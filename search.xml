<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[卸载Android微信的X5内核，如丝般顺滑]]></title>
    <url>%2Fposts%2F2019-11-15-cleanx5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;微信Android版本，每次点击链接，都要卡半天，难顶啊，怎么办呢？安排！ 微信用的是腾讯自研的X5内核，也被称为TBS的腾讯浏览服务。 腾讯说X5内核相比于系统自带的Webview： 打开网页的速度更快，更省流量而且更安全…….等等一系列的优点。 X5内核取代的就是这个安卓手机都自带的WebView组件。这个组件是基于谷歌的Chromium内核开发。 步骤只需要几个步骤，就可以用自带的Webview，抛弃腾讯的X5内核。 第一步，从微信里面进入TBS的调试模式随便打开个聊天窗口，输入以下代码： debugtbs.qq.com 文字发出去后，再点击打开，就会进入TBS调试界面 接下来先点击【内核未被禁用】，微信会自动重启一次。 重启后，显示【内核已被禁用】。 第二步，清除TBS内核点击【清除TBS内核】，页面就会提示X5内核删除成功！ 现在，就能使用系统自带的Android Webview组件来浏览网页了，而且打开网页的速度真不是X5能比的。 注意：重新使用TBS内核如果想要恢复自带的X5内核，只要回到TBS的调试界面，点击【安装线上内核】就行。 经过对比，微信打开网页慢的锅，X5内核是背定了。]]></content>
      <categories>
        <category>Wechat</category>
      </categories>
      <tags>
        <tag>Wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始-Redis入门]]></title>
    <url>%2Fposts%2F2019-10-01-Redis%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库。 1.Redis 简介Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库。 Redis 与 其他 key - value 缓存产品有以下三个特点： 1. Redis 支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 2. Redis 不仅仅支持简单的 key - value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。 3. Redis 支持数据的备份，即 master - slave 模式的数据备份。 2.Redis 优势 性能极高 – Redis 读的速度是 110000 次 /s, 写的速度是 81000 次 /s 。 丰富的数据类型 - Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子性 - Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。 其他特性 - Redis 还支持 publish/subscribe 通知，key 过期等特性。 3.Redis 数据类型Redis 支持 5 中数据类型：string（字符串），hash（哈希），list（列表），set（集合），zset（sorted set：有序集合）。 3.1 stringstring 是 redis 最基本的数据类型。一个 key 对应一个 value。 string 是二进制安全的。也就是说 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。 string 类型是 redis 最基本的数据类型，string 类型的值最大能存储 512 MB。 理解：string 就像是 java 中的 map 一样，一个 key 对应一个 value localhost:0&gt; set tfx helloredis2019 &quot;OK&quot; localhost:0&gt; get tfx &quot;helloredis2019&quot; 3.2 hashRedis hash 是一个键值对（key - value）集合。 Redis hash 是一个 string 类型的 key 和 value 的映射表，hash 特别适合用于存储对象。 理解：可以将 hash 看成一个 key - value 的集合。也可以将其想成一个 hash 对应着多个 string。 与 string 区别：string 是 一个 key - value 键值对，而 hash 是多个 key - value 键值对。 hash-key 可以看成是一个键值对集合的名字,在这里分别为其添加了 sub-key1 : value1、sub-key2 : value2、sub-key3 : value3 这三个键值对 localhost:0&gt;hset hash-key sub-key1 value1 &quot;1&quot; localhost:0&gt;hset hash-key sub-key2 value2 &quot;1&quot; localhost:0&gt;hset hash-key sub-key3 value3 &quot;1&quot; 获取 hash-key 这个 hash 里面的所有键值对 localhost:0&gt;hgetall hash-key 1) &quot;sub-key1&quot; 2) &quot;value1&quot; 3) &quot;sub-key2&quot; 4) &quot;value2&quot; 5) &quot;sub-key3&quot; 6) &quot;value3&quot; 删除 hash-key 这个 hash 里面的 sub-key2 键值对 localhost:0&gt;hdel hash-key sub-key2 &quot;1&quot; localhost:0&gt;hget hash-key sub-key2 null localhost:0&gt;hget hash-key sub-key1 &quot;value1&quot; localhost:0&gt;hgetall hash-key 1) &quot;sub-key1&quot; 2) &quot;value1&quot; 3) &quot;sub-key3&quot; 4) &quot;value3&quot; 3.3 listRedis 列表是简单的字符串列表，按照插入顺序排序，可以往列表的左边或者右边添加元素。 localhost:0&gt;rpush list-key value1 &quot;1&quot; localhost:0&gt;rpush list-key value2 &quot;2&quot; localhost:0&gt;rpush list-key value1 &quot;3&quot; localhost:0&gt;lrange list-key 0 -1 1) &quot;value1&quot; 2) &quot;value2&quot; 3) &quot;value1&quot; localhost:0&gt;lindex list-key 1 &quot;value2&quot; localhost:0&gt;lpop list-key &quot;value1&quot; localhost:0&gt;lrange list-key 0 -1 1) &quot;value2&quot; 2) &quot;value1&quot; list 是一个简单的字符串集合，和 Java 中的 list 相差不大，区别就是这里的 list 存放的是字符串。list 内的元素是可重复的。 3.4 setRedis 的 set 是字符串类型的无序集合。集合是通过哈希表实现的，因此添加、删除、查找的复杂度都是 O（1）。 localhost:0&gt;sadd key1 value1 &quot;1&quot; localhost:0&gt;sadd key1 value2 &quot;1&quot; localhost:0&gt;sadd key1 value3 &quot;1&quot; localhost:0&gt;sadd key1 value1 &quot;0&quot; localhost:0&gt;smembers key1 1) &quot;value2&quot; 2) &quot;value1&quot; 3) &quot;value3&quot; localhost:0&gt;sismember key1 value4 &quot;0&quot; localhost:0&gt;sismember key1 value1 &quot;1&quot; localhost:0&gt;srem key1 value2 &quot;1&quot; localhost:0&gt;srem key1 value2 &quot;0&quot; localhost:0&gt;smembers key1 1) &quot;value1&quot; 2) &quot;value3&quot; redis 的 set 与 java 中的 set 还是有点区别的。redis 的 set 是一个 key 对应着 多个字符串类型的 value，也是一个字符串类型的集合，但是和 redis 的 list 不同的是 set 中的字符串集合元素不能重复，但是 list 可以。 3.5 zsetredis zset 和 set 一样都是 字符串类型元素的集合，并且集合内的元素不能重复。 不同的是 zset 每个元素都会关联一个 double 类型的分数。redis 通过分数来为集合中的成员进行从小到大的排序。 zset 的元素是唯一的，但是分数（score）却可以重复。 localhost:0&gt;zadd zset-key 700 member1 &quot;1&quot; localhost:0&gt;zadd zset-key 800 member2 &quot;1&quot; localhost:0&gt;zadd zset-key 600 member2 &quot;0&quot; localhost:0&gt;zrange zset-key 0 -1 withscores 1) &quot;member2&quot; 2) &quot;600&quot; 3) &quot;member1&quot; 4) &quot;700&quot; localhost:0&gt;zrangebyscore zset-key 0 650 withscores 1) &quot;member2&quot; 2) &quot;600&quot; localhost:0&gt;zrem zset-key member1 &quot;1&quot; localhost:0&gt;zrem zset-key member1 &quot;0&quot; localhost:0&gt;zrange zset-key 0 -1 withscores 1) &quot;member2&quot; 2) &quot;600&quot; zset 是按照 分输的大小来排序的。 3.6 总结 类型简介 特性场景 string（字符串） 二进制安全可以包含任何数据，比如 jpg 图片或者序列化的对象，一个键最大能存储 521M Hash（哈希） 键值对集合，即编程语言中的 Map 类型适合存储对象，并且可以像数据库中 update 一样只修改某一项属性值存储、读取、修改用户属性 List（列表） 双向链表增删快，提供了操作某一段元素的 API 1、最新消息排行等功能（朋友圈的时间线）2、消息队列 Set（集合） 哈希表实现，元素不能重复添加删除查找的复杂度都是 O(1);为集合提供了求交集、并集、差集等操作共同好友；利用唯一性，统计访问网站的所有独立 ip；好友推荐时，根据 tag 求交集，大于某个阈值就可以推荐 Zset（有序集合） 将 Set 中的元素增加一个权重参数 score，元素按 score 有序排列数据插入集合时，已经进行天然排序排行榜；带权重的消息队列 4 发布订阅一般不用 Redis 做消息发布订阅。 Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat: localhost:0&gt;subscribe redisChat 切换到推送/订阅模式，关闭标签页来停止接收信息。 1) &quot;subscribe&quot; 2) &quot;redisChat&quot; 3) &quot;1&quot; 接下来先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。 localhost:0&gt;publish redisChat &quot;blog.iyu.pub&quot; &quot;1&quot; localhost:0&gt;publish redisChat &quot;hello redis&quot; &quot;1&quot; 在订阅者的客户端显示如下： localhost:0&gt;subscribe redisChat 切换到推送/订阅模式，关闭标签页来停止接收信息。 1) &quot;subscribe&quot; 2) &quot;redisChat&quot; 3) &quot;1&quot; 1) &quot;message&quot; 2) &quot;redisChat&quot; 3) &quot;blog.iyu.pub&quot; 1) &quot;message&quot; 2) &quot;redisChat&quot; 3) &quot;hello redis&quot; 5 事务redis 事务一次可以执行多条命令，服务器在执行命令期间，不会去执行其他客户端的命令请求。 事务中的多条命令被一次性发送给服务器，而不是一条一条地发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余命令依然被执行。也就是说 Redis 事务不保证原子性。 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中。 一个事务从开始到执行会经历以下三个阶段： 开始事务。 命令入队。 执行事务。 以下是一个事务的例子， 它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令： localhost:0&gt;multi &quot;OK&quot; localhost:0&gt;set redismulti test1 &quot;QUEUED&quot; localhost:0&gt;get redismulti &quot;QUEUED&quot; localhost:0&gt;sadd redistag value1 value2 value3 &quot;QUEUED&quot; localhost:0&gt;smembers redistag &quot;QUEUED&quot; localhost:0&gt;exec 1) &quot;OK&quot; 2) &quot;test1&quot; 3) &quot;3&quot; 4) 1) &quot;value2&quot; 2) &quot;value1&quot; 3) &quot;value3&quot; 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。 这是官网上的说明 From redis docs on transactions: It&#39;s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands. 例如： localhost:0&gt;multi &quot;OK&quot; localhost:0&gt;set a a &quot;QUEUED&quot; localhost:0&gt;set b b &quot;QUEUED&quot; localhost:0&gt;set c c &quot;QUEUED&quot; localhost:0&gt;exec 1) &quot;OK&quot; 2) &quot;OK&quot; 3) &quot;OK&quot; 如果在 set b b 处失败，set a 已成功不会回滚，set c 还会继续执行。 命令 描述 DISCARD 取消事务，放弃执行事务块内的所有命令 EXEC 执行所有事务块内的命令 MULTI 标记一个事务块的开始 UNWATCH 取消 WATCH 命令对所有 key 的监视 WATCH key [key …] 监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断 6 持久化Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 6.1 RDB 持久化将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量大，保存快照的时间会很长。 6.2 AOF 持久化将写命令添加到 AOF 文件（append only file）末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。 选项同步频率always每个写命令都同步eyerysec每秒同步一次no让操作系统来决定何时同步 always 选项会严重减低服务器的性能 everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器几乎没有任何影响。 no 选项并不能给服务器性能带来多大的提升，而且会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 7 复制通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。 一个从服务器只能有一个主服务器，并且不支持主主复制。 7.1 连接过程（1）主服务器创建快照文件，即 RDB 文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始像从服务器发送存储在缓冲区的写命令。 （2）从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。 （3）主服务器每执行一次写命令，就向从服务器发送相同的写命令。 7.2 主从链随着负载不断上升，主服务器无法很快的更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。 8 哨兵Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举处新的主服务器。 9 分片分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Redis 实例 R0, R1, R2, R3, 还有很多表示用户的键 user:1, user:2, … , 有不同的方式来选择一个指定的键存储在哪个实例中。 最简单的是范围分片，例如用户 id 从 0 ~ 1000 的存储到实例 R0 中，用户 id 从 1001 ~ 2000 的存储到实例 R1中，等等。但是这样需要维护一张映射范围表，维护操作代价高。 还有一种是哈希分片。使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道存储的实例。 根据执行分片的位置，可以分为三种分片方式： 客户端分片：客户端使用一致性哈希等算法决定应当分布到哪个节点。 代理分片：将客户端的请求发送到代理上，由代理转发到正确的节点上。 服务器分片：Redis Cluster。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Go从B站学起》第一讲:Go环境搭建]]></title>
    <url>%2Fposts%2F2019-05-01-go_learn%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;B站为了Go语言在中国的推广做出了不可磨灭的贡献。 &emsp;&emsp;但是，作为一名Go小白，怎样从零开始呢？ &emsp;&emsp;首先就是搭建Go语言环境。 &emsp;&emsp;Go官网：https://golang.google.cn &emsp;&emsp;这里教程以在Ubuntu上搭建Go环境为例： 下载Go压缩包&emsp;&emsp;点击https://golang.google.cn/dl/下载 go$VERSION.$OS-$ARCH.tar.gz &emsp;&emsp;当前最新版本为go1.12.4.linux-amd64 解压Go压缩包：tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz 配置环境变量：nano /etc/profile &emsp;&emsp;在/etc/profile的最后面加上 export PATH=$PATH:/usr/local/go/bin &emsp;&emsp;让配置文件生效： source /etc/profile 验证Go环境go version &emsp;&emsp;OK，安装完成。下一讲，你懂的，Hello World!!!(手动滑稽)]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>B站</tag>
        <tag>Bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM参数]]></title>
    <url>%2Fposts%2F2019-03-10-JVM-JVM%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JVM 参数使用手册 内存分配相关Xms 英文释义：Initial heap size(in bytes) 中文释义：堆区初始值 使用方法：-Xms2g 或 -XX:InitialHeapSize=2048m Xmx 英文释义：Maximum heap size(in bytes) 中文释义：堆区最大值 使用方法：-Xmx2g 或 -XX:MaxHeapSize=2048m Xmn 英文释义：Maximum new generation size(in bytes) 中文释义：新生代最大值 使用方法：-Xmn512m 或 -XX:MaxNewSize=512m PermSize、MetaspaceSize 英文释义：Initial size of permanent generation(in bytes) 中文释义：永久代（元空间）初始值 使用方法：-XX:PermSize=128m（1.7 之前版本）、-XX:MetaspaceSize=128m（1.7 之后版本） MaxPermSize、MetaspaceSize 英文释义：Maximum size of permanent generation(in bytes) 中文释义：永久代（元空间）最大值 使用方法：-XX:MaxPermSize=256m（1.7之前版本）、-XX：MaxMetaspaceSize=256m（1.7之后版本） Xss 英文释义：Thread Stack Size(in Kbytes) 中文释义：线程栈最大值 使用方法：-Xss256k 或 -XX:ThreadStackSize=256k GC 策略相关SurvivorRatio 英文释义：Rato of eden/survivor space size 中文释义：Eden 区和 Survivor 的比值 使用方法：-XX:SurvivorRatio=6 使用经验：默认值为 8，假如设为 6，则表示每个 Survivor 区跟 Eden 区的比值为1:6，每个 Survivor 区占新生代的八分之一 PretenureSizeThreshold 英文释义：Maximum size in bytes of objects allocated in DefNew generation;zero means no maximum 中文释义：可以在新生代直接分配的对象最大值，0表示没有最大值 使用方法：-XX:PretenureSizeThreshold=1000000 使用经验：设置该参数，可以使大于这个值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区发生大量的内存复制，该参数只对 Serial 和 ParNew 收集器有效，Parallel Scavenge并不认识该参数 MaxTenuringThreshold 英文释义：Maximum value fo tenuring threshold 中文释义：新生代最大年龄 使用方法：-XX:MaxTenuringThreshold=10 使用经验：每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代，最大支持15 ParallelGCThreads 英文释义：Number of parallel threads parallel gc will use 中文释义：并行执行gc的线程数 使用方法：-XX:ParallelGCThreads=16 UseSerialGC 英文释义：Use the Serial garbage collector 中文释义：新生代使用 Serial 垃圾收集器 使用方法：开启 -XX:+UseSerialGC、关闭 -XX:-UseSerialGC 使用经验：虚拟机在运行在 Client 模式下的默认值，老年代将会使用 SerialOld 垃圾收集器 UseParNewGC 英文释义：Use parallel threads in the new generation 中文释义：新生代使用 ParNew 垃圾收集器 使用方法：开启 -XX:+UseParNewGC、关闭 -XX:-UseParNewGC 使用经验：老年代将使用 Serial Old 收集器 CMSParallelRemarkEnabled 英文释义：Whether parallel remark enabled (only if ParNewGC) 中文释义：是否启用并行标记（仅限于ParNewGC） 使用方法：开启 -XX:+CMSParallelRemarkEnabled、关闭 -XX:-CMSParallelRemarkEnabled UseParallelGC 英文释义：Use the Parallel Scavenge garbage collector 中文释义：新生代使用 Parallel Scavenge 垃圾收集器 使用方法：开启 -XX:+UseParallelGC、关闭 -XX:-UseParallelGC 使用经验：Linux下1.6,1.7,1.8 默认开启（1.9 后默认启用 G1 收集器），老年代将会使用 Serial Old 垃圾收集器 UseAdaptiveSizePolicy 英文释义：Use adaptive generation sizing policies 中文释义：自适应调节策略，动态调整 Java 堆中各个区域的大小以及进入老年代的年龄 使用方法：开启 -XX:+UseAdaptiveSizePolicy、关闭 -XX:-UseAdaptiveSizePolicy MaxTimeRatio 英文释义： 中文释义：GC 时间占总时间的比率，默认值为 99，即允许 1% 的 GC 时间。仅在 Parallel Scavenge 收集器时生效。 使用方法：-XX:MaxTimeRatio=99 MaxGCPauseMillis 英文释义：Adaptive size policy maximum GC pause time goal in millisecond, or (G1 Only) the maximum GC time per MMU time slice 中文释义：自适应策略的最大GC暂停时间目标（以毫秒为单位），或（仅G1）每个MMU时间片的最大GC时间 使用方法：-XX:MaxGCPauseMillis=200 UseParallelOldGC 英文释义：Use the Parallel Old garbage collector 中文释义：老年代使用 Parallel Old 收集器 使用方法：开启 -XX:+UseParallelOldGC、关闭 -XX:-UseParallelOldGC 使用经验：新生代将使用 Parallel Scavenge 收集器 UseConcMarkSweepGC 英文释义：Use Concurrent Mark-Sweep GC in the old generation 中文释义：老年代使用 CMS 收集器 使用方法：开启 -XX:+UseConcMarkSweepGC、关闭 -XX:-UseConcMarkSweepGC 使用经验：年轻代将会使用 ParNew 收集器，如果出现&quot;Concurrent Mode Failure&quot;，会使用 Serial Old 收集器 CMSInitiatingOccupancyFraction 英文释义：Percentage CMS generation occupancy to start a CMS collection cycle. A negative value means that CMSTriggerRatio is used 中文释义：触发执行 CMS 回收的老年代内存空间占用的百分比，负值表示使用 CMSTriggerRatio 设置的值 使用方法：-XX:+CMSInitiatingOccupancyFraction=75 UseCMSInitiatingOccupancyOnly 英文释义：Only use occupancy as a criterion for staring a CMS collection 中文释义：只根据占用情况作为开始执行CMS收集的标准 使用方法：开启 -XX:+UseCMSInitiatingOccupancyOnly、关闭 -XX:-UseCMSInitiatingOccupancyOnly UseCMSCompactAtFullCollection 英文释义：Use Mark-Sweep-Compact algorithm at full collections 中文释义：设置 CMS 收集器在完成垃圾收集后是否要进行一次碎片整理 使用方法：开启 -XX:+UseCMSCompactAtFullCollection、关闭 -XX:-UseCMSCompactAtFullCollection CMSFullGCsBeforeCompaction 英文释义：Number of CMS full collection done before compaction if &gt; 0 中文释义：设置 CMS 收集器在进行若干次垃圾收集后再启动一次内存碎片整理。 使用方法：-XX:CMSFullGCsBeforeCompaction=1 CMSClassUnloadingEnabled 英文释义：Whether class unloading enabled when using CMS GC 中文释义：当使用CMS GC时是否启用类卸载功能 使用方法：开启 -XX:+CMSClassUnloadingEnabled、关闭 -XX:-CMSClassUnloadingEnabled UseG1GC 英文释义：Use the Garbage-First garbage collector 中文释义：使用G1垃圾收集器 使用方法：开启 -XX:+UseG1GC、关闭 -XX:-UseG1GC 使用经验：JDK 1.9 后默认选择的垃圾收集器 DisableExplicitGC 英文释义：Ignore calls to System.gc() 中文释义：禁用 System.gc() 触发FullGC 使用方法：开启 -XX:+DisableExplicitGC、关闭 -XX:-DisableExplicitGC 使用经验：不建议开启，如果开启了这个参数可能会导致对外内存无法及时回收造成对外内存溢出 GC日志相关Xloggc 英文释义：GC log file 中文释义：GC日志文件路径 使用方法：-Xloggc:/data/gclog/gc.log UseGCLogFileRotation 英文释义：Rotate gclog files(for long running applications). It requires -Xloggc: 中文释义：滚动GC日志文件，须配置Xloggc 使用方法：开启 -XX:+UseGCLogFileRotation、关闭 -XX:-UseGCLogFileRotation NumberOfGCLogFiles 英文释义：Number of gclog files in rotation(default:0,no rotation) 中文释义：滚动 GC日志文件数，默认0，不滚动 使用方法：-XX:NumberOfGCLogFiles=4 GCLogFileSize 英文释义：GC log file size,requires UseGCLogFileRotation. Set to 0 to only trigger rotation via jcmd 中文释义：GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发 使用方法：-XX:GCLogFileSize=100k PrintGCDetails 英文释义：Print more details at garbage collection 中文释义：GC时打印更多详细信息 使用方法：开启 -XX:+PrintGCDetails、关闭 -XX:-PrintGCDetails 使用经验：可以通过jinfo -flag [+|-]PrintGCDetails 或 jinfo -flag PrintGCDetails= 来动态开启或设置值 PrintGCDateStamps 英文释义：Print date stamps at garbage collection 中文释义：GC时打印时间戳信息 使用方法：开启 -XX:+PrintGCDateStamps、关闭 -XX:-PrintGCDateStamps 使用经验：可以通过jinfo -flag [+|-] PrintGCDateStamps 或 jinfo -flag PrintGCDateStamps=来动态开启或设置值 PrintTenuringDistribution 英文释义：Print tenuring age information 中文释义：打印存活实例年龄信息 使用方法：开启 -XX:+PrintTenuringDistribution、关闭 -XX:-PrintTenuringDistribution PrintGCApplicationStoppedTime 英文释义：Print the time of application has been stopped 中文释义：打印应用暂停时间 使用方法：开启 -XX:+PrintGCApplicationStoppedTime、关闭 -XX:-PrintGCApplicationStoppedTime PrintHeapAtGC 英文释义：Print heap layout before and after each GC 中文释义：GC前后打印堆区使用信息 使用方法：开启 -XX:+PrintHeapAtGC、关闭 -XX:-PrintHeapAtGC 异常相关HeapDumpOnOutOfMemoryError 英文释义：Dump heap to file when java.lang.OutOfMemoryError is thrown 中文释义：抛出内存溢出错误时导出堆信息到指定文件 使用方法：开启 -XX:+HeapDumpOnOutOfMemoryError、关闭 -XX:-HeapDumpOnOutOfMemoryError 使用经验：可以通过 jinfo -flag [+|-]HeapDumpOnOutOfMemoryError 或 jinfo -flag HeapDumpOnOutOfMemoryError= 来动态开启或设置值 HeapDumpPath 英文释义：When HeapDumpOnOutOfMemoryError is on, the path(filename or directory) of the dump file(defaults to java_pid.hprof in the working directory) 中文释义：当 HeapDumpOnOutOfMemoryError 开启的时候，dump 文件的保存路径，默认为工作目录下的 java_pid.hprof 文件 使用方法：-XX:HeapDumpPath=/data/dump/jvm.dump 其他server 英文释义：server mode 中文释义：服务端模式 使用方法：-server TieredCompilation 英文释义：Enable tiered compilation 中文释义：启用多层编译 使用方法：开启 -XX:+TieredCompilation、关闭 -XX:-TieredCompilation]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-锁优化策略]]></title>
    <url>%2Fposts%2F2019-03-09-JVM-%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 1 自旋锁背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。 原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。 优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效； 缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。 自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。 2 锁清除编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。 3 锁粗化若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。 4 轻量级锁本质：使用CAS取代互斥同步。 背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁。 轻量级锁与重量级锁的比较： 重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全； 而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。 实现原理： 对象头称为『Mark Word』，虚拟机为了节约对象的存储空间，对象处于不同的状态下，Mark Word中存储的信息也所有不同。 Mark Word中有个标志位用来表示当前对象所处的状态。 当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录； 若CAS操作成功，则轻量级锁的上锁过程成功； 若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。 前提：轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，不存在其他线程的竞争。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！ 5 偏向锁作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。 与轻量级锁的区别：轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。 与轻量级锁的相同点：它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。 原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。 优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。 偏向锁可以通过虚拟机的参数来控制它是否开启。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类加载]]></title>
    <url>%2Fposts%2F2019-03-08-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 1 类加载的时机1.1 类的生命周期![JVM_09.png](https://i.loli.net/2019/11/13/hVylYoAd3ic5P69.png) 一个类从加载进内存到卸载出内存为止，一共经历7个阶段： 加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化——&gt;使用——&gt;卸载 其中，类加载包括5个阶段： 加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化 在类加载的过程中，以下3个过程称为连接： 验证——&gt;准备——&gt;解析 因此，JVM的类加载过程也可以概括为3个过程： 加载——&gt;连接——&gt;初始化 加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定。 C/C++在运行前需要完成预处理、编译、汇编、链接；而在Java中，类加载(加载、连接、初始化)是在程序运行期间完成的。 在程序运行期间进行类加载会稍微增加程序的开销，但随之会带来更大的好处——提高程序的灵活性。Java语言的灵活性体现在它可以在运行期间 动态扩展 ，所谓动态扩展就是在运行期间 动态加载 和 动态连接 。 1.2 类加载的时机1.2.1 类加载过程中每个步骤的顺序我们已经知道，类加载的过程包括：加载、连接、初始化，连接又分为：验证、准备、解析，所以说类加载一共分为5步：加载、验证、准备、解析、初始化。 其中加载、验证、准备、初始化的 开始 顺序是依次进行的，这些步骤开始之后的过程可能会有重叠。 而解析过程会发生在初始化过程中。 1.2.2 类加载过程中“初始化”开始的时机JVM规范中只定义了类加载过程中初始化过程开始的时机，加载、连接过程都应该在初始化之前开始(解析除外)，这些过程具体在何时开始，JVM规范并没有定义，不同的虚拟机可以根据具体的需求自定义。 初始化开始的时机： 在运行过程中遇到如下字节码指令时，如果类尚未初始化，那就要进行初始化：new、getstatic、putstatic、invokestatic。 这四个指令对应的Java代码场景是： 通过new创建对象； 读取、设置一个类的静态成员变量（不包括final修饰的静态变量）； 调用一个类的静态成员函数。 使用java.lang.reflect进行反射调用的时候，如果类没有初始化，那就需要初始化； 当初始化一个类的时候，若其父类尚未初始化，那就先要让其父类初始化，然后再初始化本类； 当虚拟机启动时，虚拟机会首先初始化带有main方法的类，即主类； Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行“初始化”： (1)在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。 (2)对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。 (3)初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。 (4)虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。 (5)当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。 这 5 种场景中的行为称为对一个类进行主动引用，除此之外，其它所有引用类的方式都不会触发初始化，称为被动引用。 1.2.3 主动引用 与 被动引用JVM规范中要求在程序运行过程中，“当且仅当”出现上述4个条件之一的情况才会初始化一个类。如果间接满足上述初始化条件是不会初始化类的。 其中，直接满足上述初始化条件的情况叫做 主动引用 ；间接满足上述初始化过程的情况叫做 被动引用 。 那么，只有当程序在运行过程中满足主动引用的时候才会初始化一个类，若满足被动引用就不会初始化一个类。 1.2.4 被动引用的场景示例Demo1 public class Fu&#123; public static String name = &quot;听风行&quot;; static&#123; System.out.println(&quot;父类被初始化！&quot;); &#125; &#125; public class Zi&#123; static&#123; System.out.println(&quot;子类被初始化！&quot;); &#125; &#125; public static void main(String[] args)&#123; System.out.println(Zi.name); &#125; &#125; 输出结果： 父类被初始化！ 听风行 原因分析： 本示例看似满足初始化时机的第一条：当要获取某一个类的静态成员变量的时候如果该类尚未初始化，则对该类进行初始化。 但由于这个静态成员变量属于Fu类，Zi类只是间接调用Fu类中的静态成员变量，因此Zi类调用name属性属于间接引用，而Fu类调用name属性属于直接引用，由于JVM只初始化直接引用的类，因此只有Fu类被初始化。 Demo2 public class A&#123; public static void main(String[] args)&#123; Fu[] arr = new Fu[10]; &#125; &#125; 输出结果： 并没有输出“父类被初始化！” 原因分析： 这个过程看似满足初始化时机的第一条：遇到new创建对象时若类没被初始化，则初始化该类。 但现在通过new要创建的是一个数组对象，而非Fu类对象，因此也属于间接引用，不会初始化Fu类。 Demo3 public class Fu&#123; public static final String name = &quot;听风行&quot;; static&#123; System.out.println(&quot;父类被初始化！&quot;); &#125; &#125; public class A&#123; public static void main(String[] args)&#123; System.out.println(Fu.name); &#125; &#125; &#125; 输出结果： 听风行 原因分析： 本示例看似满足类初始化时机的第一个条件：获取一个类静态成员变量的时候若类尚未初始化则初始化类。 但是，Fu类的静态成员变量被final修饰，它已经是一个常量。被final修饰的常量在Java代码编译的过程中就会被放入它被引用的class文件的常量池中（这里是A的常量池）。所以程序在运行期间如果需要调用这个常量，直接去当前类的常量池中取，而不需要初始化这个类。 Demo4 /** * 被动引用 Demo1: * 通过子类引用父类的静态字段，不会导致子类初始化。 */ class SuperClass &#123; static &#123; System.out.println(&quot;SuperClass init!&quot;); &#125; public static int value = 123; &#125; class SubClass extends SuperClass &#123; static &#123; System.out.println(&quot;SubClass init!&quot;); &#125; &#125; public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); // SuperClass init! &#125; &#125; 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。 Demo5 /** * 被动引用 Demo2: * 通过数组定义来引用类，不会触发此类的初始化。 */ public class NotInitialization &#123; public static void main(String[] args) &#123; SuperClass[] superClasses = new SuperClass[10]; &#125; &#125; 这段代码不会触发父类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。 Demo6 /** * 被动引用 Demo3: * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 */ class ConstClass &#123; static &#123; System.out.println(&quot;ConstClass init!&quot;); &#125; public static final String HELLO_BINGO = &quot;Hello Bingo&quot;; &#125; public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLO_BINGO); &#125; &#125; 编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。 1.2.5 接口的初始化(接口的加载过程)接口和类都需要初始化，接口和类的初始化过程基本一样，不同点在于：类初始化时，如果发现父类尚未被初始化，则先要初始化父类，然后再初始化自己；但接口初始化时，并不要求父接口已经全部初始化，只有程序在运行过程中用到当父接口中的东西时才初始化父接口。 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。 2 类加载的过程通过之前的介绍可知，类加载过程共有5个步骤，分别是：加载、验证、准备、解析、初始化。其中，验证、准备、解析称为连接。下面详细介绍这5个过程JVM所做的工作。 2.1 加载注意：“加载”是“类加载”过程的第一步，不能混淆这两个名词。 在加载过程中，JVM主要做3件事情： (1)通过一个类的全限定名来获取这个类的二进制字节流，即class文件： 在程序运行过程中，当要访问一个类时，若发现这个类尚未被加载，并满足类初始化时机的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程。 (2)将二进制字节流的存储结构转化为特定的数据结构，存储在方法区中；[将二进制字节流所代表的静态结构转化为方法区的运行时数据结构] (3)在内存中创建一个代表该类的java.lang.Class类型的对象，作为方法区这个类的各种数据的访问入口。 接下来程序在运行过程中所有对该类的访问都通过这个类对象，也就是这个Class类型的类对象是提供给外界访问该类的接口。 (1)获取二进制字节流 JVM规范对于加载过程给予了较大的宽松度。一般二进制字节流都从已经编译好的本地class文件中读取，此外还可以从以下地方读取： a.从压缩包zip中读取，如：Jar、War、Ear等。 b.从网络中获取，从网络中获取二进制字节流。如：Applet。 c.通过动态代理计数生成代理类的二进制字节流 d.从其它文件中动态生成，如：从JSP文件中生成Class类。 e.从数据库中读取，将二进制字节流存储至数据库中，然后在加载时从数据库中读取。有些中间件会这么做，用来实现代码在集群间分发。如：有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 (2)类 和 数组加载过程的区别？ 数组也有类型，称为“数组类型”。如： String[] str = new String[10]; 这个数组的数组类型是Ljava.lang.String，而String只是这个数组中元素的类型。 当程序在运行过程中遇到new关键字创建一个数组时，由JVM直接创建数组类，再由类加载器创建数组中的元素类。 而普通类的加载由类加载器完成。既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器。 a.非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 loadClass() 方法） b.数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。 (3)加载过程的注意点 a.JVM规范并未给出类在方法区中存放的数据结构 类完成加载后，二进制字节流就以特定的数据结构存储在方法区中，但存储的数据结构是由虚拟机自己定义的，JVM规范并没有指定。 b.JVM规范并没有指定Class对象存放的位置 在二进制字节流以特定格式存储在方法区后，JVM会创建一个java.lang.Class类型的对象，作为本类的外部接口。既然是对象就应该存放在堆内存中，不过JVM规范并没有给出限制，不同的虚拟机根据自己的需求存放这个对象。HotSpot将Class对象存放在方法区。 c.加载阶段和连接阶段是交叉的 通过之前的介绍可知，类加载过程中每个步骤的开始顺序都有严格限制，但每个步骤的结束顺序没有限制。也就是说，类加载过程中，必须按照如下顺序开始： 加载、连接、初始化，但结束顺序无所谓，因此由于每个步骤处理时间的长短不一就会导致有些步骤会出现交叉。 虚拟机规范未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中。 加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始实践仍然保持着固定的先后顺序。 2.2 验证验证阶段比较耗时，它非常重要但不一定必要，如果所运行的代码已经被反复使用和验证过，那么可以使用-Xverify:none参数关闭，以缩短类加载时间。 2.2.1 验证的目的验证是为了保证二进制字节流中的信息符合虚拟机规范，并没有安全问题。验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 为什么需要验证？ 虽然Java语言是一门安全的语言，它能确保程序猿无法访问数组边界以外的内存、避免让一个对象转换成任意类型、避免跳转到不存在的代码行，如果出现这些情况，编译无法通过。也就是说，Java语言的安全性是通过编译器来保证的。 但是我们知道，编译器和虚拟机是两个独立的东西，虚拟机只认二进制字节流，它不会管所获得的二进制字节流是哪来的，当然，如果是编译器给它的，那么就相对安全，但如果是从其它途径获得的，那么无法确保该二进制字节流是安全的。通过上文可知，虚拟机规范中没有限制二进制字节流的来源，那么任意来源的二进制字节流虚拟机都能接受，为了防止字节流中有安全问题，因此需要验证！ 2.2.2 验证的过程（1）文件格式验证 这个阶段主要验证输入的二进制字节流是否符合class文件结构的规范。二进制字节流只有通过了本阶段的验证，才会被允许存入到方法区中。 本验证阶段是基于二进制字节流的，而后面的三个验证阶段都是在方法区中进行，并基于类特定的数据结构的。 通过上文可知，加载开始前，二进制字节流还没进方法区，而加载完成后，二进制字节流已经存入方法区。而在文件格式验证前，二进制字节流尚未进入方法区，文件格式验证通过之后才进入方法区。也就是说，加载开始后，立即启动了文件格式验证，本阶段验证通过后，二进制字节流被转换成特定数据结构存储至方法区中，继而开始下阶段的验证和创建Class对象等操作。这个过程印证了：加载和验证是交叉进行的。 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下： a.是否以魔数 0XCAFEBABE 开头 b.主次版本号是否在当前虚拟机处理范围内 c.常量池是否有不被支持的常量类型 d.指向常量的索引值是否指向了不存在的常量 e.CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据 f....... （2）元数据验证 本阶段对方法区中的字节码描述信息进行语义分析，确保其符合Java语法规范。 （3）字节码验证 本阶段是验证过程的最复杂的一个阶段。对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。 （4）符号引用验证，本阶段验证发生在解析阶段，确保解析能正常执行。 2.3 准备准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。 准备阶段完成两件事情： (1)为已经在方法区中的类中的静态成员变量分配内存 类的静态成员变量也存储在方法区中。 (2)为静态成员变量设置初始值 初始值为0、false、null等。 示例1： public static String name = “听风行”; 在准备阶段，JVM会在方法区中为name分配内存空间，并赋上初始值null。 给name赋上”柴毛毛”是在初始化阶段完成的。 示例2: public static final String name = “听风行”; 被final修饰的常量如果有初始值，那么在编译阶段就会将初始值存入constantValue属性中，在准备阶段就将constantValue的值赋给该字段。 2.4 解析解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。 2.5 初始化类初始化阶段是类加载过程的最后一步，是执行类构造器() 的过程。 () 方法由编译器自动产生，收集类中static{}代码块中的类变量赋值语句和类中静态成员变量的赋值语句。在准备阶段，类中静态成员变量已经完成了默认初始化，而在初始化阶段，clinit()方法对静态成员变量进行显示初始化。 () 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。 初始化过程的注意点： clinit()方法中静态成员变量的赋值顺序是根据Java代码中成员变量的出现的顺序决定的。 静态代码块能访问出现在静态代码块之前的静态成员变量，无法访问出现在静态代码块之后的成员变量。 静态代码块能给出现在静态代码块之后的静态成员变量赋值。 构造函数init()需要显示调用父类构造函数，而类的构造函数clinit()不需要调用父类的类构造函数，因为虚拟机会确保子类的clinit()方法执行前已经执行了父类的clinit()方法。 如果一个类/接口中没有静态代码块，也没有静态成员变量的赋值操作，那么编译器就不会生成clinit()方法。 接口也需要通过clinit()方法为接口中定义的静态成员变量显示初始化。 接口中不能使用静态代码块。 接口在执行clinit()方法前，虚拟机不会确保其父接口的clinit()方法被执行，只有当父接口中的静态成员变量被使用到时才会执行父接口的clinit()方法。 虚拟机会给clinit()方法加锁，因此当多条线程同时执行某一个类的clinit()方法时，只有一个方法会被执行，其它的方法都被阻塞。并且，只要有一个clinit()方法执行完，其它的clinit()方法就不会再被执行。因此，在同一个类加载器下，同一个类只会被初始化一次。 静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示： public class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.out.println(i); // 这句编译器会提示“非法向前引用” } static int i = 1; } () 方法不需要显式调用父类构造器，虚拟机会保证在子类的 () 方法执行之前，父类的 () 方法已经执行完毕。 由于父类的 () 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示： static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125; &#125; static class Sub extends Parent &#123; public static int B = A; &#125; public static void main(String[] args) &#123; System.out.println(Sub.B); // 输出 2 &#125; () 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 () 方法。 接口中不能使用静态代码块，但接口也需要通过 () 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 () 方法不需要先执行父类的 () 方法，只有当父接口中定义的变量使用时，父接口才会初始化。 虚拟机会保证一个类的 () 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 () 方法。 3 类加载器3.1 类与类加载器类加载器的作用：将class文件加载进JVM的方法区，并在方法区中创建一个java.lang.Class对象作为外界访问这个类的接口。 类与类加载器的关系：比较两个类是否相等，只有当这两个类由同一个加载器加载才有意义；否则，即使同一个class文件被不同的类加载器加载，那这两个类必定不同，即通过类的Class对象的equals执行的结果必为false。 任意一个类，都由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。 因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。 这里的“相等”，包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。 3.2 类加载器种类JVM提供如下三种类加载器： （1）启动类加载器（Bootstrap ClassLoader）: 负责加载Java_Home\lib中的class文件。 负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 （2）扩展类加载器（Extension ClassLoader）: 负责加载Java_Home\lib\ext目录下的class文件。 负责加载 &lt;JAVA_HOME&gt;\lib\ext 目录中的所有类库，开发者可以直接使用扩展类加载器。 （3）应用程序类加载器（Application ClassLoader）: 负责加载用户classpath下的class文件。 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 ![JVM_10.png](https://i.loli.net/2019/11/13/ZypIbv8KAX3iz1J.png) 当然，如果有必要，还可以加入自己定义的类加载器。 3.3 双亲委派模型3.3.1 双亲委派模型的定义双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码） 3.3.2 工作过程如果一个类加载器收到了加载类的请求，它首先将请求交由父类加载器加载；若父类加载器加载失败，当前类加载器才会自己加载类。 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。 在 java.lang.ClassLoader 中的 loadClass() 方法中实现该过程。 3.3.3 作用像java.lang.Object这些存放在rt.jar中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的Object类都是同一个。 相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。 3.3.4 原理双亲委派模型的代码在java.lang.ClassLoader类中的loadClass函数中实现，其逻辑如下： 首先检查类是否被加载； 若未加载，则调用父类加载器的loadClass方法； 若该方法抛出ClassNotFoundException异常，则表示父类加载器无法加载，则当前类加载器调用findClass加载类； 若父类加载器可以加载，则直接返回Class对象；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类文件结构]]></title>
    <url>%2Fposts%2F2019-03-07-JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 1 JVM的“无关性”Java具有平台无关性，也就是任何操作系统都能运行Java代码。之所以能实现这一点，是因为Java运行在虚拟机之上，不同的操作系统都拥有各自的Java虚拟机，因此Java能实现“一次编写，处处运行”。 而JVM不仅具有平台无关性，还具有语言无关性。 平台无关性是指不同操作系统都有各自的JVM，而语言无关性是指Java虚拟机能运行除Java以外的代码！ (1)平台无关性：任何操作系统都能运行 Java 代码 (2)语言无关性： JVM 能运行除 Java 以外的其他代码 这听起来非常惊人，但JVM对能运行的语言是有严格要求的。首先来了解下Java代码的运行过程。 Java源代码首先需要使用Javac编译器编译成.class文件，然后启动JVM执行.class文件，从而程序开始运行。 也就是JVM只认识.class文件，它并不管何种语言生成了.class文件，只要.class文件符合JVM的规范就能运行。 因此目前已经有Scala、JRuby、Jython等语言能够在JVM上运行。它们有各自的语法规则，不过它们的编译器都能将各自的源码编译成符合JVM规范的class文件，从而能够借助JVM运行它们。 Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的， 因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。 因此，有一些 Java 语言本身无法有效支持的语言特性，不代表字节码本身无法有效支持。 2 Class文件结构class文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全是连续的0/1。class文件中的所有内容被分为两种类型：无符号数 和 表。 (1)无符号数：它表示Class文件中的值，这些值没有任何类型，但有不同的长度。根据这些值长度的不同分为：u1、u2、u4、u8，分别代表1字节的无符号数、2字节的无符号数、4字节的无符号数、8字节的无符号数。 (2)表：由多个无符号数或者其他表作为数据项构成的符合数据类型。class文件中所有数据（即无符号数）要么单独存在，要么由多个无符号数组成二维表。即class文件中的数据要么是单个值，要么是二维表。 2.1 class文件的组织结构魔数 本文件的版本信息 常量池 访问标志 类索引、父类索引、接口索引集合 字段表集合 方法表集合 属性表集合 2.1.1 Class文件的构成1：魔数class文件的头4个字节称为魔数，用来表示这个class文件的类型。 魔数的作用就相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在class文件中标示文件类型比较合适。 class文件的魔数是用16进制表示的“CAFEBABE”，非常具有浪漫主义色彩！ 2.1.2 Class文件的构成2：版本信息紧接着魔数的4个字节是版本号。5-6 字节表示次版本号，7-8 字节表示主版本号，它表示当前class文件中使用的是哪个版本的JDK。 在高版本的JVM上能够运行低版本的class文件，但在低版本的JVM上无法运行高版本的class文件，即使该class文件中没有用到任何高版本JDK的特性也无法运行，虚拟机也必需拒绝执行超过其版本号的 Class 文件。 2.1.3 Class文件的构成3：常量池2.1.3.1 常量池的定义紧接着版本号之后的就是常量池。常量池中存放两种类型的常量： （1）字面值常量 字面值常量即我们在程序中定义的字符串、被final修饰的值。 （2）符号引用 符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符 2.1.3.2 常量池的特点（1）常量池长度不固定 常量池的大小是不固定的，因此常量池开头放置一个u2类型的无符号数，用来存储当前常量池的容量。JVM根据这个值就知道常量池的头尾来。 注： 这个值是从1开始的，若为5表示池中有4个常量。 （2）常量池中的常量由表来表示 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。 常量池开头有个常量池容量计数器，接下来就全是一个个常量了，只不过常量都是由一张张二维表构成，除了记录常量的值以外，还记录当前常量的相关信息。 常量池是class文件的资源仓库 常量池是与本class中其它部分关联最多的部分 常量池是class文件中空间占用最大的部分之一 2.1.3.3 常量池中常量的类型刚才介绍了，常量池中的常量大体上分为：字面值常量 和 符号引用。在此基础上，根据常量的数据类型不同，又可以被细分为14种常量类型。这14种常量类型都有各自的二维表示结构。每种常量类型的头1个字节都是tag，用于表示当前常量属于14种类型中的哪一个。 类型 tag 描述 CONSTANT_utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整型字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info 5 长整型字面量 CONSTANT_Double_info 6 双精度浮点型字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型字面量 CONSTANT_Fieldref_info 9 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的符号引用 CONSTANT_MethodHandle_info 15 表示方法句柄 CONSTANT_MethodType_info 16 标识方法类型 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 以CONSTANT_Class_info常量（此类型的常量代表一个类或者接口的符号引用）为例，它的二维表示结构如下： 类型 名称 数量 u1 tag 1 u2 name_index 1 tag是标志位，用于区分常量类型，表示当前常量的类型(当前常量为CONSTANT_Class_info，因此tag的值应为7，表示一个类或接口的全限定名)； name_index 是一个索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表这个类（或接口）的全限定名，这里 name_index 值若为 0x0002，也即是指向了常量池中的第二项常量。表示这个类或接口全限定名的位置。它的值表示指向常量池的第几个常量。它会指向一个CONSTANT_Utf8_info类型的常量，CONSTANT_Utf8_info的二维表结构如下： 类型 名称 数量 u1 tag 1 u2 length 1 u1 bytes length CONSTANT_Utf8_info表示字符串常量； tag表示当前常量的类型，这里应该是1；length表示这个字符串的长度；bytes为这个字符串的内容（采用缩略的UTF8编码） 问：为什么Java中定义的类、变量名字必须小于64K？ 类、接口、变量等名字都属于符号引用，它们都存储在常量池中。而不管哪种符号引用，它们的名字都由CONSTANT_Utf8_info类型的常量表示，这种类型的常量使用u2存储字符串的长度。由于2字节最多能表示65535个数，因此这些名字的最大长度最多只能是64K。 问：什么是UTF-8编码？什么是缩略UTF-8编码？ 前者每个字符使用3个字节表示，而后者把128个ASKII码用1字节表示，某些字符用2字节表示，某些字符用3字节表示。 2.1.4 Class文件的构成4：访问标志在常量池之后是2字节的访问标志。访问标志是用来表示这个class文件是类还是接口、是否被public修饰、是否被abstract修饰、是否被final修饰等。 由于这些标志都由是/否表示，因此可以用0/1表示。 访问标志为2字节，可以表示16位标志，但JVM目前只定义了8种，未定义的直接写0. 2.1.5 Class文件的构成5：类索引、父类索引、接口索引集合类索引、父类索引、接口索引集合是用来表示当前class文件所表示类的名字、父类名字、接口们的名字。 它们按照顺序依次排列，类索引和父类索引各自使用一个u2类型的无符号常量，这个常量指向CONSTANT_Class_info类型的常量，该常量的bytes字段记录了本类、父类的全限定名。 由于一个类的接口可能有好多个，因此需要用一个集合来表示接口索引，它在类索引和父类索引之后。这个集合头两个字节表示接口索引集合的长度，接下来就是接口的名字索引。 类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。 由于 Java 不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为 u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。 类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。 2.1.6 Class文件的构成6：字段表的集合2.1.6.1 什么是字段表集合？字段表集合用于存储本类所涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量。 每一个字段表只表示一个成员变量，本类中所有的成员变量构成了字段表集合。 2.1.6.2 字段表结构的定义 类型 名称 数量 说明 u2 access_flags 1 字段的访问标志，与类稍有不同 u2 name_index 1 字段名字的索引 u2 descriptor_index 1 描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。 u2 attributes_count 1 属性表集合的长度 u2 attributes attributes_count 属性表集合，用于存放属性的额外信息，如属性的值。 access_flags：字段的访问标志。在Java中，每个成员变量都有一系列的修饰符，和上述class文件的访问标志的作用一样，只不过成员变量的访问标志与类的访问标志稍有区别。 name_index：本字段名字的索引。指向一个CONSTANT_Class_info类型的常量，这里面存储了本字段的名字等信息。 descriptor_index：描述符。用于描述本字段在Java中的数据类型等信息（下面详细介绍）。 attributes_count：属性表集合的长度。 attributes：属性表集合。到descriptor_index为止是字段表的固定信息，光有上述信息可能无法完整地描述一个字段，因此用属性表集合来存放额外的信息，比如一个字段的值（下面会详细介绍）。 2.1.6.3 什么是描述符？成员变量（包括静态成员变量和实例变量）和 方法都有各自的描述符。 对于字段而言，描述符用于描述字段的数据类型； 对于方法而言，描述符用于描述字段的数据类型、参数列表、返回值。 在描述符中，基本数据类型用大写字母表示，对象类型用“L对象类型的全限定名”表示，数组用“[数组类型的全限定名”表示。 描述方法时，将参数根据上述规则放在()中，()右侧按照上述方法放置返回值。而且，参数之间无需任何符号。 2.1.6.4 字段表集合的注意点字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 一个class文件的字段表集合中不能出现从父类/接口继承而来的字段； 一个class文件的字段表集合中可能会出现程序没有定义的字段 如编译器会自动地在内部类的class文件的字段表集合中添加外部类对象的成员变量，供内部类访问外部类。 Java中只要两个字段名字相同就无法通过编译。但在JVM规范中，允许两个字段的名字相同但描述符不同的情况，并且认为它们是两个不同的字段。 2.1.7 Class文件的构成7：方法表的集合在class文件中，所有的方法以二维表的形式存储，每张表来表示一个函数，一个类中的所有方法构成方法表的集合。 方法表的结构和字段表的结构一致，只不过访问标志和属性表集合的可选项有所不同。 volatile 关键字 和 transient 关键字不能修饰方法，所以方法表的访问标志中没有 ACC_VOLATILE 和 ACC_TRANSIENT 标志。 方法表的属性表集合中有一张Code属性表，用于存储当前方法经编译器编译过后的字节码指令。 方法表集合的注意点 如果本class没有重写父类的方法，那么本class文件的方法表集合中是不会出现父类/父接口的方法表； 本class的方法表集合可能出现程序猿没有定义的方法 编译器在编译时会在class文件的方法表集合中加入类构造器和实例构造器。 重载一个方法需要有相同的简单名称和不同的特征签名。JVM的特征签名和Java的特征签名有所不同： Java特征签名：方法参数在常量池中的字段符号引用的集合 JVM特征签名：方法参数＋返回值 2.1.8 Class文件的构成8：属性表的集合每个属性对应一张属性表，属性表的结构如下： 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u1 info attribute_length]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-JVM性能调优]]></title>
    <url>%2Fposts%2F2019-03-06-JVM-JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 在高性能硬件上部署程序，目前主要有两种方式： (1)通过 64 位 JDK 来使用大内存；(2)使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。 1 使用 64 位 JDK 管理大内存堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。 如果堆内存为14 G，那么每次 Full GC 将长达数十秒。如果 Full GC 频繁发生，那么对于一个网站来说是无法忍受的。 对于用户交互性强、对停顿时间敏感的系统，可以给 Java 虚拟机分配超大堆的前提是有把握把应用程序的 Full GC 频率控制得足够低，至少要低到不会影响用户使用。 可能面临的问题： (1)内存回收导致的长时间停顿； (2)现阶段，64位 JDK 的性能普遍比 32 位 JDK 低； (3)需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生超过 10GB 的 Dump 文件），哪怕产生了快照也几乎无法进行分析； (4)相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。 2 使用 32 位 JVM 建立逻辑集群在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口， 然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。 考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性能需求， 也不需要保证每个虚拟机进程有绝对的均衡负载，因此使用无 Session 复制的亲合式集群是一个不错的选择。 我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据 SessionID 分配） 将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可。 可能遇到的问题： (1)尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致 IO 异常； (2)很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余； (3)各个节点受到 32 位的内存限制； (4)大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。 3 调优案例分析与实战3.1 场景描述一个小型系统，使用 32 位 JDK，4G 内存，测试期间发现服务端不定时抛出内存溢出异常。 加入 -XX:+HeapDumpOnOutOfMemoryError（添加这个参数后，堆内存溢出时就会输出异常日志）， 但再次发生内存溢出时，没有生成相关异常日志。 3.2 分析在 32 位 JDK 上，1.6G 分配给堆，还有一部分分配给 JVM 的其他内存，直接内存最大也只能在剩余的 0.4G 空间中分出一部分， 如果使用了 NIO，JVM 会在 JVM 内存之外分配内存空间，那么就要小心“直接内存”不足时发生内存溢出异常了。 3.3 直接内存的回收过程直接内存虽然不是 JVM 内存空间，但它的垃圾回收也由 JVM 负责。 垃圾收集进行时，虚拟机虽然会对直接内存进行回收， 但是直接内存却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收， 它只能等老年代满了后 Full GC，然后“顺便”帮它清理掉内存的废弃对象。 否则只能一直等到抛出内存溢出异常时，先 catch 掉，再在 catch 块里大喊 “System.gc()”。 要是虚拟机还是不听，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-内存分配与回收策略]]></title>
    <url>%2Fposts%2F2019-03-05-JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 Java所承诺的自动内存管理主要是针对对象内存的回收和对象内存的分配。 对象的内存分配，就是在堆上分配（也可能经过 JIT 编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的 Eden 区上，少数情况下可能直接分配在老年代，分配规则不固定，取决于当前使用的垃圾收集器组合以及相关的参数配置。 在Java虚拟机的五块内存空间中，程序计数器、Java虚拟机栈、本地方法栈内存的分配和回收都具有确定性，一半都在编译阶段就能确定下来需要分配的内存大小，并且由于都是线程私有，因此它们的内存空间都随着线程的创建而创建，线程的结束而回收。也就是这三个区域的内存分配和回收都具有确定性。 而Java虚拟机中的方法区因为是用来存储类信息、常量 静态变量，这些数据的变动性较小，因此不是Java内存管理重点需要关注的区域。 而对于堆，所有线程共享，所有的对象都需要在堆中创建和回收。虽然每个对象的大小在类加载的时候就能确定，但对象的数量只有在程序运行期间才能确定，因此堆中内存的分配具有较大的不确定性。此外，对象的生命周期长短不一，因此需要针对不同生命周期的对象采用不同的内存回收算法，增加了内存回收的复杂性。 综上所述：Java自动内存管理最核心的功能是堆内存中对象的分配与回收。 1 对象优先在 Eden 区中分配目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代。 在新生代中为了防止内存碎片问题，因此垃圾收集器一般都选用“复制”算法。因此，堆内存的新生代被进一步分为：Eden区＋Survior1区＋Survior2区。 每次创建对象时，首先会在Eden区中分配。 若Eden区已满，则在Survior1区中分配。 若Eden区＋Survior1区剩余内存太少，导致对象无法放入该区域时，就会启用“分配担保”，将当前Eden区＋Survior1区中的对象转移到老年代中，然后再将新对象存入Eden区。 大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 Minor GC vs Major GC/Full GC： Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。 Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。 在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。 2 大对象直接进入老年代所谓“大对象”就是指一个占用大量连续存储空间的对象，如数组。 大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或数据。 当发现一个大对象在Eden区＋Survior1区中存不下的时候就需要分配担保机制把当前Eden区＋Survior1区的所有对象都复制到老年代中去。 我们知道，一个大对象能够存入Eden区＋Survior1区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及到大量的复制，就会造成效率低下。 因此，对于大对象我们直接把他放到老年代中去，从而就能避免大量的复制操作。 那么，什么样的对象才是“大对象”呢？ 通过-XX:PretrnureSizeThreshold参数设置大对象 该参数用于设置大小超过该参数的对象被认为是“大对象”，直接进入老年代。 注意： 该参数只对Serial和ParNew收集器有效。 一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。 虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。（还记得吗，新生代采用复制算法回收垃圾） 3 生命周期较长的对象进入老年代(长期存活的对象将进入老年代)JVM 给每个对象定义了一个对象年龄计数器。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。使用 -XXMaxTenuringThreshold 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。 老年代用于存储生命周期较长的对象，那么我们如何判断一个对象的年龄呢？ 新生代中的每个对象都有一个年龄计数器，当新生代发生一次MinorGC后，存活下来的对象的年龄就加一，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。 使用-XXMaxTenuringThreshold设置新生代的最大年龄 设置该参数后，只要超过该参数的新生代对象都会被转移到老年代中去。 4 相同年龄的对象内存超过Survior内存一半的对象进入老年代(动态对象年龄判定)如果当前新生代的Survior中，年龄相同的对象的内存空间总和超过了Survior内存空间的一半，那么所有年龄相同的对象和超过该年龄的对象都被转移到老年代中去。无需等到对象的年龄超过MaxTenuringThreshold才被转移到老年代中去。 5 “分配担保”策略详解(空间分配担保)JDK 6 Update 24 之前的规则是这样的： 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立，Minor GC 可以确保是安全的； 如果不成立，则虚拟机会查看 HandlePromotionFailure 值是否设置为允许担保失败， 如果是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那此时也要改为进行一次 Full GC。 JDK 6 Update 24 之后的规则变为： 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。 通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。 当垃圾收集器准备要在新生代发起一次MinorGC时，首先会检查“老年代中最大的连续空闲区域的大小 是否大于 新生代中所有对象的大小？”，也就是老年代中目前能够将新生代中所有对象全部装下？ 若老年代能够装下新生代中所有的对象，那么此时进行MinorGC没有任何风险，然后就进行MinorGC。 若老年代无法装下新生代中所有的对象，那么此时进行MinorGC是有风险的，垃圾收集器会进行一次预测：根据以往MinorGC过后存活对象的平均数来预测这次MinorGC后存活对象的平均数。 如果以往存活对象的平均数小于当前老年代最大的连续空闲空间，那么就进行MinorGC，虽然此次MinorGC是有风险的。 如果以往存活对象的平均数大于当前老年代最大的连续空闲空间，那么就对老年代进行一次Full GC，通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。 这个过程就是分配担保。 注意： 分配担保是老年代为新生代作担保； 新生代中使用“复制”算法实现垃圾回收，老年代中使用“标记-清除”或“标记-整理”算法实现垃圾回收，只有使用“复制”算法的区域才需要分配担保，因此新生代需要分配担保，而老年代不需要分配担保。 总结一下有哪些情况可能会触发 JVM 进行 Full GC： (1)System.gc() 方法的调用 此方法的调用是建议 JVM 进行 Full GC，注意这只是建议而非一定，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。 (2)老年代空间不足 老年代空间不足会触发 Full GC操作，若进行该操作后空间依然不足，则会抛出错误： java.lang.OutOfMemoryError: Java heap space (3)永久代空间不足 JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中也称为永久代（Permanet Generation），存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出错误信息：java.lang.OutOfMemoryError: PermGen space (4)CMS GC 时出现 promotion failed 和 concurrent mode failure promotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。 (5)统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-HotSpot垃圾收集器]]></title>
    <url>%2Fposts%2F2019-03-04-JVM-HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 HotSpot 虚拟机提供了多种垃圾收集器，每种收集器都有各自的特点，虽然我们要对各个收集器进行比较，但并非为了挑选出一个最好的收集器。我们选择的只是对具体应用最合适的收集器。 1 新生代垃圾收集器(1)Serial 垃圾收集器（单线程） 只开启一条 GC 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程(Stop The World)。一般客户端应用所需内存较小，不会创建太多对象，而且堆内存不大，因此垃圾收集器回收时间短，即使在这段时间停止一切用户线程，也不会感觉明显卡顿。因此 Serial 垃圾收集器适合客户端使用。由于 Serial 收集器只使用一条 GC 线程，避免了线程切换的开销，从而简单高效。 ![JVM_06.png](https://i.loli.net/2019/11/13/rafdR2XSxhID57J.png) (2)ParNew 垃圾收集器（多线程） ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。但清理过程依然需要 Stop The World。ParNew 追求“低停顿时间”,与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但线程切换需要额外的开销，因此在单 CPU 环境中表现不如 Serial。 ![JVM_07.png](https://i.loli.net/2019/11/13/hHVwAuFjKTNbxda.png) (3)Parallel Scavenge 垃圾收集器（多线程） Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点： Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。 ParNew：追求降低用户停顿时间，适合交互式应用。 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) 追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC 需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行 GC 以便更快速完成，反过来又导致吞吐量下降。 通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比。 通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间。 通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略。我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio。 2 老年代垃圾收集器(1)Serial Old 垃圾收集器（单线程） Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用“标记-整理”算法；Serial 工作在新生代，使用“复制”算法。 (2)Parallel Old 垃圾收集器（多线程） Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。 (3)CMS 垃圾收集器 CMS(Concurrent Mark Sweep，并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。 并发标记：使用多条标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。 重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。 并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。 并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，总体上说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。 ![jvm_08.png](https://i.loli.net/2019/11/13/l6Fkw8rJOBVCUfK.png) CMS 的缺点：a.吞吐量低b.无法处理浮动垃圾，导致频繁 Full GCc,使用“标记-清除”算法产生碎片空间 对于产生碎片空间的问题，可以通过开启 -XX:+UseCMSCompactAtFullCollection，在每次 Full GC 完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数 -XX:CMSFullGCsBeforeCompaction告诉 CMS，经过了 N 次 Full GC 之后再进行一次内存整理。 3 G1 通用垃圾收集器G1 是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。 从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 这里抛个问题👇：一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？ 并不！每个 Region 都有一个 Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历。 如果不计算维护 Remembered Set 的操作，G1 收集器的工作过程分为以下几个步骤： 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。 并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。 最终标记：Stop The World，使用多条标记线程并发执行。 筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-垃圾收集策略与算法]]></title>
    <url>%2Fposts%2F2019-03-03-JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。 这五个区域既然是存储空间，那么为了避免Java虚拟机在运行期间内存存满的情况，就必须得有一个垃圾收集者的角色，不定期地回收一些无效内存，以保障Java虚拟机能够健康地持续运行。 这个垃圾收集者就是平常我们所说的“垃圾收集器”，那么垃圾收集器在何时清扫内存？清扫哪些数据？这就是接下来我们要解决的问题。 程序计数器、Java虚拟机栈、本地方法栈都是线程私有的，也就是每条线程都拥有这三块区域，而且会随着线程的创建而创建，随着线程的结束而销毁。那么，垃圾收集器在何时清扫这三块区域的问题就解决了。 此外，Java虚拟机栈、本地方法栈中的栈帧会随着方法的开始而入栈，方法的结束而出栈，并且每个栈帧中的本地变量表都是在类被加载的时候就确定的。因此以上三个区域的垃圾收集工作具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。垃圾收集器能够清楚地知道何时清扫这三块区域中的哪些数据。 然而，堆和方法区中的内存清理工作就没那么容易了。只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。 堆和方法区所有线程共享，并且都在JVM启动时创建，一直得运行到JVM停止时。因此它们没办法根据线程的创建而创建、线程的结束而释放。 堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象只有在程序运行期间才能确定。 方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。 因此，堆和方法区的内存回收具有不确定性，因此垃圾收集器在回收堆和方法区内存的时候花了一些心思。 1 堆内存的回收1.1 如何判定哪些对象需要回收？在对堆进行对象回收之前，首先要判断哪些是无效对象。我们知道，一个对象不被任何对象或变量引用，那么就是无效对象，需要被回收。一般有两种判别方式： (1)引用计数法 每个对象都有一个计数器，当这个对象被一个变量或另一个对象引用一次，该计数器加一；若该引用失效则计数器减一。当计数器为0时，就认为该对象是无效对象。 在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。 引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。 例如：对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。 (2)可达性分析法 所有和GC Roots直接或间接关联的对象都是有效对象，和GC Roots没有关联的对象就是无效对象。 GC Roots是指： Java虚拟机栈所引用的对象(栈帧中局部变量表中引用类型的变量所引用的对象) 方法区中静态属性引用的对象 方法区中常量所引用的对象 本地方法栈所引用的对象 GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。 两者对比： 引用计数法虽然简单，但存在一个严重的问题，它无法解决循环引用的问题。 因此，目前主流语言均使用可达性分析方法来判断对象是否有效。 1.2 回收无效对象的过程对于可达性分析中不可达的对象，也并不是没有存活的可能。 当JVM筛选出失效的对象之后，并不是立即清除，而是再给对象一次重生的机会，具体过程如下： （1）判断该对象是否覆盖了finalize()方法 JVM 会判断此对象是否有必要执行 finalize() 方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。 如果对象被判定为有必要执行 finalize() 方法，那么对象会被放入一个 F-Queue 队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。 若已覆盖该方法，并该对象的finalize()方法还没有被执行过，那么就会将finalize()扔到F-Queue队列中； 若未覆盖该方法，则直接释放对象内存。 （2）执行F-Queue队列中的finalize()方法 虚拟机会以较低的优先级执行这些finalize()方法们，也不会确保所有的finalize()方法都会执行结束。如果finalize()方法中出现耗时操作，虚拟机就直接停止执行，将该对象清除。 （3）对象重生或死亡 如果在执行finalize()方法时，将this赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。 注意： 强烈不建议使用finalize()函数进行任何操作！如果需要释放资源，请使用try-finally。因为finalize()不确定性大，开销大，无法保证顺利执行。 任何一个对象的 finalize() 方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，想继续在 finalize() 中自救就失效了。 2 Java中引用的种类判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾手收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。 在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态reachable和垃圾收集的影响。 Java中根据生命周期的长短，将引用分为4类。 2.1 强引用（Strong Reference）类似 “Object obj = new Object()” 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们错误地保持了强引用，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。 我们平时所使用的引用就是强引用。 A a = new A(); 也就是通过关键字new创建的对象所关联的引用就是强引用。 只要强引用存在，该对象永远也不会被回收。 2.2 软引用（Soft Reference）软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 只有当堆即将发生OOM异常时，JVM才会回收软引用所指向的对象。 软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。 2.3 弱引用（Weak Reference）弱引用的强度比软引用更弱一些。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。 只要垃圾收集器运行，软引用所指向的对象就会被回收。 弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。 2.4 虚引用（Phantom Reference）虚引用也叫幽灵引用或者幻影引用，它和没有引用没有区别，无法通过虚引用访问对象的任何属性或函数。 一个对象关联虚引用唯一的作用就是在该对象被垃圾收集器回收之前会受到一条系统通知。 虚引用通过PhantomReference类来实现。 它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。 3 方法区的内存回收如果使用复制算法实现堆的内存回收，堆就会被分为新生代和老年代，新生代中的对象“朝生夕死”，每次垃圾回收都会清除掉大量的对象；而老年代中的对象生命较长，每次垃圾回收只有少量的对象被清除掉。 由于方法区中存放生命周期较长的类信息、常量、静态变量，因此方法区就像是堆的老年代，每次垃圾收集的只有少量的垃圾被清除掉。 方法区中主要清除两种垃圾： 废弃常量 废弃的类 3.1 如何判定废弃常量？清除废弃的常量和清除对象类似，只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 “blog” 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 “blog” 常量，也没有其它地方引用这个字面量，必要的话，”blog”常量会被清理出常量池。 3.2 如何废弃废弃的类？清除废弃类的条件较为苛刻： (1)该类的所有对象都已被清除 (2)该类的java.lang.Class对象没有被任何对象或变量引用,无法在任何地方通过反射访问该类的方法 只要一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区的时候创建，在方法区中该类被删除时清除。 (3)加载该类的ClassLoader已经被回收 4 垃圾收集算法知道了判定一个对象是无效对象、判定一个类是废弃类、判定一个常量是废弃常量的方法，也就是知道了垃圾收集器会清除哪些数据，那么接下来介绍如何清除这些数据。 4.1 标记-清除算法首先利用刚才介绍的方法判断需要清除哪些数据，并给它们做上标记；然后清除被标记的数据。 标记的过程：遍历所有的 GC Roots，然后将所有 GC Roots 可达的对象标记为存活的对象。 清除的过程：将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。 分析不足： 这种算法标记和清除过程效率都很低，而且清除完后存在大量碎片空间，导致无法存储大对象，降低了空间利用率。 （1）效率问题：标记和清除两个过程的效率都不高。 （2）空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 4.2 复制算法（新生代）为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。 将内存分成两份，只将数据存储在其中一块上。当需要回收垃圾时，也是首先标记出废弃的数据，然后将有用的数据复制到另一块内存上，最后将第一块内存全部清除。 分析： 这种算法避免了碎片空间，但内存被缩小了一半。而且每次都需要将有用的数据全部复制到另一片内存上去，效率不高。 优点：不会有内存碎片的问题。 缺点：内存缩小为原来的一半，浪费空间。 解决空间利用率问题： 在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，因此我们可以将内存划分成三块：Eden、From Survivor（Survior1）、To Survivor（Survior2），内存大小分别是8:1:1。分配内存时，只使用Eden和一块Survior1。当发现Eden+Survior1的内存即将满时，JVM会发起一次MinorGC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。 回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。 通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。 但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，那么此时就需要将对象转移到老年代中，这种方式叫做“分配担保”。无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。 什么是分配担保？ 当JVM准备为一个对象分配内存空间时，发现此时Eden+Survior中空闲的区域无法装下该对象，那么就会触发MinorGC，对该区域的废弃对象进行回收。但如果MinorGC过后只有少量对象被回收（依然有超过 10% 的对象存活），仍然无法装下新对象，那么此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程就是“分配担保”。 4.3 标记-整理算法（老年代）在回收垃圾前，首先将所有废弃的对象做上标记，然后将所有未被标记的对象移到一边，最后清空另一边区域即可。 标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历 GC Roots，然后将存活的对象标记。 整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。 分析： 它是一种老年代的垃圾收集算法。老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，因此如果选用“复制”算法，每次需要复制大量存活的对象，会导致效率很低。而且，在新生代中使用“复制”算法，当Eden+Survior中都装不下某个对象时，可以使用老年代的内存进行“分配担保”，而如果在老年代使用该算法，那么在老年代中如果出现Eden+Survior装不下某个对象时，没有其他区域给他作分配担保。因此，老年代中一般使用“标记-整理”算法。 4.4 分代收集算法将内存划分为老年代和新生代。老年代中存放寿命较长的对象，新生代中存放“朝生夕死”的对象。然后在不同的区域使用不同的垃圾收集算法。 根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。 新生代：复制算法老年代：标记-清除算法、标记-整理算法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-HotSpot虚拟机对象探秘]]></title>
    <url>%2Fposts%2F2019-03-02-JVM-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 1 对象的内存模型一个对象从逻辑角度看，它由成员变量和成员函数构成，从物理角度来看，对象是存储在堆中的一串二进制数，这串二进制数的组织结构如下: ![JVM_03.png](https://i.loli.net/2019/11/13/wDfBAyYvSRLKuqd.png) 在 HotSpot 虚拟机中，对象的内存布局分为以下 3 块区域： （1）对象头（Header） （2）实例数据（Instance Data） （3）对齐填充（Padding） 1.1 对象头对象头中记录了对象在运行过程中所需要使用的一些数据： (1)哈希码 (2)GC分代年龄 (3)锁状态标志 (4)线程持有的锁 (5)偏向线程ID (6)偏向时间戳 此外，对象头中可能还包含类型指针。通过该指针能确定这个对象所属哪个类。 此外，如果对象是一个数组，那么对象头中还要包含数组长度。 1.2 实例数据实例数据部分就是成员变量的值，其中包含父类的成员变量和本类的成员变量。 1.3 对齐填充用于确保对象的总长度为8字节的整数倍。 HotSpot要求对象的总长度必须是8字节的整数倍。由于对象头一定是8字节的整数倍，但实例数据部分的长度是任意的，因此需要对齐补充字段确保整个对象的总长度为8的整数倍。 对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。 2 对象的创建过程当虚拟机遇到一条含有new的指令时，会进行一系列对象创建的操作： （1）检查常量池中是否有即将要创建的这个对象所属的类的符号引用； 若常量池中没有这个类的符号引用，说明这个类还没有被定义！抛出ClassNotFoundException； 若常量池中有这个类的符号引用，则进行下一步工作； （2）进而检查这个符号引用所代表的类是否已经被JVM加载、解析和初始化过； 若该类还没有被加载，就找该类的class文件，并加载进方法区； 若该类已经被JVM加载，则准备为对象分配内存； （3）根据方法区中该类的信息确定该类所需的内存大小； 一个对象所需的内存大小是在这个对象所属类被定义完就能确定的！且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。 （4）从堆中划分一块对应大小的内存空间给新的对象；分配堆中内存有两种方式： a)指针碰撞 如果 Java 堆中内存绝对规整（说明采用的是“复制算法”或“标记整理法”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“指针碰撞”。 如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。 b)空闲列表 如果 Java 堆中内存并不规整，已使用的内存和空闲内存交错（说明采用的是标记-清除法，有碎片），此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“空闲列表”。 如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。 综上所述：JVM究竟采用哪种内存分配方法，取决于它使用了何种垃圾收集器。 （5）为对象中的成员变量赋上初始值(默认初始化)； （6）设置对象头中的信息； （7）调用对象的构造函数进行初始化：分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。 此时，整个对象的创建过程就完成了。 3 对象的访问方式所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 引用类型的变量中存放的是一个地址，那么根据地址类型的不同，对象有不同的访问方式： (1)句柄访问方式 堆中需要有一块叫做“句柄池”的内存空间，用于存放所有对象的地址和所有对象所属类的类信息，句柄中包含了对象实例数据与类型数据各自的具体地址信息。 引用类型的变量存放的是该对象在句柄池中的地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。 ![JVM_04.png](https://i.loli.net/2019/11/13/7E8Dyb196cL2deq.png) (2)直接指针访问方式 引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。 但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址。 ![JVM_05.png](https://i.loli.net/2019/11/13/cr3JeXhTQ6mvPy7.png) 比较: HotSpot采用直接指针方式访问对象，因为它只需一次寻址操作，从而在性能上比句柄访问方式快一倍。但它需要额外的策略来存储对象在方法区中类信息的地址。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-JVM内存结构]]></title>
    <url>%2Fposts%2F2019-03-01-JVM-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 Java 虚拟机（Java Virtual Machine=JVM）的内存空间分为5个部分，分别是： 1.程序计数器 2.Java 虚拟机栈 3.本地方法栈 4.堆 5.方法区 ![JVM_01.png](https://i.loli.net/2019/11/13/UWxqubeJp6Rs3Pj.png) JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。 1 程序计数器（PC 寄存器）1.1 程序计数器的定义程序计数器是一块较小的内存空间，是当前线程正在执行的字节码的行号指示器，即当前线程正在执行的那一条字节码指令的地址。 注： 若当前线程正在执行的是一个本地方法，那么此时程序计数器为空（Undefined）。 1.2 程序计数器的作用程序计数器有两个作用： （1）字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 （2）在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候，就能够知道该线程上次运行到哪儿了。 1.3 程序计数器的特点（1）一块较小的内存空间 （2）线程私有，每条线程都有自己的一个程序计数器。 （3）唯一一个不会出现OutOfMemoryError的内存区域。 （4）生命周期随着线程的创建而创建，随着线程的结束而销毁。 2 Java虚拟机栈（JVM Stack）（Java 栈）2.1 Java虚拟机栈的定义Java虚拟机栈是描述Java方法运行过程的内存模型。 Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括： （1）局部变量表 （2）存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。 （3）操作数栈 （4）动态链接 （5）方法出口信息 ![JVM_02.png](https://i.loli.net/2019/11/13/qLQ9Egmw31akKfT.png) 2.2 压栈出栈过程当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。 Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。 由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。 当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。 注意： 人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。 这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。真正的Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息等。 2.3 Java 虚拟机栈的特点（1）局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。而且，局部变量表的大小在编译时期就确定下来了，在创建的时候只需分配事先规定好的大小即可。此外，在方法运行的过程中局部变量表的大小是不会发生改变的。 （2）Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。 a) StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 b) OutOfMemoryError： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。 （3）Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的结束而销毁。 注：StackOverFlowError和OutOfMemoryError的异同？ StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 3 本地方法栈（C 栈）3.1 本地方法栈的定义本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。 本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。 3.2 栈帧变化过程本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、方法出口信息等。 方法执行结束后，相应的栈帧也会出栈，并释放内存空间。 也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。 4 堆4.1 堆的定义堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。 4.2 堆的特点（1）线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个的。 （2）在虚拟机启动时创建。 （3）垃圾回收的主要场所。 （4）可以进一步细分为：新生代(Eden区 、From Survior 、To Survivor)、老年代。 新生代又可被分为：Eden、From Survior、To Survior。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，更高效。 （5）堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出 OutOfMemoryError。 注意: Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。 5 方法区5.1 方法区的定义Java 虚拟机规范中定义方法区是堆的一个逻辑部分。 方法区中存放以下信息： （1）已经被虚拟机加载的类信息、 （2）常量 （3）静态变量 （4）即时编译器编译后的代码 5.2 方法区的特点（1）线程共享：方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。 （2）永久代：方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代（“永久代”）。 （3）内存回收效率低：方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。 （4）Java虚拟机规范对方法区的要求比较宽松：和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 5.3 运行时常量池方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。 一般在一个类中通过public static final来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。 当这个类被Java虚拟机加载后，.class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：String类的intern()方法就能在运行期间向常量池中添加字符串常量。 当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。 6 直接内存（堆外内存）直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。 6.1 操作直接内存在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的 DirectByteBuffer 对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。 直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出OOM（OutOfMemoryError ）异常。 6.2 直接内存与堆内存比较（1）直接内存申请空间耗费更高的性能 （2）直接内存读取 IO 的性能要优于普通的堆内存。 （3）直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO （4）堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO 注意：服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。 7 总结Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。 两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。 只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。 Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。 堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。 程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法栈。并且他们的生命周期和所属的线程一样。 而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WPS政府版最全整理集合]]></title>
    <url>%2Fposts%2F2019-01-20-wpsgov%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;WPS2019的政府版本已经更新了4个地区，可以下载。 使用方法： （1）把那行xxxx单位的字去了的方法： \Program Files (x86)\Kingsoft\WPS Office\11.8.2.8053\oem 替换图片就行了 （2）简单去广告方法： 首先打开控制面板，假装要卸载wps.然后卸载，wps会问你卸载原因。这时候你就选择广告太多，这时候会弹出彻底关闭广告的弹窗。 （3）赠送个人版的序列号： 序列号1：9DP6T-9AGWG-KWV33-9MPC8-JDCVF 序列号2：THUV2-32HH7-6NMHN-PTX7Y-QQCTH 序列号3：R7AKQ-KLBXV-RNX3F-BPACQ-NQDGE 1.广东省：广东省政府机关单位： http://wpspro.support.wps.cn/gov/guangdong/ WPS Office 2016 专用版（10.8.0.6423） 潮州市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/chaozhou/ WPS Office 2019 专业增强版（11.8.2.8053） 惠州市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/huizhou/ WPS Office 2019 专业版（11.8.2.7978） 中山市政府党政机关： http://wpspro.support.wps.cn/gov/guangdong/zhongshan/ WPS Office 2016 专业版（10.8.0.6470） 珠海市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/zhuhai/ WPS Office 2016 专业增强版（10.8.2.6726） 佛山市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/foshan/ （需要密码才能进入） 茂名市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/maoming/ WPS Office 2019 专业增强版（11.8.2.8053） 河源市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/heyuan/ WPS Office 2016 专业版（10.8.2.6837） 揭阳市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/jieyang/ WPS Office 2016 专业版（10.8.0.6423） 肇庆市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/zhaoqing/ WPS Office 2016 专业增强版（10.8.2.6613） 2.重庆市：重庆市政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/ WPS Office 2016 专用版（10.8.2.6762） 铜梁区党政机关单位： http://wpspro.support.wps.cn/gov/chongqing/tongliang/ WPS Office 2019 铜梁区党政机关专业版（11.8.2.8053） 巴南区党政机关单位： http://wpspro.support.wps.cn/gov/chongqing/banan/ WPS Office 2016 专业增强版（10.8.2.6837） 沙坪坝区政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/shapingba/ WPS Office 2016 专用版（10.8.2.6837） 荣昌区政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/rongchang/ WPS Office 2016 专业版（10.8.0.6206） 云阳县政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/yunyang/ WPS Office 2016 专业版（10.8.2.6726） 奉节县政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/fengjie/ WPS Office 2016 专业增强版（10.8.0.6206） 巫溪县党政机关单位： http://wpspro.support.wps.cn/gov/chongqing/wuxi/ WPS Office 2016 专业版（10.8.0.6206） 秀山县党政机关单位： http://wpspro.support.wps.cn/gov/chongqing/xiushan/ WPS Office 2016 专用版（10.8.2.6666） 3.海南省：海南省党政机关单位： http://wpspro.support.wps.cn/gov/hainan/ WPS Office 2016 专业版（10.8.2.6784） 三亚市党政机关单位： http://wpspro.support.wps.cn/gov/hainan/sanya/ WPS Office 2016 专业版（10.8.2.6784） 4.云南省：云南省党政机关单位： http://wpsupdate.ynxgj.gov.cn:21009/wps_download/index.html WPS Office 2016 专业增强版（10.8.2.6837） 5.山东省：山东省部分省级预算单位： http://wpspro.support.wps.cn/gov/shandong/ WPS Office 2016 专业版（版本号：10.8.2.6726） 德州市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/dezhou/ WPS Office 2016 专业版（版本号：10.8.2.6837） 日照市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/rizhao/ WPS Office 2016 专业版（版本号：10.8.2.6948） 莱芜市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/laiwu/ WPS Office 2016 专业版（版本号：10.8.2.6870） 烟台市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/yantai/ WPS Office 2016 专业版（版本号：10.8.2.6726） 枣庄市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/zaozhuang/ WPS Office 2016 专业版（版本号：10.8.2.6949） 威海市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/weihai/ WPS Office2019 （版本号：11.8.2.7978） 6.山西省：晋城市政府机关单位： http://wpspro.support.wps.cn/gov/shanxi/jincheng/ WPS Office 2016 专业版（10.8.0.6870） 运城市党政机关单位： http://wpspro.support.wps.cn/gov/shanxi/yuncheng/ WPS Office 2016 运城市党政机关专用版（10.8.0.6058） 国家税务总局山西省税务局： http://wpspro.support.wps.cn/gov/shanxi/shuiwu/ WPS Office 2016 专业版（10.8.0.6423） 7.广西省：广西省党政机关单位： http://wpspro.support.wps.cn/gov/guangxi/ WPS Office 2016 专用版（10.8.2.6666） 8.吉林省：吉林市党政机关单位： http://wpspro.support.wps.cn/gov/jilin/ WPS Office 2016 专用版（10.8.0.6501） 9.湖南省：长沙市党政机关单位： http://wpspro.support.wps.cn/gov/hunan/changsha/ WPS Office 2016 专业版（10.8.0.6058） 10.四川省：四川省政府机关单位： http://wpspro.support.wps.cn/gov/sichuan/ WPS Office 2016 专业版（10.8.2.6784） 成都市党政机关单位： http://wpspro.support.wps.cn/gov/sichuan/chengdu/ WPS Office 2016 专业版（10.8.0.6058） 雅安市党政机关单位： http://wpspro.support.wps.cn/gov/sichuan/yaan/ WPS Office 2016 专业版（10.8.0.6058） 广元市教育行业： http://wpspro.support.wps.cn/gov/sichuan/guangyuan/ WPS Office 2016 广元市教育专用版（10.8.0.6253） 11.辽宁省：辽宁省直机关政府单位： http://wpspro.support.wps.cn/gov/liaoning/ WPS_Office_2016_辽宁省直机关政府专用版 沈阳市党政机关单位： http://wpspro.support.wps.cn/gov/liaoning/shenyang/ WPS Office 2013 专业增强版（9.1.0.5026） 12.黑龙江省：黑龙江省直党政机关： http://wpspro.support.wps.cn/gov/heilongjiang/ WPS Office 2016 专业版（版本号：10.8.2.6870） 大庆市党政机关单位： http://wpspro.support.wps.cn/gov/heilongjiang/daqing/ WPS Office 2016 专业版（版本号：10.8.2.6666） 绥化市党政机关单位： http://wpspro.support.wps.cn/gov/heilongjiang/suihua/ WPS Office 2016 专业版（版本号：10.8.2.6784） 13.福建省：福建省党政机关单位： http://wpspro.support.wps.cn/gov/fujian/ WPS Office 2016 福建省直试用版（10.8.0.6501） 泉州市党政机关单位： http://wpspro.support.wps.cn/gov/fujian/quanzhou/ WPS Office 2016 专业增强版（10.8.0.6058） 福州市党政机关单位： http://wpspro.support.wps.cn/gov/fujian/fuzhou/ WPS Office 2016 专业增强版（10.8.0.6058） 厦门市党政机关单位： http://wpspro.support.wps.cn/gov/fujian/xiamen/ WPS Office 2016 专业版和专业增强版（10.8.0.6501） 14.江西省：江西省党政机关单位： http://wpspro.support.wps.cn/gov/jiangxi/ WPS Office 2016 江西省电子政务专版（10.8.0.6294） 15.西藏自治区：西藏自治区党政机关单位： http://wpspro.support.wps.cn/gov/xizang/ WPS Office 2016 专业版（10.8.2.6666） 16.北京市：西城区政府机关单位： http://wpspro.support.wps.cn/gov/beijing/xicheng/ WPS Office 2016 专业版（10.8.0.6253） 平谷区政府机关单位： http://wpspro.support.wps.cn/gov/beijing/pinggu/ WPS Office 2016 专业版（10.8.2.6726） 石景山区党政机关单位： http://wpspro.support.wps.cn/gov/beijing/shijingshan/ WPS Office 2016 专业版（10.8.0.6058） 17.安徽省：六安市政府机关单位： http://wpspro.support.wps.cn/gov/anhui/liuan/ WPS Office 2016 专业增强版（10.8.0.6253） 18.湖北省：武汉市党政机关单位： http://wpspro.support.wps.cn/gov/hubei/wuhan/ WPS Office 2016 专业增强版（10.8.2.6837） 19.各其他企业单位：中国能源建设股份有限公司： http://wpspro.support.wps.cn/enterprise/ceec/ WPS Office 2016 专业增强版（10.8.2.6784） 中国铁建： http://wpspro.support.wps.cn/enterprise/crcc/ WPS Office（10.8.0.6470） 石家庄市人力资源和社会保障局： http://www.sjzrs.gov.cn/col/1515395624617/2018/02/11/1518329562990.html WPS Office 2016 专业版（10.8.0.5562）]]></content>
      <categories>
        <category>IT</category>
        <category>WPS</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>WPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用深度学习识别12306图片验证码]]></title>
    <url>%2Fposts%2F2019-01-12-12306_captcha%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在写12306抢票软件，发现图片验证码绕不过，开始用手动输入图片验证码的方式去登录12306账户，幸好，只有登录的时候需要验证图片，下单的时候不需要图片验证码识别，成功购票！ &emsp;&emsp;但是，怎么能这么轻易的放过图片验证码呢？这里，学以致用，如何使用深度学习去识别12306图片验证码呢？ &emsp;&emsp;12306的图片验证码是从8个图片中找到要求的物体，如下图所示： ![12306_captcha_01.jpg](https://i.loli.net/2019/04/26/5cc2716a52c66.jpg) &emsp;&emsp;统计了1000个左右的样本图片，发现12306的图片类别只有80个，如下列表： 药片 中国结 仪表盘 公交卡 冰箱 创可贴 刺绣 剪纸 印章 卷尺 双面胶 口哨 啤酒 安全帽 开瓶器 手掌印 打字机 护腕 拖把 挂钟 排风机 文具盒 日历 本子 档案袋 棉棒 樱桃 毛线 沙包 沙拉 海报 海苔 海鸥 漏斗 烛台 热水袋 牌坊 狮子 珊瑚 电子秤 电线 电饭煲 盘子 篮球 红枣 红豆 红酒 绿豆 网球拍 老虎 耳塞 航母 苍蝇拍 茶几 茶盅 菠萝 蒸笼 薯条 蚂蚁 蜜蜂 蜡烛 蜥蜴 订书机 话梅 调色板 跑步机 路灯 辣椒酱 金字塔 钟表 铃铛 锅铲 锣 锦旗 雨靴 鞭炮 风铃 高压锅 黑板 龙舟 &emsp;&emsp;通过一轮又一轮的训练12306的图片，生成了识别的模型。关于具体的模型训练，此处省略一亿字。 &emsp;&emsp;由于是小白，这里图片的识别不是很高，没有达到100%，测试总体的准确率在75% - 85% 之间，还有完善的空间。 &emsp;&emsp;这里，在本地搭建了个临时访问的web网站，可以体验体验图片的识别。 &emsp;&emsp;请用电脑浏览器打开 http://idl.free.idcfengye.com/ 演示：&emsp;&emsp;打开上面的演示地址： ![12306_captcha_02.jpg](https://i.loli.net/2019/04/26/5cc2716a8ecee.jpg) &emsp;&emsp;演示的图片验证码文件： ![12306_captcha_03.jpg](https://i.loli.net/2019/04/26/5cc2716a547b0.jpg) &emsp;&emsp;上传文件之后，跳到显示识别出来的结果的页面： ![12306_captcha_04.jpg](https://i.loli.net/2019/04/26/5cc2716a91118.jpg) &emsp;&emsp;OK，最后有个问题，最近一直在思考：Deep Learning 真的是泡沫吗？]]></content>
      <categories>
        <category>图片识别</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>12306</tag>
        <tag>深度学习</tag>
        <tag>验证码</tag>
        <tag>图片识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派安装Tensorflow]]></title>
    <url>%2Fposts%2F2018-12-03-raspberrypi_tensorflow%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;树莓派如何安装Tensorflow呢？ &emsp;&emsp;官方提供的方式感觉太复杂，这里按照如下步骤，也能完成Tensorflow在树莓派上的安装。 # 安装驱动 sudo apt install libatlas-base-dev # 安装TensorFlow pip3 install tensorflow &emsp;&emsp;安装TensorFlow的时候会自动下载安装依赖的工具，如：numpy，tensorboard，markdown 等等。 &emsp;&emsp;如果下载很慢，可以去 piwheels网站 上下载。 &emsp;&emsp;如果现实cv2导入错误，可以去之前的博客文章《python3安装opencv爬坑步骤》找到解决方法 &emsp;&emsp;实现Hello World: import tensorflow as tf hello = tf.constant(&#39;Hello, TensorFlow!&#39;) sess = tf.Session() print(sess.run(hello)) &emsp;&emsp; &emsp;&emsp;OK，大功告成！]]></content>
      <categories>
        <category>Tensorflow</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>raspberry pi</tag>
        <tag>pi</tag>
        <tag>raspbian</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派配置WIFI信息]]></title>
    <url>%2Fposts%2F2018-12-01-raspberrypi_wifi%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;树莓派如何配置WIFI信息？ &emsp;&emsp;通过配置wpa_supplicant.conf可以设置要连接的无线网。 sudo nano /etc/wpa_supplicant/wpa_supplicant.conf &emsp;&emsp;在文件末尾出添加一下代码，并替换掉ssid_name以及password即可。 network=&#123; ssid=&quot;ssid_name&quot; key_mgmt=WPA-PSK psk=&quot;password&quot; &#125; &emsp;&emsp;添加多个无线网络配置,只要添加多个network即可。 network=&#123; ssid=&quot;SSID1&quot; psk=&quot;passwordl&quot; id_str=&quot;ssidl&quot; &#125; network=&#123; ssid=&quot;SSID2&quot; psk=&quot;password2&quot; id_str=&quot;ssid2&quot; &#125; &emsp;&emsp;如果有多个网络，可以添加优先级选项来选择具体连接哪一个网络。具有最高优先级的范围内的网络将是优先连接的网络。 network=&#123; ssid=&quot;SSID1&quot; psk=&quot;password1&quot; priority=1 id_str=&quot;ssid1&quot; &#125; network=&#123; ssid=&quot;SSID2&quot; psk=&quot;password2&quot; priority=2 id_str=&quot;ssid2&quot; &#125; &emsp;&emsp;添加没有密码的WIFI网络，只要将key_mgmt设置为NONE network=&#123; ssid=&quot;ssid_name&quot; key_mgmt=NONE &#125;]]></content>
      <categories>
        <category>IT</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>raspberry pi</tag>
        <tag>pi</tag>
        <tag>raspbian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2Fposts%2F2019-01-04-HashMap%2F</url>
    <content type="text"><![CDATA[HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序； 简介HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序； 继承体系![HashMap.png](https://i.loli.net/2019/11/26/LAWRwQFy5zKNVqm.png) HashMap实现了Cloneable，可以被克隆。 HashMap实现了Serializable，可以被序列化。 HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。 存储结构![HashMap1.png](https://i.loli.net/2019/11/26/I9BtwgVexrCvz1E.png) 在Java中，HashMap的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。 在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。 当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。 数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。 源码解析属性/** * The default initial capacity - MUST be a power of two. * 默认的初始容量为16 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. * 最大的容量为2的30次方 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. * 默认的装载因子 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. * 当一个桶中的元素个数大于等于8时进行树化 */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. * 当一个桶中的元素个数小于等于6时把树转化为链表 */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * 当桶的个数达到64的时候才进行树化 */ static final int MIN_TREEIFY_CAPACITY = 64; /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) * 数组，又叫作桶（bucket） */ transient Node&lt;K,V&gt;[] table; /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). * 作为entrySet()的缓存 */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * The number of key-value mappings contained in this map. * 元素的数量 */ transient int size; /** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). * 修改次数，用于在迭代的时候执行快速失败策略 */ transient int modCount; /** * The next size value at which to resize (capacity * load factor). * 当桶的使用数量达到多少时进行扩容，threshold = capacity * loadFactor * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; /** * The load factor for the hash table. * 装载因子 * @serial */ final float loadFactor; （1）容量 容量为数组的长度，亦即桶的个数，默认为16，最大为2的30次方，当容量达到64时才可以树化。 （2）装载因子 装载因子用来计算容量达到多少时才进行扩容，默认装载因子为0.75。 （3）树化 树化，当容量达到64且链表的长度达到8时进行树化，当链表的长度小于6时反树化。 Node内部类Node是一个典型的单链表节点，其中，hash用来存储key计算得来的hash值。 /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; TreeNode内部类这个类继承自LinkedHashMap中的Entry类。 TreeNode是一个典型的树型节点，其中，prev是链表中的节点，用于在删除元素的时候可以快速找到它的前置节点。 // 位于HashMap中 /** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */ static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; &#125; // 位于LinkedHashMap中，典型的双向链表节点 static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; HashMap()构造方法空参构造方法，全部使用默认值。 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; HashMap(int initialCapacity)构造方法调用HashMap(int initialCapacity, float loadFactor)构造方法，传入默认装载因子。 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; HashMap(int initialCapacity, float loadFactor)构造方法判断传入的初始容量和装载因子是否合法，并计算扩容门槛，扩容门槛为传入的初始容量往上取最近的2的n次方。 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; // 检查传入的初始容量是否合法 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检查装载因子是否合法 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; // 计算扩容门槛 this.threshold = tableSizeFor(initialCapacity); &#125; /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; // 扩容门槛为传入的初始容量往上取最近的2的n次方 int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; put(K key, V value)方法添加元素的入口。 /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; // 调用hash(key)计算出key的hash值 return putVal(hash(key), key, value, false, true); &#125; /** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don&#39;t benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */ static final int hash(Object key) &#123; int h; // 如果key为null，则hash值为0，否则调用key的hashCode()方法 // 并让高16位与整个hash异或，这样做是为了使计算出的hash更分散 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 如果桶的数量为0，则初始化 if ((tab = table) == null || (n = tab.length) == 0) // 调用resize()初始化 n = (tab = resize()).length; // (n - 1) &amp; hash 计算元素在哪个桶中 // 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 新建一个节点放在桶中 tab[i] = newNode(hash, key, value, null); else &#123; // 如果桶中已经有元素存在了 Node&lt;K,V&gt; e; K k; // 如果桶中第一个元素的key与待插入元素的key相同，保存到e中用于后续修改value值 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 如果第一个元素是树节点，则调用树节点的putTreeVal插入元素 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 遍历这个桶对应的链表，binCount用于存储链表中元素的个数 for (int binCount = 0; ; ++binCount) &#123; // 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表最后插入一个新节点 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 如果插入新节点后链表长度大于8，则判断是否需要树化，因为第一个元素没有加到binCount中，所以这里-1 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果待插入的key在链表中找到了，则退出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 如果找到了对应key的元素 if (e != null) &#123; // existing mapping for key // 记录下旧值 V oldValue = e.value; // 判断是否需要替换旧值 if (!onlyIfAbsent || oldValue == null) // 替换旧值为新值 e.value = value; // 在节点被访问后做点什么事，在LinkedHashMap中用到 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 到这里了说明没有找到元素 // 修改次数加1 ++modCount; // 元素数量加1，判断是否需要扩容 if (++size &gt; threshold) // 扩容 resize(); // 在节点插入后做点什么事，在LinkedHashMap中用到 afterNodeInsertion(evict); // 没找到元素返回null return null; &#125; （1）计算key的hash值； （2）如果桶（数组）数量为0，则初始化桶； （3）如果key所在的桶没有元素，则直接插入； （4）如果key所在的桶中的第一个元素的key与待插入的key相同，说明找到了元素，转后续流程（9）处理； （5）如果第一个元素是树节点，则调用树节点的putTreeVal()寻找元素或插入树节点； （6）如果不是以上三种情况，则遍历桶对应的链表查找key是否存在于链表中； （7）如果找到了对应key的元素，则转后续流程（9）处理； （8）如果没找到对应key的元素，则在链表最后插入一个新节点并判断是否需要树化； （9）如果找到了对应key的元素，则判断是否需要替换旧值，并直接返回旧值； （10）如果插入了元素，则数量加1并判断是否需要扩容； resize()方法扩容方法 /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() &#123; // 旧数组 Node&lt;K,V&gt;[] oldTab = table; // 旧容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 旧扩容门槛 int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 如果旧容量达到了最大容量，则不再进行扩容 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 如果旧容量的两倍小于最大容量并且旧容量大于默认初始容量（16），则容量扩大为两部，扩容门槛也扩大为两倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold // 使用非默认构造方法创建的map，第一次插入元素会走到这里 // 如果旧容量为0且旧扩容门槛大于0，则把新容量赋值为旧门槛 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults // 调用默认构造方法创建的map，第一次插入元素会走到这里 // 如果旧容量旧扩容门槛都是0，说明还未初始化过，则初始化容量为默认容量，扩容门槛为默认容量*默认装载因子 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; // 如果新扩容门槛为0，则计算为容量*装载因子，但不能超过最大容量 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 赋值扩容门槛为新门槛 threshold = newThr; // 新建一个新容量的数组 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 把桶赋值为新数组 table = newTab; // 如果旧数组不为空，则搬移元素 if (oldTab != null) &#123; // 遍历旧数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 如果桶中第一个元素不为空，赋值给e if ((e = oldTab[j]) != null) &#123; // 清空旧桶，便于GC回收 oldTab[j] = null; // 如果这个桶中只有一个元素，则计算它在新桶中的位置并把它搬移到新桶中 // 因为每次都扩容两倍，所以这里的第一个元素搬移到新桶的时候新桶肯定还没有元素 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // 如果这个链表不止一个元素且不是一颗树 // 则分化成两个链表插入到新的桶中去 // 比如，假如原来容量为4，3、7、11、15这四个元素都在三号桶中 // 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去 // 也就是分化成了两个链表 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // (e.hash &amp; oldCap) == 0的元素放在低位链表中 // 比如，3 &amp; 4 == 0 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; // (e.hash &amp; oldCap) != 0的元素放在高位链表中 // 比如，7 &amp; 4 != 0 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 遍历完成分化成两个链表了 // 低位链表在新桶中的位置与旧桶一样（即3和11还在三号桶中） if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了） if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; （1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12； （2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方； （3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍； （4）创建一个新容量的桶； （5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置； TreeNode.putTreeVal(…)方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Map</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派修改镜像源]]></title>
    <url>%2Fposts%2F2018-12-02-raspberrypi_source%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;树莓派如何修改镜像源呢？ &emsp;&emsp;树莓派内置的镜像源，访问很慢，这里修改成国内访问速度快的镜像源。 &emsp;&emsp;一、树莓派基金会提供的源 &emsp;&emsp;/etc/apt/sources.list.d/raspi.list里的软件源是树莓派基金会单独（非Raspbian开发者）提供/维护的软件源，主要包括raspi-config、minecraftpi、树莓派桌面环境、内核固件驱动等少量软件。 &emsp;&emsp;1.Debian 8 Jessie 中科大 deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ jessie main ui 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/debian/ jessie main ui 默认官方源 deb http://archive.raspberrypi.org/debian/ jessie main ui &emsp;&emsp;2.Debian 9 Stretch 中科大 deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/debian/ stretch main ui 默认官方源 deb http://archive.raspberrypi.org/debian/ stretch main ui &emsp;&emsp;二、Raspbian源 &emsp;&emsp;raspbian这个源是由独立开发者维护的，与树莓派基金会并无直接联系。国内源比较多，选择一个与自己延迟最小或连接速度最好或物理距离最短的即可。无需担心各个软件源内容上会有不同，基本上各个站点每天都会同步一次，绝大部分情况下某软件安装不了与用了哪个站点提供的源无关。通常位于/etc/apt/sources.list &emsp;&emsp;1.Debian 8 Jessie 中科大 deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 大连东软 deb http://mirrors.neusoft.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 重庆大学 deb http://mirrors.cqu.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 浙江大学 deb http://mirrors.zju.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 阿里云 deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main contrib non-free rpi 搜狐 deb http://mirrors.sohu.com/raspbian/raspbian/ jessie main contrib non-free rpi 元智大学（中国台湾） deb http://ftp.cse.yzu.edu.tw/Linux/raspbian/raspbian/ jessie main contrib non-free rpi 新加坡国立大学 deb http://mirror.nus.edu.sg/raspbian/raspbian/ jessie main contrib non-free rpi 北陆先端科学技术大学院大学（日本知名镜像站，日常出口带宽2g） deb http://ftp.jaist.ac.jp/raspbian/ jessie main contrib non-free rpi 牛津大学 deb http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/ jessie main contrib non-free rpi 美国Berkely大学 deb http://mirrors.ocf.berkeley.edu/raspbian/raspbian/ jessie main contrib non-free rpi 美国俄克拉荷马大学 deb http://reflection.oss.ou.edu/raspbian/raspbian/ jessie main contrib non-free rpi 南非知名软件源 deb http://mirror.liquidtelecom.com/raspbian/raspbian/ jessie main contrib non-free rpi 默认源（带重定向by mirrorbrain） deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi 官方源 deb https://archive.raspbian.org/raspbian/ jessie main contrib non-free rpi &emsp;&emsp;2.Debian 9 Stretch 中科大 deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 大连东软 deb http://mirrors.neusoft.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 重庆大学 deb http://mirrors.cqu.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 浙江大学 deb http://mirrors.zju.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 阿里云 deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi 搜狐 deb http://mirrors.sohu.com/raspbian/raspbian/ stretch main contrib non-free rpi 元智大学（中国台湾） deb http://ftp.cse.yzu.edu.tw/Linux/raspbian/raspbian/ stretch main contrib non-free rpi 新加坡国立大学 deb http://mirror.nus.edu.sg/raspbian/raspbian/ stretch main contrib non-free rpi 北陆先端科学技术大学院大学（日本知名镜像站，日常出口带宽2g） deb http://ftp.jaist.ac.jp/raspbian/ stretch main contrib non-free rpi 牛津大学 deb http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/ stretch main contrib non-free rpi 美国Berkely大学 deb http://mirrors.ocf.berkeley.edu/raspbian/raspbian/ stretch main contrib non-free rpi 美国俄克拉荷马大学 deb http://reflection.oss.ou.edu/raspbian/raspbian/ stretch main contrib non-free rpi 南非知名软件源 deb http://mirror.liquidtelecom.com/raspbian/raspbian/ stretch main contrib non-free rpi 默认源（带重定向by mirrorbrain） deb http://mirrordirector.raspbian.org/raspbian/ stretch main contrib non-free rpi 官方源 deb https://archive.raspbian.org/raspbian/ stretch main contrib non-free rpi &emsp;&emsp;这里提供个raspbian官方镜像列表 : https://www.raspbian.org/RaspbianMirrors]]></content>
      <categories>
        <category>IT</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>raspberry pi</tag>
        <tag>pi</tag>
        <tag>raspbian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CopyOnWriteArrayList 源码分析]]></title>
    <url>%2Fposts%2F2019-01-03-CopyOnWriteArrayList%2F</url>
    <content type="text"><![CDATA[CopyOnWriteArrayList是ArrayList的线程安全版本，内部也是通过数组实现，每次对数组的修改都完全拷贝一份新的数组来修改，修改完了再替换掉老数组，这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。 简介CopyOnWriteArrayList是ArrayList的线程安全版本，内部也是通过数组实现，每次对数组的修改都完全拷贝一份新的数组来修改，修改完了再替换掉老数组，这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。 继承体系![CopyOnWriteArrayList.png](https://i.loli.net/2019/11/25/B19QlWcv6z3jaMt.png) CopyOnWriteArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。 CopyOnWriteArrayList实现了List，提供了基础的添加、删除、遍历等操作。 CopyOnWriteArrayList实现了RandomAccess，提供了随机访问的能力。 CopyOnWriteArrayList实现了Cloneable，可以被克隆。 CopyOnWriteArrayList实现了Serializable，可以被序列化。 源码分析主要属性/** * The lock protecting all mutators * 用于修改时加锁 */ final transient ReentrantLock lock = new ReentrantLock(); /** * The array, accessed only via getArray/setArray. * 真正存储元素的地方，只能通过getArray()/setArray()访问 */ private transient volatile Object[] array; （1）lock 用于修改时加锁，使用transient修饰表示不自动序列化。 （2）array 真正存储元素的地方，使用transient修饰表示不自动序列化，使用volatile修饰表示一个线程对这个字段的修改另外一个线程立即可见。 问题：为啥没有size字段？ CopyOnWriteArrayList()构造方法创建空数组： /** * Creates an empty list. */ public CopyOnWriteArrayList() &#123; setArray(new Object[0]); &#125; /** * Sets the array. */ final void setArray(Object[] a) &#123; array = a; &#125; CopyOnWriteArrayList 构造方法如果c是CopyOnWriteArrayList类型，直接把它的数组赋值给当前list的数组，注意这里是浅拷贝，两个集合共用同一个数组。 如果c不是CopyOnWriteArrayList类型，则进行拷贝把c的元素全部拷贝到当前list的数组中。 /** * Creates a list containing the elements of the specified * collection, in the order they are returned by the collection&#39;s * iterator. * * @param c the collection of initially held elements * @throws NullPointerException if the specified collection is null */ public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) //如果c也是CopyOnWriteArrayList类型,直接把它的数组拿过来使用 elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; // 否则调用其toArray()方法将集合元素转化为数组 elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) // 这里c.toArray()返回的不一定是Object[]类型,详细原因见ArrayList里面的分析 if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements); &#125; CopyOnWriteArrayList(E[] toCopyIn)构造方法把toCopyIn的元素拷贝给当前list的数组。 /** * Creates a list holding a copy of the given array. * * @param toCopyIn the array (a copy of this array is used as the * internal array) * @throws NullPointerException if the specified array is null */ public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class)); &#125; add(E e)方法添加一个元素到末尾。 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 获取旧数组 Object[] elements = getArray(); int len = elements.length; // 将旧数组元素拷贝到新数组中 // 新数组大小是旧数组大小加1 Object[] newElements = Arrays.copyOf(elements, len + 1); // 将元素放在最后一位 newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; （1）加锁； （2）获取元素数组； （3）新建一个数组，大小为原数组长度加1，并把原数组元素拷贝到新数组； （4）把新添加的元素放到新数组的末尾； （5）把新数组赋值给当前对象的array属性，覆盖原数组； （6）解锁； add(int index, E element)方法添加一个元素在指定索引处。 /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 获取旧数组 Object[] elements = getArray(); int len = elements.length; // 检查是否越界, 可以等于len if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+len); Object[] newElements; int numMoved = len - index; if (numMoved == 0) // 如果插入的位置是最后一位,那么拷贝一个n+1的数组, 其前n个元素与旧数组一致 newElements = Arrays.copyOf(elements, len + 1); else &#123; // 如果插入的位置不是最后一位,那么新建一个n+1的数组 newElements = new Object[len + 1]; // 拷贝旧数组前index的元素到新数组中 System.arraycopy(elements, 0, newElements, 0, index); // 将index及其之后的元素往后挪一位拷贝到新数组中 // 这样正好index位置是空出来的 System.arraycopy(elements, index, newElements, index + 1, numMoved); &#125; // 将元素放置在index处 newElements[index] = element; setArray(newElements); &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; （1）加锁； （2）检查索引是否合法，如果不合法抛出IndexOutOfBoundsException异常，注意这里index等于len也是合法的； （3）如果索引等于数组长度（也就是数组最后一位再加1），那就拷贝一个len+1的数组； （4）如果索引不等于数组长度，那就新建一个len+1的数组，并按索引位置分成两部分，索引之前（不包含）的部分拷贝到新数组索引之前（不包含）的部分，索引之后（包含）的位置拷贝到新数组索引之后（不包含）的位置，索引所在位置留空； （5）把索引位置赋值为待添加的元素； （6）把新数组赋值给当前对象的array属性，覆盖原数组； （7）解锁； addIfAbsent(E e)方法添加一个元素如果这个元素不存在于集合中。 /** * Appends the element, if not present. * * @param e element to be added to this list, if absent * @return &#123;@code true&#125; if the element was added */ public boolean addIfAbsent(E e) &#123; // 获取元素数组, 取名为快照 Object[] snapshot = getArray(); // 检查如果元素不存在,直接返回false // 如果存在再调用addIfAbsent()方法添加元素 return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false : addIfAbsent(e, snapshot); &#125; /** * A version of addIfAbsent using the strong hint that given * recent snapshot does not contain e. */ private boolean addIfAbsent(E e, Object[] snapshot) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 重新获取旧数组 Object[] current = getArray(); int len = current.length; // 如果快照与刚获取的数组不一致 // 说明有修改 if (snapshot != current) &#123; // Optimize for lost race to another addXXX operation // 重新检查元素是否在刚获取的数组里 int common = Math.min(snapshot.length, len); for (int i = 0; i &lt; common; i++) // 到这个方法里面了, 说明元素不在快照里面 if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) return false; if (indexOf(e, current, common, len) &gt;= 0) return false; &#125; // 拷贝一份n+1的数组 Object[] newElements = Arrays.copyOf(current, len + 1); // 将元素放在最后一位 newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; （1）检查这个元素是否存在于数组快照中； （2）如果存在直接返回false，如果不存在调用addIfAbsent(E e, Object[] snapshot)处理; （3）加锁； （4）如果当前数组不等于传入的快照，说明有修改，检查待添加的元素是否存在于当前数组中，如果存在直接返回false; （5）拷贝一个新数组，长度等于原数组长度加1，并把原数组元素拷贝到新数组中； （6）把新元素添加到数组最后一位； （7）把新数组赋值给当前对象的array属性，覆盖原数组； （8）解锁； get(int index)获取指定索引的元素，支持随机访问，时间复杂度为O(1)。 /** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; // 获取元素不需要加锁 // 直接返回index位置的元素 // 这里是没有做越界检查的, 因为数组本身会做越界检查 return get(getArray(), index); &#125; @SuppressWarnings(&quot;unchecked&quot;) private E get(Object[] a, int index) &#123; return (E) a[index]; &#125; /** * Gets the array. Non-private so as to also be accessible * from CopyOnWriteArraySet class. */ final Object[] getArray() &#123; return array; &#125; （1）获取元素数组； （2）返回数组指定索引位置的元素； remove(int index)方法删除指定索引位置的元素。 /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). Returns the element that was removed from the list. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 获取旧数组 Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) // 如果移除的是最后一位 // 那么直接拷贝一份n-1的新数组, 最后一位就自动删除了 setArray(Arrays.copyOf(elements, len - 1)); else &#123; // 如果移除的不是最后一位 // 那么新建一个n-1的新数组 Object[] newElements = new Object[len - 1]; // 将前index的元素拷贝到新数组中 System.arraycopy(elements, 0, newElements, 0, index); // 将index后面(不包含)的元素往前挪一位 // 这样正好把index位置覆盖掉了, 相当于删除了 System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; （1）加锁； （2）获取指定索引位置元素的旧值； （3）如果移除的是最后一位元素，则把原数组的前len-1个元素拷贝到新数组中，并把新数组赋值给当前对象的数组属性； （4）如果移除的不是最后一位元素，则新建一个len-1长度的数组，并把原数组除了指定索引位置的元素全部拷贝到新数组中，并把新数组赋值给当前对象的数组属性； （5）解锁并返回旧值； size()方法返回数组的长度。 /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() &#123; // 获取元素个数不需要加锁 // 直接返回数组的长度 return getArray().length; &#125; 总结（1）CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全； （2）CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能比较低下； （3）CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)； （4）CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合； （5）CopyOnWriteArrayList只保证最终一致性，不保证实时一致性； 问题:为什么CopyOnWriteArrayList没有size属性？因为每次修改都是拷贝一份正好可以存储目标个数元素的数组，所以不需要size属性了，数组的长度就是集合的大小，而不像ArrayList数组的长度实际是要大于集合的大小的。 比如，add(E e)操作，先拷贝一份n+1个元素的数组，再把新元素放到新数组的最后一位，这时新数组的长度为len+1了，也就是集合的size了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
        <tag>Collection</tag>
        <tag>源码分析</tag>
        <tag>CopyOnWriteArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList 源码分析]]></title>
    <url>%2Fposts%2F2019-01-02-LinkedList%2F</url>
    <content type="text"><![CDATA[LinkedList是一个以双向链表实现的List，它除了作为List使用，还可以作为队列或者栈来使用，它是怎么实现的呢？让我们一起来学习吧。 问题（1）LinkedList只是一个List吗？ （2）LinkedList还有其它什么特性吗？ （3）LinkedList为啥经常拿出来跟ArrayList比较？ 简介LinkedList是一个以双向链表实现的List，它除了作为List使用，还可以作为队列或者栈来使用，它是怎么实现的呢？ 继承体系![LinkedList.png](https://i.loli.net/2019/11/02/bF2yULoKJTxmPjl.png) 通过继承体系，我们可以看到LinkedList不仅实现了List接口，还实现了Queue和Deque接口，所以它既能作为List使用，也能作为双端队列使用，当然也可以作为栈使用。 源码分析主要属性// 元素个数 transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) * * 链表首节点 */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) * * 链表尾节点 */ transient Node&lt;E&gt; last; 属性很简单，定义了元素个数size和链表的首尾节点。 主要内部类典型的双链表结构： private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 主要构造方法/** * Constructs an empty list. */ public LinkedList() &#123; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#39;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 两个构造方法也很简单，可以看出是一个无界的队列。 添加元素作为一个双端队列，添加元素主要有两种，一种是在队列尾部添加元素，一种是在队列首部添加元素，这两种形式在LinkedList中主要是通过下面两个方法来实现的。 /** * Links e as first element. * 从队列首添加元素 */ private void linkFirst(E e) &#123; // 首节点 final Node&lt;E&gt; f = first; // 创建新节点，新节点的next是首节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 让新节点作为新的首节点 first = newNode; // 判断是不是第一个添加的元素，如果是就把last也置为新节点，否则把原首节点的prev指针置为新节点 if (f == null) last = newNode; else f.prev = newNode; // 元素个数加1 size++; // 修改次数加1，说明这是一个支持fail-fast的集合 modCount++; &#125; /** * Links e as last element. * 从队列尾添加元素 */ void linkLast(E e) &#123; // 队列尾节点 final Node&lt;E&gt; l = last; // 创建新节点，新节点的prev是尾节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 让新节点成为新的尾节点 last = newNode; // 判断是不是第一个添加的元素，如果是就把first也置为新节点，否则把原尾节点的next指针置为新节点 if (l == null) first = newNode; else l.next = newNode; // 元素个数加1 size++; // 修改次数加1 modCount++; &#125; /** * Inserts the specified element at the beginning of this list. * * @param e the element to add */ public void addFirst(E e) &#123; linkFirst(e); &#125; /** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;. * * @param e the element to add */ public void addLast(E e) &#123; linkLast(e); &#125; // Deque operations /** * Inserts the specified element at the front of this list. * 作为无界队列，添加元素总是会成功的 * * @param e the element to insert * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerFirst&#125;) * @since 1.6 */ public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; /** * Inserts the specified element at the end of this list. * * @param e the element to insert * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerLast&#125;) * @since 1.6 */ public boolean offerLast(E e) &#123; addLast(e); return true; &#125; 典型的双链表在首尾添加元素的方法了。 上面是作为双端队列来看，它的添加元素分为首尾添加元素，那么，作为List呢？ 作为List，是要支持在中间添加元素的，主要是通过下面这个方法实现的。 /** * Inserts element e before non-null Node succ. * 在节点succ之前添加元素 */ void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // succ是待添加节点的后继节点 ， 找到待添加节点的前置节点 final Node&lt;E&gt; pred = succ.prev; // 在其前置节点和后继节点之间创建一个新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 修改后继节点的前置指针指向新节点 succ.prev = newNode; // 判断前置节点是否为空，如果为空，说明是第一个添加的元素，修改first指针，否则修改前置节点的next为新节点 if (pred == null) first = newNode; else pred.next = newNode; // 修改元素个数 size++; // 修改次数加1 modCount++; &#125; /** * Returns the (non-null) Node at the specified element index. * 寻找index位置的节点 */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 因为是双链表，所以根据index是在前半段还是后半段决定从前遍历还是从后遍历 // 这样index在后半段的时候可以少遍历一半的元素 if (index &lt; (size &gt;&gt; 1)) &#123; // 如果是在前半段，就从前遍历 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 如果是在后半段， 就从后遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * 在指定index位置处添加元素 * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; // 判断是否越界 checkPositionIndex(index); // 如果index是在队列尾节点之后的一个位置 // 把新节点直接添加到尾节点之后 // 否则调用linkBefore()方法在中间添加节点 if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125; 在中间添加元素的方法，典型的双链表在中间添加元素的方法。 添加元素的三种方式大致如下图所示： ![LinkedList-1.png](https://i.loli.net/2019/11/15/HlCbXhRk7LScTzx.png) 在队列首尾添加元素很高效，时间复杂度为O(1)。 在中间添加元素比较低效，首先要先找到插入位置的节点，再修改前后节点的指针，时间复杂度为O(n)。 删除元素作为双端队列，删除元素也有两种方式，一种是队列首删除元素，一种是队列尾删除元素。 作为List，又要支持中间删除元素，所以删除元素一个有三个方法，分别如下： /** * Unlinks non-null first node f. * 删除首节点 */ private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; // 首节点的元素值 final E element = f.item; // 首节点的next指针 final Node&lt;E&gt; next = f.next; // 添加首节点的内容，协助GC f.item = null; f.next = null; // help GC // 把首节点的next作为新的首节点 first = next; // 如果只有一个元素，删除了，把last也置为空，否则把next的前置指针置为空 if (next == null) last = null; else next.prev = null; // 元素个数减1 size--; // 修改次数加1 modCount++; // 返回删除的元素 return element; &#125; /** * Unlinks non-null last node l. * // 删除尾节点 */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; // 尾节点的元素值 final E element = l.item; // 尾节点的前置指针 final Node&lt;E&gt; prev = l.prev; // 清空尾节点的内容，协助GC l.item = null; l.prev = null; // help GC // 让前置节点成为新的尾节点 last = prev; // 如果只有一个元素，删除了把first置为空 // 否则把前置节点的next置为空 if (prev == null) first = null; else prev.next = null; // 元素个数减1 size--; // 修改次数加1 modCount++; // 返回删除的元素 return element; &#125; /** * Unlinks non-null node x. * 删除指定节点x */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; // x的元素值 final E element = x.item; // x的前置节点 final Node&lt;E&gt; next = x.next; // x的后置节点 final Node&lt;E&gt; prev = x.prev; // 如果前置节点为空，说明是首节点，让first指向x的后置节点，否则修改前置节点的next为x的后置节点 if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; // 如果后置节点为空，说明是尾节点，让last指向x的前置节点， 否则修改后置节点的prev为x的前置节点 if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; // 清空x的元素值，协助GC x.item = null; // 元素个数减1 size--; // 修改次数加1 modCount++; // 返回删除的元素 return element; &#125; /** * Removes and returns the first element from this list. * remove的时候如果没有元素抛出异常 * * @return the first element from this list * @throws NoSuchElementException if this list is empty */ public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125; /** * Removes and returns the last element from this list. * remove的时候如果没有元素抛出异常 * * @return the last element from this list * @throws NoSuchElementException if this list is empty */ public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; /** * Retrieves and removes the first element of this list, * or returns &#123;@code null&#125; if this list is empty. * poll的时候如果没有元素返回null * * @return the first element of this list, or &#123;@code null&#125; if * this list is empty * @since 1.6 */ public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; /** * Retrieves and removes the last element of this list, * or returns &#123;@code null&#125; if this list is empty. * poll的时候如果没有元素返回null * * @return the last element of this list, or &#123;@code null&#125; if * this list is empty * @since 1.6 */ public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); &#125; /** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * 删除中间节点 * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; // 检查是否越界 checkElementIndex(index); // 删除指定index位置的节点 return unlink(node(index)); &#125; 删除元素的三种方法都是典型的双链表删除元素的方法，大致流程如下图所示: ![LinkedList-2.png](https://i.loli.net/2019/11/15/DUmEx2vNM4V9uSb.png) 在队列首尾删除元素很高效，时间复杂度为O(1)。 在中间删除元素比较低效，首先要找到删除位置的节点，再修改前后指针，时间复杂度为O(n)。 栈LinkedList是双端队列，双端队列可以作为栈使用： /** * Pushes an element onto the stack represented by this list. In other * words, inserts the element at the front of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addFirst&#125;. * * @param e the element to push * @since 1.6 */ public void push(E e) &#123; addFirst(e); &#125; /** * Pops an element from the stack represented by this list. In other * words, removes and returns the first element of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #removeFirst()&#125;. * * @return the element at the front of this list (which is the top * of the stack represented by this list) * @throws NoSuchElementException if this list is empty * @since 1.6 */ public E pop() &#123; return removeFirst(); &#125; 栈的特性是LIFO(Last In First Out)，所以作为栈使用也很简单，添加删除元素都只操作队列首节点即可 总结（1）LinkedList是一个以双链表实现的List； （2）LinkedList还是一个双端队列，具有队列、双端队列、栈的特性； （3）LinkedList在队列首尾添加、删除元素非常高效，时间复杂度为O(1)； （4）LinkedList在中间添加、删除元素比较低效，时间复杂度为O(n)； （5）LinkedList不支持随机访问，所以访问非队列首尾的元素比较低效； （6）LinkedList在功能上等于ArrayList + ArrayDeque；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
        <tag>LinkedList</tag>
        <tag>Collection</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3安装opencv爬坑步骤]]></title>
    <url>%2Fposts%2F2018-12-04-python_opencv%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;python3安装opencv，但是导入失败？ &emsp;&emsp;各种尝试安装opencv,但是导入都是失败，这是什么问题呢？ &emsp;&emsp;以前总是这样安装：pip3 install opencv-python，安装是成功了，可是导入的时候总是报错，没找到cv2的包，这里，再安装一个opencv-contrib-python模块。 &emsp;&emsp;试试 pip3 install opencv-contrib-python &emsp;&emsp;这时候，如果导入cv2还报错，请按照如下错误解决问题： &emsp;&emsp;（1）ImportError: libjasper.so.1: cannot open shared object file: No such file or directory &emsp;&emsp;请安装 apt install libjasper-dev &emsp;&emsp;（2）ImportError: libQtGui.so.4: cannot open shared object file: No such file or directory &emsp;&emsp;请安装 apt install libqtgui4 &emsp;&emsp;（3）ImportError: libQtTest.so.4: cannot open shared object file: No such file or directory &emsp;&emsp;请安装 apt install libqt4-test &emsp;&emsp;这些问题，看着不难，但是从遇到到解决，还是花了不少时间。总结下，还是直接一次安装完比较好，这里提供一份完整爬坑指南： &emsp;&emsp;pip3 install opencv-contrib-python &emsp;&emsp;apt install libjasper-dev libqtgui4 libqt4-test libhdf5-dev libatlas-base-dev &emsp;&emsp;apt update &emsp;&emsp;相信到了这里，应该能搞定了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 源码分析]]></title>
    <url>%2Fposts%2F2019-01-01-ArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList是一种以数组实现的List，与数组相比，它具有动态扩展的能力，因此也可称之为动态数组。 简介ArrayList是一种以数组实现的List，与数组相比，它具有动态扩展的能力，因此也可称之为动态数组。 继承体系![ArrayList.png](https://i.loli.net/2019/11/02/IBrCjLM16gmVGpW.png) ArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。 ArrayList实现了List，提供了基础的添加、删除、遍历等操作。 ArrayList实现了RandomAccess，提供了随机访问的能力。 ArrayList实现了Cloneable，可以被克隆。 ArrayList实现了Serializable，可以被序列化。 源码解析属性/** * Default initial capacity. * 默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. * 空数组，如果传入的容量是0时使用 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * 空数组，传入容量时使用，添加第一个元素的时候会重新初始化为默认容量大小 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * 存储元素的数值 */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * 集合中元素的个数 * @serial */ private int size; DEFAULT_CAPACITY 默认容量为10，也就是通过new ArrayList()创建时的默认容量。 EMPTY_ELEMENTDATA 空的数组，这种是通过new ArrayList(0)创建时用的是这个空数组。 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 也是空数组，这种是通过new ArrayList()创建时用的是这个空数组，与EMPTY_ELEMENTDATA的区别是在添加第一个元素时使用这个空数组的会初始化为DEFAULT_CAPACITY（10）个元素。 elementData 真正存放元素的地方，使用transient是为了不序列化这个字段。 至于没有使用private修饰，后面注释是写的“为了简化嵌套类的访问”，但是实测加了private嵌套类一样可以访问（?）。 private表示是类私有的属性，只要是在这个类内部都可以访问，嵌套类或者内部类也是在类的内部，所以也可以访问类的私有成员。 size 真正存储元素的个数，而不是elementData数组的长度。 ArrayList(int initialCapacity)构造方法传入初始容量，如果大于0就初始化elementData为对应大小，如果等于0就使用EMPTY_ELEMENTDATA空数组，如果小于0抛出异常。 /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 如果传入的初始容量大于0，就新建一个数组存储元素 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 如果传入的初始容量等于0，使用空数组EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 如果传入的初始容量小于0，抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity); &#125; &#125; ArrayList()构造方法不传初始容量，初始化为DEFAULTCAPACITY_EMPTY_ELEMENTDATA空数组，会在添加第一个元素的时候扩容为默认的大小，即10。 /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; // 如果没有传入初始容量，则使用空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA // 使用这个数组是在添加第一个元素的时候会扩容到默认大小10 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; ArrayList 构造方法传入集合并初始化elementData，这里会使用拷贝把传入集合的元素拷贝到elementData数组中，如果元素个数为0，则初始化为EMPTY_ELEMENTDATA空数组。 /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#39;s * iterator. * * 把传入集合的元素初始化到ArrayList中 * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 集合转数组 elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) // 检查c.toArray()返回的是不是Object[]类型，如果不是，重新拷贝成Object[].class类型 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. // 如果c的空集合，则初始化为空数组EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 为什么c.toArray();返回的有可能不是Object[]类型呢？ add(E e)方法添加元素到末尾，平均时间复杂度为O(1)。 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; // 检查是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 把元素插入到最后一位 elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; // 如果是空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，就初始化为默认大小10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code // 扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新容量为旧容量的1.5倍 【右移运算 除以2的n次方】 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果新容量发现比需要的容量还小，则以需要的容量为准 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量已经超过最大容量了，则使用最大容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 以新容量拷贝出来一个新数组 elementData = Arrays.copyOf(elementData, newCapacity); &#125; （1）检查是否需要扩容； （2）如果elementData等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA则初始化容量大小为DEFAULT_CAPACITY； （3）新容量是老容量的1.5倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果加了这么多容量发现比需要的容量还小，则以需要的容量为准； （4）创建新容量的数组并把老数组拷贝到新数组； add(int index, E element)方法添加元素到指定位置，平均时间复杂度为O(n)。 /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; // 检查是否越界 rangeCheckForAdd(index); // 检查是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将inex及其之后的元素往后挪一位，则index位置处就空出来了 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将元素插入到index的位置 elementData[index] = element; // 大小增1 size++; &#125; /** * A version of rangeCheck used by add and addAll. */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; （1）检查索引是否越界； （2）检查是否需要扩容； （3）把插入索引位置后的元素都往后挪一位； （4）在插入索引位置放置插入的元素； （5）大小加1； addAll 方法求两个集合的并集。 /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection&#39;s Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * 将集合c中所有元素添加到当前ArrayList中 * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 将集合c转为数组 Object[] a = c.toArray(); int numNew = a.length; // 检查是否需要扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 将c中元素全部拷贝到数组的最后 System.arraycopy(a, 0, elementData, size, numNew); // 大小增加c的大小 size += numNew; // 如果c不为空就返回true，否则返回false return numNew != 0; &#125; （1）拷贝c中的元素到数组a中； （2）检查是否需要扩容； （3）把数组a中的元素拷贝到elementData的尾部； get(int index)方法获取指定索引位置的元素，时间复杂度为O(1)。 /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; // 检查是否越界 rangeCheck(index); // 返回数组index位置的元素 return elementData(index); &#125; /** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; @SuppressWarnings(&quot;unchecked&quot;) E elementData(int index) &#123; return (E) elementData[index]; &#125; （1）检查索引是否越界，这里只检查是否越上界，如果越上界抛出IndexOutOfBoundsException异常，如果越下界抛出的是ArrayIndexOutOfBoundsException异常。 （2）返回索引位置处的元素； remove(int index)方法删除指定索引位置的元素，时间复杂度为O(n)。 /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; // 检查是否越界 rangeCheck(index); modCount++; // 获取index位置的元素 E oldValue = elementData(index); // 如果index不是最后一位，则将index之后的元素往前挪一位 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素删除，帮助GC elementData[--size] = null; // clear to let GC do its work // 返回旧值 return oldValue; &#125; （1）检查索引是否越界； （2）获取指定索引位置的元素； （3）如果删除的不是最后一位，则其它元素往前移一位； （4）将最后一位置为null，方便GC回收； （5）返回删除的元素。 可以看到，ArrayList删除元素的时候并没有缩容。 remove(Object o)方法删除指定元素值的元素，时间复杂度为O(n)。 /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; // 遍历整个数组，找到元素第一次出现的位置，并将其快速删除 for (int index = 0; index &lt; size; index++) // 如果要删除的元素为null，则以null进行比较，使用== if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; // 遍历整个数组，找到元素第一次出现的位置，并将其快速删除 for (int index = 0; index &lt; size; index++) // 如果要删除的元素不为null，则进行比较，使用equals()方法 if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; // 这里没有越界的检查，是不是少了？？？ modCount++; // 如果index不是最后一位，则将index之后的元素往前挪一位 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素删除，帮助GC elementData[--size] = null; // clear to let GC do its work &#125; （1）找到第一个等于指定元素值的元素； （2）快速删除； fastRemove(int index)相对于remove(int index)少了检查索引越界的操作，可见jdk将性能优化到极致。 retainAll方法求两个集合的交集。 /** * Retains only the elements in this list that are contained in the * specified collection. In other words, removes from this list all * of its elements that are not contained in the specified collection. * * @param c collection containing elements to be retained in this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) &#123; // 集合c不能为null Objects.requireNonNull(c); // 调用批量删除方法，这时complement传入true，表示删除不包含在c中的元素 return batchRemove(c, true); &#125; /** * 批量删除元素 * complement为true表示删除c中不包含的元素 * complement为false表示删除c中包含的元素 */ private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // 使用读写两个指针同时遍历数组 // 读指针每次自增1，写指针放入元素的时候才加1 // 这样不需要额外的空间，只需要在原有的数组上操作就可以了 int r = 0, w = 0; boolean modified = false; try &#123; // 遍历整个数组，如果c中包含该元素，则把该元素放到写指针的位置（以complement为准） for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. // 正常来说r最后是等于size的，除非c.contains()抛出了异常 if (r != size) &#123; // 如果c.contains()抛出了异常，则把未读的元素都拷贝到写指针之后 System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work // 将写指针之后的元素置为空，帮助GC for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; // 新大小等于写指针的位置（因为每写一次写指针就加1，所以新大小正好等于写指针的位置） size = w; modified = true; &#125; &#125; // 有修改返回true return modified; &#125; （1）遍历elementData数组； （2）如果元素在c中，则把这个元素添加到elementData数组的w位置并将w位置往后移一位； （3）遍历完之后，w之前的元素都是两者共有的，w之后（包含）的元素不是两者共有的； （4）将w之后（包含）的元素置为null，方便GC回收； removeAll求两个集合的单方向差集，只保留当前集合中不在c中的元素，不保留在c中不在当前集体中的元素。 /** * Removes from this list all of its elements that are contained in the * specified collection. * * @param c collection containing elements to be removed from this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) &#123; // 集合c不能为空 Objects.requireNonNull(c); // 同样调用批量删除方法，这时complement传入false，表示删除包含在c中的元素 return batchRemove(c, false); &#125; 与retainAll(Collection&lt;?&gt; c)方法类似，只是这里保留的是不在c中的元素。 总结（1）ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容； （2）ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)； （3）ArrayList添加元素到尾部极快，平均时间复杂度为O(1)； （4）ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)； （5）ArrayList从尾部删除元素极快，时间复杂度为O(1)； （6）ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)； （7）ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可； （8）ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可； （9）ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可； 思考elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？ /** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff // 防止序列化期间有修改 int expectedModCount = modCount; // 写出非transient非static属性（会写出size属性） s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() // 写出元素个数 s.writeInt(size); // Write out all elements in the proper order. // 依次写出元素 for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; // 如果有修改，抛出异常 if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // 声明为空数组 elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff // 读入非transient非static属性（会读取size属性） s.defaultReadObject(); // Read in capacity // 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读 s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity // 计算容量 int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); // 检查是否需要扩容 ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. // 依次读取元素到数组中 for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。 一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。 在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。 elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
        <tag>Collection</tag>
        <tag>源码分析</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内主流视频网站VIP视频解析接口]]></title>
    <url>%2Fposts%2F2018-11-02-vipjiexi%2F</url>
    <content type="text"><![CDATA[为什么使用需要这些视频解析接口？ 首先没有广告，最重要的是支持VIP等需要会员才能观看的视频。 使用方法： 将需要播放VIP视频的网址复制到上述任一接口后面，在浏览器打开即可。 注意：如果接口失效，请联系我或者留言，我会及时更新！ 2019年01月02日更新：http://api.smq1.com/?url= https://api.smq1.com/?url= https://jx.hezeshi.net/ce/jlexi.php?url= http://api.hellosex.cc/jlexi.php?url= https://api.pangujiexi.com/player.php?url= http://at520.cn/jx/?url=http://www.cmys.tv/?url= https://jx.km58.top/jx/?url= http://www.fantee.net/fantee/?url= http://api.51ckm.com/Box.php?url= https://www.3aym.cn/?url= http://beaacc.com/api.php?url= http://api.zuilingxian.com/jiexi.php?url= http://jx.2tv.org/?url= http://api.bbbbbb.me/ipsign/player.php?v= http://17kyun.com/api.php?url= 2018年12月06日更新：https://jx.hezeshi.net/ce/jlexi.php?url= http://api.hellosex.cc/jlexi.php?url= https://api.pangujiexi.com/player.php?url= http://at520.cn/jx/?url= http://player.jidiaose.com/supapi/iframe.php?v= https://jx.okokjx.com/okok/?url= http://api.jykkk.com/?url= https://jx.km58.top/jx/?url= http://jx.fantee.net/fantee/?url= http://api.51ckm.com/Box.php?url= http://www.1717yun.com/jx/ty.php?url= https://www.3aym.cn/?url= http://beaacc.com/api.php?url= http://api.zuilingxian.com/jiexi.php?url= http://jx.2tv.org/?url= http://cdn.yangju.vip/k/?url= http://api.bbbbbb.me/ipsign/player.php?v= http://17kyun.com/api.php?url= 2018年08月10日更新：http://www.iwkan.cn/jx2/?url= http://api.ledboke.com/?url= http://ckparse.kaizhoukm.com/play/vippcq.php?url= http://jqaaa.com/jx.php?url= http://api.47ks.com/webcloud/?v= http://api.xfsub.com/index.php?url= http://jx.du2.cc/jx6.php?url= http://jx.du2.cc/?url= 2018年07月08日更新：http://lykezhan.com/vip/ http://yy.zhiliaotang.com/vip/ http://www.5ifxw.com/vip/ http://www.qmaile.com http://tv.myhack58.com http://www.51onb.com/filmvip/ 2018年06月27日更新：https://api.pangujiexi.com/player.php?url= http://api.ledboke.com/vip/?url= http://vip.qike.ink/?url= http://jx.598110.com/index.php?url= http://player.jidiaose.com/supapi/iframe.php?v= http://api.91exp.com/svip/?url= http://v.72du.com/api/?url= http://api.bbbbbb.me/ipsign/player.php?v= http://17kyun.com/api.php?url= 2018年05月02日更新：http://www.662820.com/xnflv/index.php?url= http://api.lldyy.net/svip/?url= http://www.82190555.com/index/qqvod.php?url= http://jiexi.92fz.cn/player/vip.php?url= http://jiexi.071811.cc/jx2.php?url= http://api.wlzhan.com/sudu/?url= http://beaacc.com/api.php?url= http://qxkkk.bid/jx/jx.php?url= http://www.27v9.cn/index.php?url= http://www.ckplayer.tv/kuku/?url= http://o8ve.cn/1/?url= http://api.xyingyu.com/?url= https://jx.kt111.top/jx/mf/?url= https://api.pangujiexi.com/player.php?url= http://api.lvcha2017.cn/?url= http://kkk.2016ve.cn/kkjx/index.php?url= http://mlxztz.com/vip/?url= http://www.aktv.men/?url= http://jy777.cn/XSD/XSD/?url= http://api.visaok.net/?url= http://api.xyingyu.com/?url= http://api.greatchina56.com/?url= http://jx.618g.com/?url= http://api.baiyug.vip/index.php?url= http://jx.jfysz.cn/jx.php/?url= http://jx.ektao.cn/jx.php/?url= http://jx.reclose.cn/jx.php/?url= http://jx.eayn.org.cn/jx.php/?url= http://api.xyingyu.com/?url= http://jx.iaeec.cn/jx.php/?url= http://jx.83y4n7a.cn/jx.php/?url= http://jx.cmbzzs.cn/jx.php/?url= http://api.greatchina56.com/?url= http://jx.as19811.cn/jx.php/?url= http://jx.sdjnd09.cn/jx.php/?url= http://api.baiyug.vip/index.php?url= http://jx.09876as.cn/jx.php/?url= http://jx.17ktv.com.cn/jx.php/?url= http://jx.ab78a.cn/jx.php/?url= http://jx.09877as.cn/jx.php/?url= http://jx.yipolo111.cn/jx.php/?url= http://jx.908astbb.cn/jx.php/?url= http://jx.dlzyrk001.cn/jx.php/?url= http://jx.dccmy.org.cn/jx.php/?url= http://jx.boctx.cn/jx.php/?url= http://jx.hxbte.cn/jx.php/?url= http://api.visaok.net/?url= http://jx.618g.com/?url= http://yun.baiyug.cn/vip/?url= http://api.baiyug.cn/vip/?url= https://api.flvsp.com/?url= http://api.xfsub.com/index.php?url= http://api.xfsub.com/index.php?url= http://jiexi.071811.cc/jx2.php?url= http://player.jidiaose.com/supapi/iframe.php?v= http://www.82190555.com/index/qqvod.php?url= http://api.pucms.com/?url= http://api.baiyug.cn/vip/index.php?url= https://api.flvsp.com/?url= http://www.82190555.com/index/qqvod.php?url= http://2gty.com/apiurl/yun.php?url= http://v.2gty.com/apiurl/yun.php?url= 2018年04月17日更新：http://api.visaok.net/?url= http://api.xyingyu.com/?url= http://api.greatchina56.com/?url= http://jx.618g.com/?url= http://api.xyingyu.com/?url= http://api.greatchina56.com/?url= http://api.visaok.net/?url= http://jx.618g.com/?url= http://zuiai.ml/dh/jx/ajx.php?url= http://zuiai.ml/dh/jx/jx.php?url= http://zuiai.ml/dh/jx/jiexi.php?url= 2018年03月22日更新：无广告 http://player.jidiaose.com/supapi/iframe.php?v= 爱奇艺推荐(无广告) http://api.xfsub.com/index.php?url= 爱奇艺、优酷推荐 https://jx.okokjx.com/okokjx/?url= 万能接口1 http://api.47ks.com/webcloud/?v= 万能接口2 http://wwwhe1.177kdy.cn/4.php?pass=2&amp;url= 万能接口3 https://api.daidaitv.com/index/?url= 万能接口4 http://jx.aeidu.cn/index.php?url= 爱奇艺接口1 http://api.baiyug.cn/vip/?url= 爱奇艺接口2 http://api.baiyug.cn/vip/index.php?url= 腾讯视频接口1 http://www.82190555.com/index/qqvod.php?url= 2018年01月22日更新：http://17kyun.com/api.php?url= http://jx.biaoge.tv/index.php?url= http://www.85105052.com/admin.php?url= http://api.iy11.cn/apiget.php?url= http://api.baiyug.cn/vip/index.php?url= http://jx.hanximeng.com/m3u8.php?url= http://jx.39book.com/Client/apiget.php?url= http://014670.cn/jx/ty.php?url= http://www.ibb6.com/x1/?url= http://tv.x-99.cn/api/wnapi.php?id= http://www.52rjb.cn/vip1/?url= http://www.52rjb.cn/vip2/?url= http://www.52rjb.cn/vip3/?url= http://49.4.144.33/xfjx/1.php?url= http://7cyd.com/vip/?url= https://47ksvip.duapp.com/vip/2mm/?vid= 2016年12月06日更新：http://www.vipjiexi.com/yun.php?url= http://www.wmxz.wang/video.php?url= http://www.yydy8.com/common/?url= http://www.wmxz.wang/video.php?url= http://5qiyi.sdyhy.cn/5qiyi/5qiyi1.php?url= http://5qiyi.sdyhy.cn/5qiyi/5qiyi2.php?url= http://vip.sdyhy.cn/ckflv/?url= http://player.gakui.top/?url= http://mt2t.com/yun?url= http://qtzr.net/s/?qt= http://www.xiguaso.com/api/index.php?url= http://www.vipjiexi.com/yun.php?url=]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>vip</tag>
        <tag>video</tag>
        <tag>视频解析</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Nginx以及uwsgi 的 Django 环境搭建]]></title>
    <url>%2Fposts%2F2018-04-12-django_centos_setup%2F</url>
    <content type="text"><![CDATA[基于Nginx以及uwsgi环境下，Django环境搭建，记录下来 !!! 安装 Django先安装pip,再通过pip安装Django。 1.安装pip cd /data; mkdir tmp; cd tmp; wget https://bootstrap.pypa.io/get-pip.py; python ./get-pip.py; 2.使用 PIP，安装 Django pip install Django==1.11.7 安装 Mysql1.安装并启动 mariadb 因为 CentOS 7 之后的版本都不在提供 Mysql 安装源，这里我们使用 mariadb 代替 mysql，依次执行下列命令 yum install mariadb mariadb-server -y yum install MySQL-python -y systemctl start mariadb 2.对 mariadb 进行初始化设置 执行下面命令，根据提示操作 设置新密码为 test 默认密码为空，直接回车即可 mysql_secure_installation 3.使用设置的密码登陆 mariadb 登陆 db，这里假设密码被设置为 test mysql -uroot -ptest 4.创建一个数据库 create database mysite; 5.成功后，输入 exit 命令退出 db exit 创建 Django 项目1.创建 mysite 项目 在 /data/ 目录下，创建一个名为 mysite 的 Django 项目 cd /data/ django-admin startproject mysite 2.修改配置文件，与 Mysql 数据库相关联 备注：SECRET_KEY 配置项无需修改 编辑 /data/mysite/mysite/settings.py 示例代码：/data/mysite/mysite/settings.py """ Django settings for mysite project. Generated by 'django-admin startproject' using Django 1.11.7. For more information on this file, see https://docs.djangoproject.com/en/1.11/topics/settings/ For the full list of settings and their values, see https://docs.djangoproject.com/en/1.11/ref/settings/ """ import os # Build paths inside the project like this: os.path.join(BASE_DIR, ...) BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # Quick-start development settings - unsuitable for production # See https://docs.djangoproject.com/en/1.11/howto/deployment/checklist/ # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = 'm4@g1=hz^08y(9d)v5l!8^*0wbla=oe15s@u8@5^pw=llfz48%' # SECURITY WARNING: don't run with debug turned on in production! DEBUG = True ALLOWED_HOSTS = ["*"] # Application definition INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] ROOT_URLCONF = 'mysite.urls' TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] WSGI_APPLICATION = 'mysite.wsgi.application' # Database # https://docs.djangoproject.com/en/1.11/ref/settings/#databases DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mysite', 'PASSWORD':'test', 'USER': 'root', 'HOST':'127.0.0.1', 'PORT':'3306', } } # Password validation # https://docs.djangoproject.com/en/1.11/ref/settings/#auth-password-validators AUTH_PASSWORD_VALIDATORS = [ { 'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', }, { 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', }, { 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', }, { 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', }, ] # Internationalization # https://docs.djangoproject.com/en/1.11/topics/i18n/ LANGUAGE_CODE = 'en-us' TIME_ZONE = 'UTC' USE_I18N = True USE_L10N = True USE_TZ = True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/1.11/howto/static-files/ STATIC_URL = '/static/' 3.创建 Django 数据库 cd /data/mysite python manage.py migrate 4.启动 Django python manage.py runserver 如果没有报错，就说明 Django 已经安装成功了，并且跟 Mysql 的连接正常 5.退出 Django 按 ctrl+c 退出 Django 服务 安装 Nginx1.通过 yum 安装 Nginx yum install nginx -y 2.启动 Nginx 服务 systemctl start nginx 访问你的服务器IP，可以看到 nginx 的欢迎界面 http://&lt;您的 server IP 地址&gt;/ 安装 uwsgi使用 yum 命令安装 uwsgi yum install uwsgi uwsgi-plugin-python -y 让 Nginx，uwsgi，Django 协同工作[精华部分]1.修改 Nginx 配置文件 编辑 /etc/nginx/nginx.conf # For more information on configuration, see: # * Official English Documentation: http://nginx.org/en/docs/ # * Official Russian Documentation: http://nginx.org/ru/docs/ user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; # Load dynamic modules. See /usr/share/nginx/README.dynamic. include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8000; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } # Settings for a TLS enabled server. # # server { # listen 443 ssl http2 default_server; # listen [::]:443 ssl http2 default_server; # server_name _; # root /usr/share/nginx/html; # # ssl_certificate "/etc/pki/nginx/server.crt"; # ssl_certificate_key "/etc/pki/nginx/private/server.key"; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 10m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # # # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # # location / { # } # # error_page 404 /404.html; # location = /40x.html { # } # # error_page 500 502 503 504 /50x.html; # location = /50x.html { # } # } } 2.重启 Nginx /usr/sbin/nginx -s reload 3.创建 uwsgi 配置文件 在 /data/mysite 目录下创建 uwsgi.ini，参考下面的内容 示例代码：/data/mysite/uwsgi.ini [uwsgi] socket = 127.0.0.1:8000 chdir = /data/mysite wsgi-file = mysite/wsgi.py processes = 4 threads = 2 stats = 127.0.0.1:9191 uid = nobody gid = nobody master = true harakiri = 30 daemonize = /data/mysite/uwsgi.log plugins = python 4.启动 uwsgi uwsgi uwsgi.ini 搭建完成访问链接 http://&lt;您的 server IP 地址&gt;/ 如果可以看到 Django 的界面，恭喜你，环境搭建成功]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[180G喜马拉雅收费音频大合集]]></title>
    <url>%2Fposts%2F2018-04-10-ximalaya%2F</url>
    <content type="text"><![CDATA[所有链接密码都是6666，无任何解压密码，价值不清楚，选你喜欢的来存。 主要网站 No. 网站 链接 1 传统国学(14套) https://pan.baidu.com/s/12O8lYNrV9c2ixraP7_gY6A 2 健康养生 https://pan.baidu.com/s/136CBDpo1cxc4MJzeHyEMCA 3 金融财经 https://pan.baidu.com/s/1w5Mc4EHbP2ZNVsRpdV60uw 4 亲子育儿 https://pan.baidu.com/s/19jTHFqw0tIMO9yzwkLaP6w 5 外语语言 https://pan.baidu.com/s/1bNAxiNgrrXbe-jdZALIUEA 6 职场管理 https://pan.baidu.com/s/10VLPuVf21Y6-HwY0igHKXg 7 情感心理 https://pan.baidu.com/s/1OqFm40915-QV-9SOZSme0A 8 演讲语言 https://pan.baidu.com/s/1-wUFDqetIWWgdK9v_FnnaA 9 诗歌小说 https://pan.baidu.com/s/1ERmupi5LCiZP20eRGeMpDg 10 烧脑记忆 https://pan.baidu.com/s/1QFaQxQGpsQBL2YGy-2VvwA 密码：mkpt 11 文学艺术 https://pan.baidu.com/s/1eDZJDfgeAT4Y-Zjoo3rC_A 12 女神养成 https://pan.baidu.com/s/15X0sCMqMIRY_T9cvl0koBg 13 音乐艺术 https://pan.baidu.com/s/1Z8yugUin03MWH7xD1Is4-g 14 中学课程 https://pan.baidu.com/s/1SGnwi48txASVFht9Enwq5g 15 读书类 https://pan.baidu.com/s/1e1oM7o3Mbd4Oj8jBvU3gdw 16 人文社会 https://pan.baidu.com/s/1heGyEioXxTa6tEGItBC3Eg 17 个人素质 https://pan.baidu.com/s/1-VC0fcZchgq4LR6VtLHBZg 18 其他类 https://pan.baidu.com/s/1C-eNzhCujO0QfT35P4U4yA 19 新增栏目尚未分类 https://pan.baidu.com/s/1-uIgEDUEFt-WKYgacxZBhQ]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>喜马拉雅FM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你敢信?Java10发布了！！！]]></title>
    <url>%2Fposts%2F2018-03-21-java10%2F</url>
    <content type="text"><![CDATA[没有跳票的Java10，正式发布！ 不知是不是OUT了，Java9还没在生产环境中使用过，Java10就发布了。 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html 为了更快地迭代更新，以及跟进社区反馈，Java 的版本发布周期变更为每六个月一次，并且承诺不会跳票。 新的发布周期也会严格遵循时间点，将在每年的 3 月份和 9 月份发布，所以 Java 10 的版本号是 18.3。 （貌似有点像Ubuntu的发布周期的模式） Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性。 JDK10 包含 12 个JEP (改善提议）：1.【286】局部变量类型推断：对于开发者来说，这是JDK10唯一的真正特性。 它向Java中引入在其他语言中很常见的 var ，比如JavaScript。只要编译器可以推断此种类型，你不再需要专门声明一个局部变量的类型。 一个简单的例子是： var x = new ArrayList(); 这就消除了之前必须执行的 ArrayList 类型定义的重复。 有趣的是，需要注意 var 不能成为一个关键字，而是一个保留字。这意味着你仍然可以使用 var 作为一个变量，方法或包名，但是现在不能再有一个类被调用。 2.[310]应用类数据共享(CDS) ：CDS 在JDK5时被引进以改善 JVM 启动的表现，同时减少当多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。 JDK10 将扩展 CDS 到允许内部系统的类加载器、内部平台的类加载器和自定义类加载器来加载获得的类。 之前，CDS 的使用仅仅限制在了 bootstrap 的类加载器。 3.[314]额外的 Unicode 语言标签扩展：这将改善 java.util.Locale 类和相关的 API 以实现额外 BCP 47 语言标签的 Unicode 扩展。 尤其是，货币类型，一周的第一天，区域覆盖和时区等标签现在将被支持。 4.[322]基于时间的版本控制：JDK 版本字符串格式几乎与 JDK 版本一样多。有幸的是，这是最后需要使用到的，可以坚持用它。这种格式使用起来很像 JDK9 中介绍的提供一个更加语义的形式。 有一件困扰我的事是包含了一个 INTERIM 元素，正如 JEP 提议中所说，“永远是0”。好吧，如果永远是0，那它有什么意义呢？他们说这是为未来使用做保留… 这也消除了在 JDK9 中有过的相当奇怪的情形。 第一次更新是 JDK 9.0.1 , 非常符合逻辑。第二次更新是 JDK 9.0.4 ，不合逻辑。原因是，在 JDK9 的版本计数模式下，需要留下空白以便应急或不在预期安排的更新使用。但既然没有更新是必须的，为什么不简单称之为 JDK 9.0.2 呢？ 5.[319]根证书：在 JDK 中将提供一套默认的 CA 根证书。关键的安全部件，如 TLS ，在 OpenJDK 构建中将默认有效。这是 Oracle 正在努力确保 OpenJDK 二进制和 Oracle JDK 二进制功能上一样的工作的一部分，是一项有用的补充内容。 6.[307] 并行全垃圾回收器 G1 :G1 是设计来作为一种低延时的垃圾回收器（但是如果它跟不上旧的堆碎片产生的提升速率的话，将仍然采用完整压缩集合）。 在 JDK9 之前，默认的收集器是并行，吞吐，收集器。为了减少在使用默认的收集器的应用性能配置文件的差异，G1 现在有一个并行完整收集机制。 7.[313]移除 Native-Header 自动生成工具：Java9 开始了一些对 JDK 的家务管理，这项特性是对它的延续。当编译 JNI 代码时，已不再需要单独的工具来生成头文件，因为这可以通过 javac 完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还不清楚。 8.[304]垃圾回收器接口:这不是让开发者用来控制垃圾回收的接口；而是一个在 JVM 源代码中的允许另外的垃圾回收器快速方便的集成的接口。 9.[312]线程-局部变量管控：这是在 JVM 内部相当低级别的更改，现在将允许在不运行全局虚拟机安全点的情况下实现线程回调。这将使得停止单个线程变得可能和便宜，而不是只能启用或停止所有线程。 10.[316]在备用存储装置上的堆分配：硬件技术在持续进化，现在可以使用与传统 DRAM 具有相同接口和类似性能特点的非易失性 RAM 。这项 JEP 将使得 JVM 能够使用适用于不同类型的存储机制的堆。 11.[317]试验性的基于 Java 的 JIT 编译器：最近宣布的 Metropolis 项目，提议用 Java 重写大部分 JVM 。乍一想，觉得很奇怪。如果 JVM 是用 Java 编写的，那么是否需要一个 JVM 来运行 JVM ？ 相应的，这导致了一个很好的镜像类比。 现实情况是，使用 Java 编写 JVM 并不意味着必须将其编译为字节码，你可以使用 AOT 编译，然后在运行时编译代码以提高性能。 这项 JEP 将 Graal 编译器研究项目引入到 JDK 中,并给将 Metropolis 项目成为现实，使 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。 12.[296]合并 JDK 多个代码仓库到一个单独的储存库中：在 JDK9 中，有 8 个仓库： root、corba、hotspot、jaxp、jaxws、jdk、langtools 和 nashorn 。 在 JDK10 中这些将被合并为一个，使得跨相互依赖的变更集的存储库运行 atomic commit （原子提交）成为可能。 新 API有 73 项新增内容添加到了标准类库中。 1.java.awt.Toolkit int getMenuShortcutKeyMaskEx(): 确定哪个扩展修饰符键是菜单快捷键的适当加速键。 2.java.awt.geom.Path2D: void trimToSize(): 将此 Path2D 实例的容量计算到它当前的大小。应用可使用此操作将路径的存储空间最小化。这个方法也被添加到 Path2D.Double 和 Path2D.Float 类。 3.java.io.ByteArrayOutputStream: String toString(Charset): 重载 toString()，通过使用指定的字符集解码字节，将缓冲区的内容转换为字符串。 4.java.io.PrintStream: &amp;&amp; lang.io.PrintWriter: 这两个类都有三个新的构造函数，它们需要额外的 Charset 参数。 5.java.io.Reader: &amp;&amp; long transferTo(Writer): 从这个 Reader 中读取所有字符，并按照所读的顺序将字符写入给定的 Writer 。 6.java.lang.Runtime.Version: 有四种新方法返回新（JEP 322）版本字符串字段的整数值: feature()、interim()、patch() 和 update() 。 7.java.lang.StackWalker.StackFrame: String getDescriptor(): 按照 JVM 标准返回此堆栈帧所代表的方法的描述符。 String getMethodType():返回此堆栈帧所代表的方法类型，描述参数类型和返回值类型。 8.java.lang.invoke.MethodType: Class&lt;?&gt; lastParameterType():返回这个方法类型的最后一个参数类型。如果这个方法类型没有参数，则返回空类型作为岗哨值（Sentinel Value）。 9.java.lang.management.RuntimeMXBean: long getPid(): R 返回正在运行的 JVM 的进程 ID 。 10.java.lang.management.ThreadMXBean: ThreadInfo[] dumpAllThreads(boolean, boolean, int): 返回所有活动线程的线程信息，其中有指定的最大元素数量和同步信息的堆栈跟踪。 ThreadInfo[] getThreadInfo(long[], boolean, boolean, int): 返回每个线程的线程信息，这些线程的标识位于输入数组中，其中有指定的最大元素数量和同步信息的堆栈跟踪。 11.java.lang.reflect.MalformedParameterizedTypeException: 添加了一个新的构造函数，它以字符串的形式作为参数来获取详细信息。 12.java.net.URLDecoder: java.net.URLEncoder: 这两个类都有新的重载的解码和编码方法，将 charset 作为附加参数。 13.java.nio.channels.Channels: 两个新的静态重载方法，允许使用 Charset 的 newReader（ReadByteChannel，Charset）和newWriter（WriteByteChannel，Charset）。 14.java.nio.file.FileStore: long getBlockSize(): 在这个文件存储中返回每个块的字节数。 15.java.time.chrono: 这个包里有三个类，HijrahEra、MiinguoEra 和 ThaiBuddhistEra ，都有同样的方法。 String getDisplayName(TextStyle, Locale): 这将返回用于识别 era 的文本名称，适合于向用户展示。 16.java.time.format.DateTimeFormatter: localizedBy(Locale): 返回指定格式器的一个副本，其中包含地区、日历、区域、小数和/或时区的本地化值，这将取代该格式器中的值。 17.java.util: DoubleSummaryStatistics、IntSummaryStatistics 和 LongSummaryStatistics 都有一个新的构造函数，它包含 4 个数值。 它使用指定的计数、最小值、最大值和总和构造一个非空实例。 18.java.util.List: &amp;&amp; java.util.Map: &amp;&amp; java.util.Set: 这些接口中的每一个都增加了一个新的静态方法，copyOf(Collection）。这些函数按照其迭代顺序返回一个不可修改的列表、映射或包含给定集合的元素的集合。 19.java.util.Optional: &amp;&amp; java.util.OptionalDouble: &amp;&amp; java.util.OptionalInt: &amp;&amp; java.util.OptionalLong: 每一个类都有一个新的方法，orElseThrow() ，它本质上和 get() 一样，也就是说，如果 Optional 有值则返回。否则，将抛出 NoSuchElementException 。 20.java.util.Formatter: &amp;&amp; java.util.Scanner: 这两个类都有三个新的构造函数，除了其他参数之外，它们都带有一个 charset 参数。 21.java.util.Properties: 这有一个新的构造函数，它接受一个 int 参数。这将创建一个没有默认值的空属性列表，并且指定初始大小以容纳指定的元素数量，而无需动态调整大小。 还有一个新的重载的 replace 方法，接受三个 Object 参数并返回一个布尔值。只有在当前映射到指定值时，才会替换指定键的条目。 22.java.SplittableRandom: void nextBytes(byte[]): 用生成的伪随机字节填充一个用户提供的字节数组。 23.java.util.concurrent.FutureTask: 添加了 toString() 方法，该方法返回一个标识 FutureTask 的字符串，以及它的完成状态。 在括号中，状态包含如下字符串中的一个，“Completed Normally” 、“Completed Exceptionally”、 “Cancelled” 或者 “Not completed”。 24.java.util.concurrent.locks.StampedLock: boolean isLockStamp(long): 返回一个标记戳表示是否持有一个锁。 boolean isOptimisticReadStamp(long): 返回一个标记戳代表是否成功的进行了乐观读（optimistic read）。 boolean isReadLockStamp(long): 返回一个标记戳表示是否持有一个非独占锁（即 read lock ）。 boolean isWriteLockStamp(long): 返回一个标记戳表示是否持有一个独占锁（即 write lock ）。 25.java.jar.JarEntry: String getRealName(): 返回这个 JarEntry 的真实名称。如果这个 JarEntry 是一个多版本 jar 文件的入口，它被配置为这样处理，这个方法返回的名字是 JarEntry 所代表的版本条目的入口，而不是 ZipEntry.getName（） 返回的基本条目的路径名。 如果 JarEntry 不代表一个多版本 jar 文件的版本化条目或者 jar 文件没有被配置为作为一个多版本 jar 文件进行处理，这个方法将返回与 ZipEntry.getName（） 返回的相同名称。 26.java.util.jar.JarFile: Stream versionedStream(): 返回 jar 文件中指定版本的入口对应 Stream 。与 JarEntry 的 getRealName 方法类似，这与多版本 jar 文件有关。 27.java.util.spi.LocaleNameProvider: getDisplayUnicodeExtensionKey(String, Locale): 为给定的 Unicode 扩展键返回一个本地化名称。 getDisplayUnicodeExtensionType(String, String, Locale): 为给定的 Unicode 扩展键返回一个本地化名称。 28.java.util.stream.Collectors: toUnmodifiableList(): toUnmodifiableSet(): toUnmodifiableMap(Function, Function): toUnmodifiableMap(Function, Function, BinaryOperator): 这四个新方法都返回 Collectors ，将输入元素聚集到适当的不可修改的集合中。 29.java.lang.model.SourceVersion: 现在有了一个字段，它代表了 JDK 10 的版本。 30.java.lang.model.util.TypeKindVisitor6: javax.lang.model.util.TypeKindVisitor9: R visitNoTypeAsModule(NoType, P): 访问一个 MODULE 的 pseudo-type 。不确定为什么只有这两个类得到这个方法，因为还有 Visitor7 和 Visitor8 变量。 31.javax.remote.management.rmi.RMIConnectorServer: 这个类已经添加了两个字段： CREDENTIALS_FILTER_PATTERN 和 SERIAL_FILTER_PATTERN 。 32.javax.ButtonModel： Swing 还在更新！ ButtonGroup getGroup(): 返回按钮所属的组。通常用于单选按钮，它们在组中是互斥的。 33.javax.plaf.basic.BasicMenuUI: Dimension getMinimumSize(JComponent): 返回指定组件适合观感的最小大小。 JVM 规范改动这些改动相当小： 4.6节： 类文件格式（第99页）。在方法访问标志方面有小的改动。 4.7节： 模块属性（第169页）。如果模块不是 java.base ，则 JDK 10 不再允许设置 ACC_TRANSITIVE 或 ACC_STATIC_PHASE 。 4.10节： 类文件的校验（第252页）。dup2 指令已改变了 typesafe form 1 的定义，颠倒了 canSafleyPushList 一节中类型的顺序（你需要仔细查看才能发现它）。 5.2节： Java 虚拟机启动（第350页）。该描述添加了在创建初始类或接口时可使用用户定义的类加载器（ bootstrap 类加载器除外）。 对 Java 语言规范的更改这里还有一些更改，但主要是为了支持局部变量类型推断。 第3.8节： 标识符（第23页）。在忽略了可忽略的字符之后，标识符的等价性现在被考虑了。这似乎是合乎逻辑的。 （第24页）一个新的 Token，TypeIdentifier，它支持对局部变量类型推断的新用法，而 var 的使用不是关键字，而是一个具有特殊含义的标识符，作为局部变量声明的类型。 第4.10.5节： 类型预测（第76页）。这是一个相当复杂的部分，它涉及到捕获变量、嵌套类以及如何使用局部变量类型推断。建议阅读规范中的这一部分，而不是试图解释它。 第6.1节： 声明（第134页）。一个反映使用 TypeIdentifier 来支持局部变量类型的推断的小改动。 第6.5节： 确定名字的含义（第153页，第158页和第159页）。根据类型标识符的使用而更改类类型。 第6.5.4.1: 简单的 PackageOrTypeNames（第160页） 第6.5.4.2节： 合规的 PackageOrTypeNames（第160页）。这两种方式都与使用 TypeIdentifier 有细微的变化。 第7.5.3: 单静态导入声明（第191页）。这改变了导入具有相同名称的静态类型的规则。除非类型是相同的，否则这将成为一个错误，在这种情况下，重复被忽略。 第7.7.1: 依赖（第198页）。如果你明确声明一个模块需要 java.base ，那在必要的关键字之后，你就不能再使用修饰符（例如静态）了。 第8部分： 正式参数（第244页）。接收者参数可能只出现在一个实例方法的 formalparameters 列表，或者是一个内部类的构造函数中，其中内部类没有在静态上下文中声明。 第9.7.4节： 注释可能出现的地方（第335页）。有一个与局部变量类型推断相关的变更。 第14.4部分： 局部变量声明语句（第433页）。实现局部变量类型推断所需的大量更改。 第14节： 增强的 for 语句（第455页）。这个结构已经更新，包括对局部变量类型推断的支持。 第14.20.3节: try-with-resources（474页）。这个结构已经更新，包括对局部变量类型推断的支持。 最后，第 19 章有多处语法更新，反映了应更多使用 TypeIdentifier 类型标识符，而不仅仅是 Identifier 标识符，以支持局部变量类型推断。 杂项如果 Kerberos 的配置文件 krb5.conf 包含一个 INCLUDEDIR 选项，那么在 INCLUDEDIR 这个目录下所有以 .conf 结尾的文件都会被默认加载进来。 以前版本中已经过期的 Java 的启动选项 -d32 和 –d64 在当前版本已经被移除。如果在新的版本里仍然使用了这两个选项，JVM 将无法正常启动。 JDK10 支持 JDK9 中的新版本 Doclet，JDK6、JDK7、JDK8 中的 Doclet 版本都不再支持。 JDK10 重新启用了在 JDK9 中被不当过时的 newFactory() 方法。 JDK10 引入了一个新的 Javadoc 标签： {@summary…}，解决了以前版本无法生成 API 摘要的问题。 JDK10 去掉了 BiasedLockingStartupDelay 的 4 秒启动延时。 以下在 com.sun.security.auth 包中的过时的类在新版本中都已经被移除： PolicyFile SolarisNumericGroupPrincipal SolarisNumericUserPrincipal X500Principal SolarisLoginModule SolarisSystem 在 java.lang.SecurityManager 类中的以下属性和方法（从 JDK 1.2 就已经过时）终于被移除了： inCheck (属性) getInCheck classDepth classLoaderDepth currentClassLoader currentLoadedClass inClass inClassLoader 以下 java.lang.Runtime 类中已经被废弃的国际化方法在新版本被移除： getLocalizedInputStream getLocalizedOutputStream 以下废弃的 Hotspot –X 选项在新版本中被移除：-Xoss, -Xsqnopause, -Xoptimize, -Xboundthreads and –Xusealtsigs.policytool 在新版本中被移除。 javadoc 工具在新版本中可以通过 –add-stylesheets 命令选项支持多个 stylesheets 。 新版本的 JVM 能够根据系统分配给当前 Docker 容器的 CPU 数和内存来配置线程池和 GC 机制，而不再是直接使用系统的 CPU 和内存。并且增加了三个更强大的命令选项：-XX:InitialRAMPercentage、-XX:MaxRAMPercentage 和 -XX:MinRAMPercentage 。 新版本增加了一个新的系统属性：jdk.disableLastUsageTracking。 这个新增的属性就像它的名字一样，会禁用 JRE 的上一次使用跟踪。 如上所述，尽管距离 JDK 9 发布仅有六个月的时间，但 JDK 10 实际上有相当多的变化。 当然，它们中的一些是非常小的变更，但这表明目前每 6 个月发布一次的节奏，将在 Java 平台快速迭代改进方面起到作用。 也许以后的以后，每当Java新版本发布： 我们都会感慨一句：我X，JavaX又发布了！！！]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Java10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你修改苹果设备定位]]></title>
    <url>%2Fposts%2F2018-03-20-changeAppleLocation%2F</url>
    <content type="text"><![CDATA[安卓修改定位比较简单，工具一大堆，这里提供一种修改苹果设备定位的方法！ 1.下载工具首先下载工具—-&gt;爱思助手 现在爱思助手已经更新到7.x版本了，安装并打开。 打开后，通过数据线连接好手机,连接成功后就会显示这个窗口。 2.修改步骤点击左上方的“设备信息”。打开后可以看到有一个“备份/恢复”，点击全备份设备。 然后选择“立即备份”，就可以把手机上面的数据备份到电脑上了，这里时间可能会有点长。 当显示备份完成后,点击上面的“备份恢复”界面，然后找到刚刚使用的“全备份文件管理”，然后直接打开查看。 打开后，可以看到“AppDomain-com.apple.Maps”的文件夹，点击打开。 然后接着打开Library/Preferences，并往下拉找到com.apple.Maps.plist文件，继续打开。 会看到有两行代码&lt;/dict&gt;和&lt;/plist&gt;，然后把下面的代码写在这两行上面： &lt;key&gt;__internal__PlaceCardLocationSimulation&lt;/key&gt;&lt;true/&gt; 完成后点击保存。 添加完成后，找到刚刚界面的全“全恢复数据”然后点击立即恢复。 重启一下手机。 打开手机地图，会发现下面多了一个选项Simulate Location。 点击这个，所有的软件位置定位都是这个虚拟位置。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>定位</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序猿视角"手撕"微信多开]]></title>
    <url>%2Fposts%2F2018-03-14-multi-wechat%2F</url>
    <content type="text"><![CDATA[白色情人节，快！ 乐！ 微信多开，不想使用其他多开软件，胆小，怕封号！ 从程序猿的视角，实现微信多开，对，徒手撕！ 1.简介软件代码是如何实现同一个软件只能打开一次的？ “死锁”操作系统上有两类锁，一类是进程内可见的，一类是跨进程可见的。 软件程序想要单实例运行，是使用了第二类锁， 声明一个跨进程可见的锁（互斥量Mutex）。 当你第二次打开同一个软件，启动时检测跨进程可见的锁是否存在，如果存在就退出，如果不存在就正常启动。 2.具体实现(1)下载微软的增强版资源管理器 下载地址：https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer (2)下载后用管理员身份运行，找到微信的进程 WeChat (3)按下Ctrl+L,显示详细信息，找到如下的两把锁。 WeChat_GlobalConfig_Multi_Process_Mutex _WeChat_App_Instance_Identity_Mutex_Name 然后右键， Close Handle， 结束掉这两把锁。 (4)OK,可以打开第二个微信了。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
        <tag>微信</tag>
        <tag>微信多开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的 Docker 镜像]]></title>
    <url>%2Fposts%2F2018-02-08-docker-images%2F</url>
    <content type="text"><![CDATA[收集一些有趣的Docker镜像！！！ Docker 一键安装脚本 wget -qO- get.docker.com | sh 常用基础镜像Centos/Debian/Ubuntu CentOS：kinogmt/centos-ssh （默认用户名root，密码password，CentOS6.7） Debian：itscaro/debian-ssh（默认用户名root，密码root，Debian Jessie） Ubuntu：rastasheep/ubuntu-sshd（默认用户名root，密码root） 镜像1：rastasheep/ubuntu-sshd （带ssh的ubuntu）地址：https://hub.docker.com/r/rastasheep/ubuntu-sshd/ sudo docker run -d -p 22:22 rastasheep/ubuntu-sshd:16.04 用户名、密码为root 镜像2：itscaro/debian-ssh （带ssh的ubuntu）地址：https://hub.docker.com/r/itscaro/debian-ssh/ sudo docker run -d -p 22:22 itscaro/debian-ssh 用户名、密码为root 镜像3：tutum/centos （带ssh的centos）地址：https://hub.docker.com/r/tutum/centos/ sudo docker run -d -p 22:22 tutum/centos（centos7：tutum/centos:centos7 ） 用户名root，密码随机，请执行 docker logs 查看 镜像4：alexwhen/docker-2048（游戏2048）地址：https://hub.docker.com/r/alexwhen/docker-2048/ sudo docker run -d -p 80:80 alexwhen/docker-2048 镜像5：dorowu/ubuntu-desktop-lxde-vnc（noVNC、Firefox51）地址：https://hub.docker.com/r/dorowu/ubuntu-desktop-lxde-vnc/ docker run -it -p 80:80 dorowu/ubuntu-desktop-lxde-vnc Browse http://ip/ 镜像6：consol/centos-xfce-vnc （VNC、noVNC、密码、chrome、Firefox45）地址：https://hub.docker.com/r/consol/ubuntu-xfce-vnc/ run -it -p 5901:5901 -p 6901:6901 -e “VNC_PW=my-new-password” -e VNC_RESOLUTION=800x600 consol/centos-xfce-vnc 默认VNC密码：vncpassword VNC-Server (default VNC port 5901) noVNC - HTML5 VNC client (default http port 6901) 其他相关 onsol/centos-xfce-vnc: Centos7 with Xfce4 UI session consol/ubuntu-xfce-vnc: Ubuntu with Xfce4 UI session consol/centos-icewm-vnc: dev Centos7 with IceWM UI session consol/ubuntu-icewm-vnc: dev Ubuntu with IceWM UI session 镜像7：fish/peerflix-server （支持磁力，种子）地址：https://hub.docker.com/r/dorowu/ubuntu-desktop-lxde-vnc/ docker run -it -p 9000:9000 fish/peerflix-server Browse http://ip:9000/ 镜像8：jpillora/cloud-torrent（种子下载，搜索）地址：https://hub.docker.com/r/jpillora/cloud-torrent/ docker run -d -p 3000:3000 -v /path/to/my/downloads:/downloads jpillora/cloud-torrent Browse http://ip:3000/ 镜像9：jim3ma/google-mirror（google镜像，如需ssl要手动添加）地址：https://hub.docker.com/r/jim3ma/google-mirror/ docker run -d -p 80:80 jim3ma/google-mirror Browse http://ip/ 镜像10：google-reverse-proxy（google镜像，有ssl）地址：https://hub.docker.com/r/jokester/google-reverse-proxy/ docker run -d –publish 54321:20081 –restart=always jokester/google-reverse-proxy Browse http://ip:54321/ 镜像11：forsaken-mail（临时邮箱）地址：https://hub.docker.com/r/rockmaity/forsaken-mail/ docker run –name forsaken-mail -itd -p 25:25 -p 3000:3000 rockmaity/forsaken-mail Browse http://ip:3000/ 镜像12：imdjh/owncloud-with-ocdownloader支持 owncloud, torrent, aria2, youtube-dl 地址：https://hub.docker.com/r/imdjh/owncloud-with-ocdownloader/ docker run -d -p 80:80 -e OWNCLOUD_VERSION=9.1.4 -v /var/www/html/data:/var/www/html/data imdjh/owncloud-with-ocdownloader Browse http://ip/ 镜像13：v2ray/official（v2ray）地址：https://hub.docker.com/r/v2ray/official/ docker run -d -p 8001:8001 v2ray/official 镜像14：timonier/aria2地址：https://hub.docker.com/r/timonier/aria2/ docker run -i -t -v /data:/data –net host timonier/aria2 –dir=/data –enable-rpc –rpc-listen-all=true 配合使用：timonier/webui-aria2（aria2web管理） 地址：https://hub.docker.com/r/timonier/webui-aria2/ docker run -i -t -p 80:80 timonier/webui-aria2]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Docker</tag>
        <tag>Docker镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 搭建 Docker 环境]]></title>
    <url>%2Fposts%2F2018-02-08-centos-docker%2F</url>
    <content type="text"><![CDATA[Docker, Docker, Docker !!! 有人说Docker是未来，也有人说Docker已死，不管怎样，该学还得学，该搬的砖一块都不会少。 2013年Docker刚发布那会，懵懂不甚理解，通过2015年慢慢的接触，才了解了点皮毛，还记得2016年arukas.io提供的Docker服务，玩的不亦乐乎。 关于介绍还是请各位Google去，这里系统地整理下Docker入门，在CentOS下搭建Docker环境。 安装与配置Docker1.安装Docker Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 docker，只需要运行下面的 yum 命令： yum install docker-io -y 直接yum安装，安装成功后查看版本 docker -v 启动docker service docker start 设置开机启动 chkconfig docker on 2.配置 Docker 因为国内访问 Docker Hub 较慢, 可以使用腾讯云提供的国内镜像源, 加速访问 Docker Hub,依次执行以下命令: echo "OPTIONS='--registry-mirror=https://mirror.ccs.tencentyun.com'" >> /etc/sysconfig/docker systemctl daemon-reload service docker restart Docker的简单操作1.下载镜像 下载一个官方的 CentOS 镜像到本地 docker pull centos 下载好的镜像就会出现在镜像列表里 docker images 2.运行容器 这时我们可以在刚才下载的 CentOS 镜像生成的容器内操作了。生成一个 centos 镜像为模板的容器并使用 bash shell docker run -it centos /bin/bash 这个时候可以看到命令行的前端已经变成了 [root@(一串 hash Id)] 的形式, 这说明我们已经成功进入了 CentOS 容器。 在容器内执行任意命令, 不会影响到宿主机, 如下: mkdir -p /data/simple_docker 可以看到 /data 目录下已经创建成功了 simple_docker 文件夹 ls /data 退出容器 exit 查看宿主机的 /data 目录, 并没有 simple_docker 文件夹, 说明容器内的操作不会影响到宿主机 ls /data 3.保存容器 查看所有的容器信息， 能获取容器的id docker ps -a 然后执行如下命令，保存镜像： docker commit -m=”备注” 你的CONTAINER_ID 你的IMAGE 部署完成大功告成！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Ubuntu搭建FTP文件服务器]]></title>
    <url>%2Fposts%2F2018-02-07-ubuntu-ftp%2F</url>
    <content type="text"><![CDATA[经常需要搭建FTP，各种配置起来很繁琐，今天整理下，方便以后使用！ 安装并启动FTP服务(1) 安装VSFTPD 使用 apt-get 安装 vsftpd： sudo apt-get install vsftpd -y (2) 启动 VSFTPD 安装完成后 VSFTPD 会自动启动，通过 netstat 命令可以看到系统已经 监听了 21 端口： sudo netstat -nltp | grep 21 如果没有启动，可以手动开启 VSFTPD 服务： sudo systemctl start vsftpd.service 配置用户访问目录(1)新建用户主目录 sudo mkdir /home/uftp 执行完后，在 /home/uftp 就能看到新建的文件夹 uftp 了。 创建登录欢迎文件: sudo touch /home/uftp/welcome.txt (2)新建用户 uftp 并设置密码 创建一个用户 uftp: sudo useradd -d /home/uftp -s /bin/bash uftp 为用户 uftp 设置密码: sudo passwd uftp 删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败： sudo rm /etc/pam.d/vsftpd (3)限制该用户仅能通过 FTP 访问 限制用户 uftp 只能通过 FTP 访问服务器，而不能直接登录服务器： sudo usermod -s /sbin/nologin uftp (4)修改 vsftpd 配置 sudo chmod a+w /etc/vsftpd.conf 修改 /etc/vsftpd.conf 文件中的配置（直接将如下配置添加到配置文件最下方）： # 限制用户对主目录以外目录访问 chroot_local_user=YES # 指定一个 userlist 存放允许访问 ftp 的用户列表 userlist_deny=NO userlist_enable=YES # 记录允许访问 ftp 用户列表 userlist_file=/etc/vsftpd.user_list # 不配置可能导致莫名的530问题 seccomp_sandbox=NO # 允许文件上传 write_enable=YES # 使用utf8编码 utf8_filesystem=YES 新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户： sudo touch /etc/vsftpd.user_list sudo chmod a+w /etc/vsftpd.user_list 修改 /etc/vsftpd.user_list ，加入刚刚创建的用户： uftp (5)设置访问权限 设置主目录访问权限（只读）： sudo chmod a-w /home/uftp 新建公共目录，并设置权限（读写）：[可选] sudo mkdir /home/uftp/public &amp;&amp; sudo chmod 777 -R /home/uftp/public 重启vsftpd 服务： sudo systemctl restart vsftpd.service 访问 FTP 服务FTP 服务已安装并配置完成，下面我们来使用该 FTP 服务。根据您个人的工作环境，选择一种方式来访问已经搭建的 FTP 服务。 (1)通过 FTP 客户端工具访问 FTP 客户端工具众多，下面推荐两个常用的： ① FileZilla - 跨平台的 FTP 客户端，支持 Windows 和 Mac ② WinSCP - Windows 下的 FTP 和 SFTP 连接客户端 下载和安装 FTP 客户端后，使用服务器的登录信息(服务器IP和ftp的用户名以及密码)进行连接即可，例如： 主机：100.100.100.100 用户名以及密码： uftp/uftp 输入密码后，如果能够正常连接，那么大功告成，您可以开始使用属于您自己的 FTP 服务器了！ 接下来，请上传任意一张图片到 FTP 服务器上的 uftp 的 public 目录下，然后，就可以在 /home/uftp/public 中看到了。 (2)通过 Windows 资源管理器访问 Windows 用户可以复制下面的链接到资源管理器的地址栏访问： ftp://uftp:uftp@100.100.100.100]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 SVN 服务器]]></title>
    <url>%2Fposts%2F2018-02-06-linux-svn%2F</url>
    <content type="text"><![CDATA[虽然当今江湖上Git当道，但是SVN也是需要搭建的，今天整理下，方便以后使用！ 安装SVN服务端Subversion 是一个版本控制系统，相对于的 RCS 、 CVS ，采用了分支管理系统，它的设计目标就是取代 CVS 。 yum install -y subversion 创建SVN版本库创建项目版本库 mkdir -p /data/svn/myproject svnadmin create /data/svn/myproject 配置SVN信息1.配置文件简介 版本库中的配置目录 conf 有三个文件: authz 是权限控制文件 passwd 是帐号密码文件 svnserve.conf 是SVN服务综合配置文件 2.配置权限配置文件 authz 编辑 authz ，内容参考如下： [groups] #用户组 admin = admin,root,test #用户组所对应的用户 [/] #库目录权限 @admin = rw #用户组权限 *=r #非用户组权限 3.配置账号密码文件 passwd 编辑 passwd ，内容参考如下： [users] # harry = harryssecret # sally = sallyssecret admin = 123456 root = 123456 test = 123456 4.配置 SVN 服务综合配置文件 svnserve.conf 编辑 svnserve.conf ，内容参考如下： [general] # force-username-case = none # 匿名访问的权限 可以是read、write，none，默认为read anon-access = none #使授权用户有写权限 auth-access = write #密码数据库的路径 password-db = passwd #访问控制文件 authz-db = authz #认证命名空间，SVN会在认证提示里显示，并且作为凭证缓存的关键字 realm = /data/svn/myproject [sasl] 启动SVN服务1.启动SVN svnserve -d -r /data/svn 2.checkout SVN 项目 mkdir -p /data/workspace/myproject svn co svn://127.0.0.1/myproject /data/workspace/myproject --username root --password 123456 --force --no-auth-cache 3.提交文件到SVN服务器 从本地提交文件到 SVN 服务器，其中 root 密码为 /data/svn/myproject/conf/passwd 文件存储的密码 cd /data/workspace/myproject echo test >> test.txt svn add test.txt svn commit test.txt -m 'test' 提交成功后可以通过如下命令从本地项目删除文件: cd /data/workspace/myproject rm -rf test.txt 删除后可以通过 SVN 服务器恢复: cd /data/workspace/myproject svn update 部署完成大功告成！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 搭建 Git 服务器]]></title>
    <url>%2Fposts%2F2018-02-05-centos-git%2F</url>
    <content type="text"><![CDATA[当今江湖上Git当道，整理下，方便以后使用！ Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 这里以 CentOS 7.2 x64 的系统为环境，搭建 Git 服务器。 下载安装Git1.安装依赖库和编译工具 为了后续安装能正常进行，我们先来安装一些相关依赖库和编译工具 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel 安装编译工具: yum install gcc perl-ExtUtils-MakeMaker 2.下载 Git 选一个目录，用来放下载下来的安装包，这里将安装包放在 /usr/local/src 目录里 cd /usr/local/src 到官网找一个新版稳定的源码包下载到 /usr/local/src 文件夹里 wget https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz 解压和编译: 解压下载的源码包 tar -zvxf git-2.10.0.tar.gz 解压后进入 git-2.10.0 文件夹 cd git-2.10.0 执行编译 make all prefix=/usr/local/git 编译完成后, 安装到 /usr/local/git 目录下 make install prefix=/usr/local/git 配置环境变量将 git 目录加入 PATH 将原来的 PATH 指向目录修改为现在的目录: echo ‘export PATH=$PATH:/usr/local/git/bin’ &gt;&gt; /etc/bashrc 生效环境变量； source /etc/bashrc 此时我们能查看 git 版本号，说明我们已经安装成功了； git –version 创建Git账号密码创建 git 账号 为我们刚刚搭建好的 git 创建一个账号 useradd -m gituser 然后为这个账号设置密码: passwd gituser 初始化Git仓库并配置用户权限1.创建 git 仓库并初始化 我们创建 /data/repositories 目录用于存放 git 仓库 mkdir -p /data/repositories 创建好后，初始化这个仓库 cd /data/repositories/ &amp;&amp; git init –bare test.git 2.配置用户权限 给 git 仓库目录设置用户和用户组并设置权限 chown -R gituser:gituser /data/repositories chmod 755 /data/repositories 查找 git-shell 所在目录, 编辑 /etc/passwd 文件，将最后一行关于 gituser 的登录 shell 配置改为 git-shell 的目录如下: gituser:x:500:500::/home/gituser:/usr/local/git/bin/git-shell 3.使用搭建好的 Git 服务 克隆 test repo 到本地: cd ~ &amp;&amp; git clone &#x67;&#x69;&#x74;&#117;&#115;&#x65;&#x72;&#64;&#49;&#x32;&#51;&#x2e;&#50;&#x30;&#x37;&#x2e;&#52;&#53;&#x2e;&#49;&#x32;&#51;:/data/repositories/test.git 部署完成大功告成！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度莱茨狗免费领取]]></title>
    <url>%2Fposts%2F2018-02-03-baidupet%2F</url>
    <content type="text"><![CDATA[区块链今年是异常的火爆~ 百度推出了区块链数字狗，目前可以免费领取！！虽然不知道这个玩意有啥用，也不知道能玩出什么花，先领取了再说。 官网地址https://pet-chain.baidu.com/ 领取地址第一只：https://pet-chain.baidu.com/chain/splash 第二只：https://pet-chain.baidu.com/chain/splash?appId=2&amp;tpl=wallet 第三只：https://pet-chain.baidu.com/chain/splash?appId=3&amp;tpl=wallet 第四只：https://pet-chain.baidu.com/chain/splash?appId=4&amp;tpl=wallet 我是谁?汪汪汪~ 我是区块链赋能的莱茨狗。 我的小伙伴们，每只都有独一无二的基因。 一旦你拥有了我，我们的关系将被永远记录在区块链上，任何人都不能改变。 我有8个外貌特征，每个特征有两种不同的属性：稀有属性和普通属性。这些属性组合起来，将会决定我最终的稀有等级（普通、稀有、卓越、史诗、神话、传说）。 你要怎么玩儿？你可以在市场中，通过数字积分—微积分，购买你心仪的莱茨狗。 你也能在个人中心，查看并出售你所拥有的莱茨狗。 开发团队百度金融区块链实验室，拥有完整的企业级区块链解决方案，以及面向用户的应用级区块链解决方案。该实验室深入底层技术、平台化、区块链应用以及前瞻性领域研究，目前的技术已应用于多条核心业务线，支撑了超500亿元资产的真实性问题。同时，该实验室也是Hyperledger的核心董事会成员，致力于提升区块链行业的技术发展，推动全球区块链技术规范和标准的建立。 特别提示:01.点击免费领取后，系统将通过区块链，把属于你的狗狗和微积分发放到你的账户中。当领取人数较多时，写入区块链时间可能较长，请耐心等待。 02.当你提交购买订单后，由于订单需要写入区块链，将要一段交易确认时间。待交易确认后，才能在“我的狗窝”看到你所购买的莱茨狗。 03.当你在购买莱茨狗时，需扣除5微积分左右的手续费，用于支付写入区块链所需算力资源的消耗。因此，你的微积分余额必须大于【狗狗出售价格与手续费之和】，才能成功发起购买。实际收取的费用将由具体消耗的算力决定，待交易成功后，可在我的订单中查看。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链初代狗</tag>
        <tag>区块链</tag>
        <tag>初代狗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JetBrains 系列注册码]]></title>
    <url>%2Fposts%2F2018-01-30-jetbrains-mynum%2F</url>
    <content type="text"><![CDATA[由于经常使用JetBrains系列的软件，总是各种找激活信息，很是麻烦，索性自己剁手上车。 2018年01月30日今天又买了一枚激活码，还是一年的有效期，到2019年01月29日。 关注微信公众号《听风吟且行》，回复“jetbrains”即可。 2017年07月30日最近买了个正版IntelliJ 系列注册码（心好痛），可以激活IntelliJ 系列所有产品。 一年有效期，目前到2018年08月25日。 在此分享给大家，拿好，不谢。 1D42KHYC787-eyJsaWNlbnNlSWQiOiJENDJLSFlDNzg3IiwibGljZW5zZWVOYW1lIjoiaXl1IHB1YiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJGb3IgZWR1Y2F0aW9uYWwgdXNlIG9ubHkiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTgtMDgtMjUifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTgtMDgtMjUifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTgtMDgtMjUifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMTgtMDgtMjUifSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9XSwiaGFzaCI6IjY1NDE0MzEvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-c/SJ1KIswpxXLzreXc8ou/XgLUVy3rvhsu9OqB7491QfoTfF8HeO4fxH4MSsB2MwxNhbgcsfCxDGR23u5Gc+RGuCTPlnsahWCsnVYpcFUxjML8MS0FN/5inrDrZXZLE+nUeW+fwgnwM2Y0ttBy/vDcvJKYasqV8YBFAkPIG+HuegiIFz1gYqF99xIofDzeL4pziUi/K5JyWHP/JCgTqQlzDnpNfqILJDyYJNqGkZwJBAWuytkcbvh85lmRPhePKl9gQr+Rh2k9jF8+bUCZh2OrZVey2KK5Kg2pi52QENhcVqJwWVzF0CTwqzpJStCw3g6OLiXUKDX+CJhH8/TfipPg==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>注册码</tag>
        <tag>IntelliJ</tag>
        <tag>IDEA</tag>
        <tag>PyCharm</tag>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code常用技巧]]></title>
    <url>%2Fposts%2F2018-01-22-vscode%2F</url>
    <content type="text"><![CDATA[2018年01月22日更新： 1.去掉vscode右侧的预览窗口 文件&gt;&gt;首选项&gt;&gt;设置 属性editor.minimap.enabled 改为false 2.代码格式化： Shift+Alt+F 或 Ctrl+Shift+P后输入format code]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>VSCode</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[放学别走，等你下课]]></title>
    <url>%2Fposts%2F2018-01-18-dengnixiake%2F</url>
    <content type="text"><![CDATA[欣赏歌曲，全词不押韵！这，其实已经是到了一个新的境界！ 众所周知，无论诗词，韵脚都是极为重要，决定了是否让人朗朗上口！而，周董眼中：押韵是什么？我自己来，随便来！偏偏，效果极好！ 专辑名称随意啦，歌词随意啦，MV随意啦（卡通图，敢不敢再随意一点），内容好，那就够了！ 音乐在线播放： http://music.163.com/song?id=531051217&amp;userid=91899213 下载： 下载地址 MV在线播放：http://music.163.com/mv/?id=5819032&amp;userid=91899213 下载（超清版）：下载地址 歌词作曲 : 周杰伦作词 : 周杰伦 **Jay**： 你住的 巷子里 我租了一间公寓 为了想与你不期而遇 高中三年 我为什么 为什么不好好读书 没考上跟你一样的大学 我找了份工作 离你宿舍很近 当我开始学会做蛋饼 才发现你 不吃早餐 喔 你又擦肩而过 你耳机听什么 能不能告诉我 **合**： 躺在你学校的操场看星空 教室里的灯还亮着你没走 记得 我写给你的情书 都什么年代了 到现在我还在写着 总有一天总有一年会发现 有人默默的陪在你的身边 也许 我不该在你的世界 当你收到情书 也代表我已经走远 **Gary**： 学校旁 的广场 我在这等钟声响 等你下课一起走好吗 **Jay**： 弹着琴 唱你爱的歌 暗恋一点都不痛苦 （Gary：一点都不痛苦） **Jay**： 痛苦的是你 **合**： 根本没看我 **Jay**： 我唱这么走心 却走不进你心里 （Gary：这么走心 进你心里） **Jay**： 在人来人往 **合**： 找寻着你 守护着你 不求结局 **Gary**： 喔 你又擦肩而过 （Jay：喔 而过） **Jay**： 我唱告白气球 终于你回了头 **合**： 躺在你学校的操场看星空 教室里的灯还亮着你没走 记得 我写给你的情书 都什么年代了 到现在我还在写着 总有一天总有一年会发现 有人默默的陪在你的身边 也许 我不该在你的世界 当你收到情书 也代表我已经走远]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>周杰伦</tag>
        <tag>等你下课</tag>
        <tag>单曲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你一定要安装的反挖矿插件]]></title>
    <url>%2Fposts%2F2018-01-17-nocoin%2F</url>
    <content type="text"><![CDATA[为什么我们需要安装反挖矿扩展程序？ 主要此类扩展程序会自动检测网站是否加载挖矿脚本，如果检测到那么直接封锁脚本并禁止脚本加载。禁止后不会影响访问者继续浏览网页或者是使用其中的功能（少部分网站禁止加载挖矿脚本后会设置访问阻挡）。 另外挖矿脚本可以按照网站所有者的意愿进行自定义配置，如果设置的哈希计算强度比较低的话那么CPU负载并不会很高、风扇转速亦不会迅速提高，所以通常情况下我们亦不会发觉已经被挖矿。 当然如果是笔记本电脑的话拦截挖矿脚本还可以节省我们的电量，同时如果使用按流量计费的网络也可以帮助我们节省流量开支（挖矿消耗的流量实际上比较低）。 最重要的是现在越来越多的网站开始使用挖矿脚本，显然如果我们经常访问网页的话那么对于设备性能和电量来说都是个损失。 目前仅发现360极速浏览器和opera浏览器自带防挖矿功能（傲游很逗比的出了个挖矿版） 其他浏览器可下载对应的防挖矿扩展 另外，IE浏览器不支持挖矿脚本…… 相关浏览器插件下载Chrome插件： https://chrome.google.com/webstore/detail/no-coin/gojamcfopckidlocpkbelmpjcgmbgjcl FireFox插件1： https://addons.mozilla.org/zh-CN/firefox/addon/no-coin/?src=search FireFox插件2： https://addons.mozilla.org/zh-CN/firefox/addon/coinblock/?src=search TingBrowser开发事项： 在下个版本的TingChrome和TingFirefox中会集成反挖矿插件。 最近由于事情有点多，没有时间开发其他的浏览器版本。。。 TingBrowser官网： http://browser.iyu.pub]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>IT</tag>
        <tag>反挖矿</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mqtt专题（一）之MQTT协议]]></title>
    <url>%2Fposts%2F2017-12-27-mqtt_subject1%2F</url>
    <content type="text"><![CDATA[MQTT系列专题文章一之MQTT协议 一、基本概念MQTT(Message Queuing Telemetry Transport,消息队列遥测传输)是IBM开发的一个即时通信协议，是物联网的重要组成部分，该协议几乎支持所有的平台。最近工作中正在使用这个，这个博客写的简单是自学的笔记，不喜勿喷啊。。。 二、MQTT的特点MQTT 协议是为大量计算能力有限，且工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性： 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于 XMPP，但是 MQTT 的信息冗余远小于XMPP（因为 XMPP 使用的是 XML 这种格式来传递数据）。 对负载内容屏蔽的消息传输。 使用 TCP/IP 提供网络连接。主流的 MQTT 是基于 TCP 连接进行数据推送的，但是同样有基于 UDP 的版本，叫做 MQTT-SN 。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 有三种消息发布服务质量（Qos）: 最多一次：消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。 至少一次：确保消息到达，但消息重复可能会发生。这一种方式比较鸡肋，在我的想象中没能想到这种质量的发送在常规的 APP 开发中有什么用处。 只有一次：确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP 的推送，确保用户收到且只会收到一次。 小型传输，数据传输和狭义交换的最小化（协议头部只有2个字节），以降低网络流量。 通知机制，异常中断是通知传输双方。使用 Last Will 和 Testament 特性通知有关各方客户端异常中断的机制。Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。 三、MQTT协议原理 协议实现方式 实现MQTT协议需要:客户端和服务器端 MQTT协议中有三种身份：发布者（Pushlish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT的消息分为：主题（Topic）和负载（payload）两部分 Topic,可以理解为消息的类型，订阅者Subscribe之后，就会收到该主题的消息内容（payload）。 payload，可以理解为消息的内容，是指订阅者具体的使用内容 网络传输和应用消息 MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节的双向传输。当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（Qos）和主题名（Topic）相关联。 MQTT客户端 一个使用MQTT的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以: 发布其他客户端可能会订阅的消息 订阅其他客户端发布的消息 退订或删除应用程序的消息 断开与服务器的连接 MQTT服务器 MQTT服务器可以称为“消息代理（Broker）”,也可以是一个 应用程序或者设备，它位于消息发布者和订阅者之间，它可以： 接受来自客户的网络连接 接受客户发布的应用信息 处理来自客户端的订阅和退订请求 向订阅的客户转发应用程序信息 MQTT协议中的订阅、主题、会话 订阅（Subscription） 订阅包换主题筛选器（Topic Filter）和最大服务质量（Qos）。订阅与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话的每个订阅都有一个不同的主题筛选器。 会话（Session）每个客户与服务器建立连接之后就是一个会话，客户端和服务器之间有状态交互。会话存在一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。 主题名（Topic）连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。 主题筛选器（Topic Filter）一个与主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。 负载（Payload）消息订阅者所具体接收的内容 MQTT协议中的方法 MQTT 协议中定义了一些方法（也被称为动作）， 来于表示对确定资源所进行操作。 这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。 Connect，等待与服务器建立连接 Disconnect，等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话 Subscribe，等待完成订阅 UnSubscribe，等待服务器取消客户端的一个或多个topic订阅 Publish， MQTT 客户端发送消息请求，发送完成后返回应用程序线程 未完待续。。。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐一部科幻小说《三体》（1-3全本）]]></title>
    <url>%2Fposts%2F2017-12-22-santi%2F</url>
    <content type="text"><![CDATA[三体 文化大革命如火如荼地进行，天文学家叶文洁在期间历经劫难，被带到军方绝秘计划“红岸工程”。叶文洁以太阳为天线，向宇宙发出地球文明的第一声啼鸣，取得了探寻外星文明的突破性进展。三颗无规则运行的太阳主导下，四光年外的“三体文明”百余次毁灭与重生，正被逼迫不得不逃离母星，而恰在此时，他们接收到了地球发来的信息。对人性绝望的叶文洁向三体人暴露了地球的坐标，彻底改变了人类的命运。 地球的基础科学出现了异常的扰动，纳米科学家汪淼进入神秘的网络游戏《三体》，开始逐步逼近这个世界的真相。汪淼参加一次玩家聚会时，接触到了地球上应对三体人到来而形成的一个秘密组织（ETO）。地球防卫组织中国区作战中心通过“古筝计划”，一定程度上挫败了拯救派和降临派扰乱人类科学界和其他领域思想的图谋，获悉处于困境之中的三体人为了得到一个能够稳定生存的世界决定入侵地球。 在运用超技术锁死地球人的基础科学之后，庞大的三体舰队开始向地球进发，人类的末日悄然来临。 三体Ⅱ·黑暗森林 三体人在利用科技锁死了地球人的科学之后，出动庞大的宇宙舰队直扑太阳系，面对地球文明前所未有的危局，人类组建起同样庞大的太空舰队，同时（PDC）利用三体人思维透明的致命缺陷，制订了“面壁计划”。出乎意料地，社会学教授罗辑被选出作为四位“面壁者”之一，展开对三体人的秘密反击。虽然三体人自身无法识破人类的计谋，却依靠由地球人中的背叛者挑选出的“破壁人”与“面壁者”进行智慧博弈。 在这场你死我活的文明生存竞争中，罗辑由一开始的逃避和享乐主义逐渐意识到自己的责任心，想到了一个对抗三体文明入侵的办法。科研军官章北海试图借一场陨石雨干涉飞船推进形式的研究方向。近二百年后，获选增援未来的他在人类舰队被“水滴”清除殆尽前，成功抢夺战舰逃离。此时罗辑证实了宇宙文明间的黑暗森林法则，任何暴露自己位置的文明都将很快被消灭。 借助于这一发现，他以向全宇宙公布三体世界的位置坐标相威胁，暂时制止了三体对太阳系的入侵，使地球与三体建立起脆弱的战略平衡。 三体Ⅲ·死神永生 身患绝症的云天明买下一颗星星送给暗恋着的大学同学程心，而程心因参与（PIA）向三体舰队发射探测器的工作，却想让航天专业背景的他放弃安乐死，作为被执行人将大脑捐献给阶梯计划。与三体文明的战争使人类首次看到了宇宙黑暗的真相，地球文明因为黑暗森林打击的存在如临大敌，不敢在太空中暴露自己。在零道德的宇宙中发起黑暗战役的战舰被诱导返航，却受到有道德的地球文明审判。 不称职的懦弱少女程心被选来充当掌握地球命运的执剑人，她因为罗辑的成功将这看作一项只需花费时间的任务，刚刚任职水滴就向地球发动攻击，程心为了忠于人性做出了错误的决定。在警示下继续逃离的“蓝色空间”号，受到具有发射引力波能力的“万有引力”号与两个同行的“水滴”追击，其上的人员进入四维空间摧毁水滴并占领了“万有引力”号，启动引力波广播向宇宙公布了三体星系的坐标。 云天明与地球取得联系，通过讲述三个自己编创的童话故事，向程心透露大量情报；人类自以为悟出了生存竞争的秘密，开始进行掩体计划，维德领导的空间曲率驱动研究因为程心的错误判断被终止，使得人类最终没有能够逃脱被高级文明毁灭的命运。因为宇宙中还存在更强大的文明，战争的方式和武器已经远超出人类的想象，极高文明发出了一张卡片大小的“二向箔”，使整个太阳系压缩为二维平面而毁灭。 在地球人类接近灭亡之际，只有程心和艾AA两个幸存者乘坐光速飞船离开。罗辑成为设置于冥王星的地球文明博物馆的“守墓人”，她们在冥王星带走人类文明的精华。在云天明送的恒星的一颗行星上，程心遇到关一帆且探讨了宇宙降维的真相，然而超乎一切之上的力量要求宇宙归零重生，在黑域中穿越长达1800万年的时空……程心没有等到云天明到来，和关一帆在小宇宙中短暂居住后重新进入大宇宙生活。 三体全本下载:点我下载]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>三体</tag>
        <tag>科幻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownPad2.5 注册码分享]]></title>
    <url>%2Fposts%2F2017-12-20-markdownpad-num%2F</url>
    <content type="text"><![CDATA[最近在使用Markdown书写，找到一款Markdown的编辑工具，分享一枚注册码。 邮箱： Soar360@live.com 授权秘钥： 1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==]]></content>
      <categories>
        <category>福利</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>注册码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django开发的微信公众号上线]]></title>
    <url>%2Fposts%2F2017-07-05-django-wechat%2F</url>
    <content type="text"><![CDATA[近期在学习Python的Django框架，写了几个小项目之后，就想着用在公众号（听风吟且行）上试试。 经过一周的开发，终于上线了。现在大概支持3个功能： 1.快递查询：输入“快递公司名字+快递单号”，比如输入“圆通11111111111” 2.天气查询：输入“城市名+天气”，比如输入“深圳天气” 3.自动回复：自动语义回复的功能，随时随地陪您聊天。大概实现了如下的一些功能： （1）笑话大全：“讲个笑话” （2）故事大全：“讲个故事” （3）成语接龙：“成语接龙一心一意” （4）新闻资讯：“今日新闻” （5）姓名测试：“林俊杰这个名字好不好” （6）星座运势：“射手座的运势” （7）生活百科：“树莓派的简介” （8）图片搜索：“计算机的图片” （9）天气查询：“深圳天气” （10）菜谱大全：“糖醋排骨怎么做” （11）聊天对话：“你好” （12）列车查询：“今天深圳到合肥的火车” （13）航班查询：“今天深圳到上海的飞机” （14）数字计算：“3的立方是多少” （15）中英互译：“苹果的单词是什么” （16）问答百科：“天为什么是蓝的” （17）绕口令：“说个绕口令” （18）城市邮编：“深圳的邮编” 目前大概实现了这些功能，当然可能有些Bug，只是为了练手的，不喜勿喷。 有兴趣的童鞋可以关注（听风吟且行），体验一下，尽情的撩吧！ 体验之后，如果有什么好的建议，请回复我，我会逐渐完善的，谢谢！ 最后放上微信公众号的二维码：]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>WeChat</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tool工具页面正式上线！！！]]></title>
    <url>%2Fposts%2F2017-06-15-tool-django%2F</url>
    <content type="text"><![CDATA[2017年06月15日Tool后台写了一个星期，框架大概搭建起来。。。 接下来就是码代码。 先放上几个小工具，后面慢慢增加（针对需求的优先级） 界面目前还没怎么优化，先将就着看吧，先把功能完善。。。哈哈^_^ 项目环境： 整套项目使用Django框架，使用Python3开发。 项目还在持续设计中，如有好的建议，留言告诉我，我会加入你所期待的功能。 https://tool.hunit.cn]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单Python抓取网页下载地址]]></title>
    <url>%2Fposts%2F2017-01-19-getlinkbypython%2F</url>
    <content type="text"><![CDATA[下午，一哥们说要下载美剧《福尔摩斯：基本演绎法》，网页上几十个迅雷下载链接，嫌麻烦不愿一个一个点，我就建议了如下方法： 写个程序去抓取网页上有用的迅雷下载链接，再把全部链接复制到迅雷，就OK。 这里我用Python简单写了个。。。不喜勿喷。。。 抓取的网页：http://www.qtfy.cc/mjxz/13553.html # -*- coding: utf8 -*- import urllib.request as request from bs4 import BeautifulSoup def geturl(href): html = request.urlopen(href).read().decode('utf-8') html_Soup = BeautifulSoup(html, 'lxml') a = html_Soup.find_all('a') for link in a: if link.get('href') is not None: if "thunder" in link.get('href') : print(link.get('href')) if "ed2k" in link.get('href') : print(link.get('href')) if __name__ == '__main__': geturl("http://www.qtfy.cc/mjxz/13553.html") 简单易懂，达到想要的效果就行。 针对其他的电影网站下载链接，稍微改下即可。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[情怀再起--Opera发布概念网页浏览器Opera Neon]]></title>
    <url>%2Fposts%2F2017-01-13-operaneon%2F</url>
    <content type="text"><![CDATA[Opera 今天展示了首款概念网页浏览器,代号为 Opera Neon。Opera Neon 采用与标准版 Opera 浏览器相同的渲染引擎,但 Neon 的重点是突出显示网页内容。Opera Neon 包含全新用户界面,包括使用用户桌面壁纸的起始页面,包含视频播放器、图库和下载管理器的侧栏,以及视觉标签页条,让用户可以更轻松的在标签页之间切换。 &nbsp; 此外,Opera Neon 还内置了“智能系统”,可以管理标签页,将经常访问的标签页整理至顶部,将不经常访问的页面转移至底部。Opera Neon 还支持弹出式视频播放窗口,方便用户浏览其他网页时继续观看视频。其他功能包括,网页截图功能,分屏模式等。 Opera Neon官网：http://www.opera.com/zh-cn/computer/neon Feast your eyes Engage your senses Free your mind Visual tabs and gravity Snap-to-gallery Split screen mode Video pop-out and player&nbsp; 首个版本的Opera Neon目前已经推出了以下内容： 浏览器的起始页面将会和电脑使用相同的背景，也就是浏览器起始页类似透明； 首个版本已经内置媒体播放器、图片库以及下载管理器，其位于浏览器左侧边栏； 在浏览器右侧的视觉化分页栏可以让用户更方便的辨识相关的标签页内容； 自动化管理标签页的智能系统，会将常用的标签页漂浮到上方、其他则沉到下方； 对于还有视频的网页可以将播放的视频弹出（这个似乎不少浏览器都有了）； 可以直接截取屏幕截图到图片库，用户可以在任何地方截图存储并方便上传； 双屏模式：可以让两个页面同时展示、开启和使用等等；Opera Neon属于概念浏览器且代表了Opera对未来浏览器的愿景，其不会取代现有的Opera浏览器，但其中的某些新功能也会被慢慢增添至Opera浏览器中。 目前该浏览器已支持Windows和Mac平台，有兴趣的用户可以下载测试版： 在线安装包： Opera Neon （国内下载较慢） 离线安装包： Opera Neon]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>浏览器</tag>
        <tag>Opera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS获取系统信息的Shell脚本]]></title>
    <url>%2Fposts%2F2017-01-11-getsysteminfobyshell%2F</url>
    <content type="text"><![CDATA[由于要监测服务器的运行状态，练手写了个简单的shell脚本。 大概实现了如下两个简单系统信息的展示： 功能一：获取操作系统的基本信息（内核、系统版本、网络地址等） 功能二：获取系统的运行状态（CPU负载、内存以及磁盘的使用率等） &nbsp; ########################################################################## #File Name:systemmonitor.sh #Author:Yuolvv #Blog:http://blog.iyu.pub ########################################################################## #!/bin/bash #把屏幕上的内容清空 clear if [[ $# -eq 0 ]] then echo -e '\E[33m'"#########################系统分析#########################" #定义一个高亮输出的变量 output=$(tput sgr0) #检查系统类型，使用uname -o命令 os=$(uname -o) echo -e '\E[32m'"系统类型:"$output $os #获取操作系统版本类型 #os_name=$(cat /etc/issue | grep -e "Server") #os_name=$(lsb_release -a | grep -e "Description") os_name=$(cat /etc/redhat-release) echo -e '\E[33m'"系统版本:"$output $os_name #获取CPU的指令集 os_bit=$(uname -m) echo -e '\E[34m'"系统位数:"$output $os_bit #获取内核版本 os_kernel=$(uname -r) echo -e '\E[35m'"内核版本:"$output $os_kernel #获取主机名￥hostname或者uname -n hostname=$(hostname) #获取内网IP inner=$(hostname -I) echo -e '\E[36m'"内网IP:"$output $inner #获取外网IP outer=$(curl -s http://ipecho.net/plain) echo -e '\E[29m'"外网IP:"$output $outer #获取DNS，从/etc/resolv.conf文件提取匹配 nameservers=$(cat /etc/resolv.conf | grep -E "\&lt;nameserver[ ]"+|awk '{print $NF}') echo -e '\E[31m'"系统DNS:"$output $nameservers #判断当前网络的连通性，直接使用ping命令测试 ping -c 2 www.ifeng.com &amp;&gt;/dev/null &amp;&amp; echo "网络连通:yes"||echo "网络连通:no" #检查当前登录的用户，使用who命令输出到一个临时文件中 who &gt;/tmp/who echo -e '\E[32m'"当前登录用户:"$output &amp;&amp; cat /tmp/who #命令输出后删除临时文件 rm -rf /tmp/who echo -e '\E[33m'"##########################################################" echo -e '\E[33m'"#########################运行状态#########################" #获取系统已经使用的内存，通过awk命令文本进行提取，然后计算出结果转换成MB system_men=$(awk '/MemTotal/{total=$2}/MemFree/{free=$2}END{print (total-free)/1024}' /proc/meminfo) echo -e '\E[36m'"系统使用内存:"$output $system_men"M" #获取应用使用内存，通过awk命令文本进行提取，然后计算出结果换算成MB app_men=$(awk '/MemTotal/{total=$2}/MemFree/{free=$2}/Cached/{cached=$2}/Buffers/{buffers=$2}END{print (total-free-cached-buffers)/1024}' /proc/meminfo) echo -e '\E[36m'"应用程序使用内存:"$output $app_men"M" #获取系统CPU负载 load_average=$(top -n 1 -b | grep "load average:" | awk '{print $12 $13 $14}') echo -e '\E[33m'"CPU负载:"$output $load_average #获取磁盘状况 disk=$(df -hP | grep -vE 'Filesystem|tmpfs'|awk '{print $1 "总量:"$2 "已使用:"$3 "使用率:"$5}') echo -e '\E[33m'"磁盘状况:"$output $disk echo -e '\E[33m'"##########################################################" else echo "shell脚本不能运行请联系我Email:1@iyu.pub" fi 代码浅显易懂，也加上了注释，这里就不逐行解释了。 代码的运行方法： 1.新建个sh文件systemmonitor.sh,把上面的代码复制进去。 或者使用wget命令： wget http://www.iyu.pub/fun/systemmonitor.sh 2.给文件执行的权限： chmod +x systemmonitor.sh 3.运行脚本： sh systemmonitor.sh 或者 ./systemmonitor.sh &nbsp; 好了，简单的分享就到这了。 &nbsp; &nbsp;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有道云笔记 去除左下角广告]]></title>
    <url>%2Fposts%2F2017-01-10-delyoudaoad%2F</url>
    <content type="text"><![CDATA[找到有道云笔记的安装路径，xxx\Youdao\YoudaoNote\theme\build.xml 用notepad++打开这个文件，根据type=”adpanel”找到如下代码： PanelAd type=&quot;adpanel&quot; css=&quot;public&quot; ass=&quot;mainform panelclient PanelAd&quot;&gt; &lt;panelTopLine type=&quot;panel&quot; css=&quot;AdPanel&quot; Dockstyle=&quot;top&quot; Bounds=&quot;0,0,0,1&quot;/&gt; &lt;MiddlePhotoPanel type=&quot;panel&quot; css=&quot;public&quot; DockStyle=&quot;top&quot; Bounds=&quot;0,0,250,160&quot; Margin=&quot;0,13,0,13&quot;&gt; &lt;AdPhoto type=&quot;photo&quot; css=&quot;Ad AdPhoto&quot; AnchorStyle=&quot;center&quot; AutoZoom=&quot;ZoomEqual&quot; Bounds=&quot;0,0,200,130&quot;&gt; &lt;AdClose type=&quot;button&quot; css=&quot;adclear&quot; AnchorStyle=&quot;topright&quot; Bounds=&quot;-1,1,24,24&quot; /&gt; &lt;AdText type=&quot;label&quot; css=&quot;AdText&quot; AnchorStyle=&quot;bottomleft&quot; Bounds=&quot;6,-6,25,10&quot;/&gt; &lt;/AdPhoto&gt; &lt;/MiddlePhotoPanel&gt; &lt;/PanelAd&gt; 修改上面的这段代码： （1）修改第2行： &lt;panelTopLine type=&quot;panel&quot; css=&quot;AdPanel&quot; Dockstyle=&quot;top&quot; Bounds=&quot;0,0,0,1&quot;/&gt; 改为： &lt;panelTopLine type=&quot;panel&quot; css=&quot;AdPanel&quot; Dockstyle=&quot;top&quot; Bounds=&quot;0,0,0,0&quot;/&gt; （2）修改第4行： &lt;AdPhoto type=&quot;photo&quot; css=&quot;Ad AdPhoto&quot; AnchorStyle=&quot;center&quot; AutoZoom=&quot;ZoomEqual&quot; Bounds=&quot;0,0,200,130&quot;&gt; 改为： &lt;AdPhoto type=&quot;photo&quot; css=&quot;Ad AdPhoto&quot; AnchorStyle=&quot;center&quot; AutoZoom=&quot;ZoomEqual&quot; Bounds=&quot;0,0,0,0&quot;&gt; 保存之后重启有道云笔记，就可以了。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>去广告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017元旦香港维多利亚港烟火表演]]></title>
    <url>%2Fposts%2F2017-01-01-newyear%2F</url>
    <content type="text"><![CDATA[2017的元旦，香港跨年！ 香港地标维多利亚港以“烟花音乐汇演”喜迎2017！ 烟花、烟火、灯光以及音乐在著名地标的衬托下，于维多利亚港上空交织绽放，共同迎接2017年的到来。 “六星连环”、“蝴蝶飞舞”、“20响礼炮鸣放” Youtube超清：https://www.youtube.com/embed/2QD9InOhd_Q 优酷超清：http://player.youku.com/embed/XMTg5NTMwNjcyNA==]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>香港</tag>
        <tag>烟火</tag>
        <tag>表演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【深圳】TOP 链接公益 • 移动技术年度盛典]]></title>
    <url>%2Fposts%2F2016-12-21-socialprogrammer%2F</url>
    <content type="text"><![CDATA[社会程序员技术改变生活，让信息的流通、人和人的连接、协作变得更加有效率；技术无边界，用技术做些公益的事情，能将温暖传递到更多角落。当技术遇上公益会产生怎样的【催化反应】？ 【T.O.P链接公益·移动技术年度盛典】由个推·云之讯·Ping++联合多家合作伙伴共同举办。 术业有专、成事有先—-T.O.P（Tech &amp; Organization &amp; Partner） 活动邀请到那些勇于探索移动新技术，实践新想法的领路者们，分享他们在产品技术实践上的见解与心得。 希望有更多的人加入“社会程序员”的行列，我们携手让技术赋能公益。 这是我上周末参加的一个活动，感触挺深的，在此分享给大家。 今天收到官方发布的录制视频，特此分享！ &nbsp; &nbsp; &nbsp; &nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>公益</tag>
        <tag>技术</tag>
        <tag>盛典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone6/6s变砖怎么办？]]></title>
    <url>%2Fposts%2F2016-12-16-iphone6-6s-wenti%2F</url>
    <content type="text"><![CDATA[今天作死的想更新下手机固件，结果成砖了。 搜索资料，发现如下两种方法： 第一种： 1将你的iPhone关机 2.同时按住开关机键和home键 3.当你看见白色的苹果logo时，请松开开关机键，并继续保持按住home键。 4.开启iTunes，等待其提示你进行恢复模式后，即可按住键盘上的shift键，点击“恢复”，选择相应的固件进行恢复。 第二种： 1.用USB线将iPhone连接上电脑，然后你将会听见电脑已连接成功的提示声音。 2.现在请先将iPhone关机，然后你将会听见电脑未连接成功的提示声音。 3.请同时按住开关机键和home键，持续到第10秒的时候，请立即松开开关键，并继续保持按住home键。 4.这个时候iTunes会自动启动，并提示你进行恢复模式(iPhone会一直保持黑屏状态)。那么你就可以按住键盘上的shift键，点击“恢复”，选择相应的固件进行恢复。 &nbsp; 作死感悟： No zuo no die 没有金刚钻别揽瓷器活，这句话说的真不错。 我是用第二种方法处理的，第一种不成功。 抹掉了所有数据，然而并没有备份。 滴，车翻了。。。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iPhone6</tag>
        <tag>iPhone6s</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果iOS App从2017年起强制使用HTTPS]]></title>
    <url>%2Fposts%2F2016-12-06-iosnews%2F</url>
    <content type="text"><![CDATA[苹果App于2017年1月1日将启用App Transport Security安全功能，即强制App通过HTTPS连接网络服务。 Apple Store强制使用HTTPS的原因 随着全球互联网安全意识的进一步觉醒，越来越多的公司意识到网络信息安全的重要性，只有绝对的加密才能保证在线交易和商务活动的安全进行。互联网无疑是个人信息和隐私泄露最频繁的场合，各种以窃取信息为方式而展开的网络犯罪是互联网发展所面临的最大挑战。在这样一个大环境下，苹果公司首先做出应对，强制所有App在2017年1月1日前使用HTTPS加密，这就意味着，如果您的APP如果仍采用HTTP传输，那么，在Apple Store中您的APP将不再能被用户下载使用。 App开发商将如何应对这一协议 早在2015年9月的WWDC15上，苹果公司就提出了ATS(App Transport Security)，所谓的ATS是一种新型加密技术-Forward Secrecy，要求应用与后台通讯必须使用最新的TLS1.2版本Https协议，以及所有Apple Store中的App必须使用SHA256算法的SSL/TLS证书。时隔一年多，这一协议还剩不到一个月的时间就要生效，还未安装SSL证书的App开发商们应该如何应对呢？ 以下几点至关重要： （1）必须选择好适用的SSL证书，这是部署HTTPS的第一步 （2）调整后台应用，实现后台应用全站HTTPS （3）选择正规的CA机构申请符合ATS要求的SSL证书]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>新闻</tag>
        <tag>iOS</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锤子手机发布会 相声]]></title>
    <url>%2Fposts%2F2016-10-19-chuizifabuhui%2F</url>
    <content type="text"><![CDATA[老罗单口相声专场10月18日，锤子科技在上海梅赛德斯-奔驰文化中心举行2016年度新品发布会，正式推出代号为SM901和SM919的两款手机新品。当然，发布会的主持人应该还是老罗本人，鉴于老罗幽默风趣的演讲风格，这是一年一度的罗永浩单口相声大会。 昨晚看到23点，心累。 这里贴上视频： &nbsp; 观后感： 亮点还是有几个的，老罗好像慢慢妥协了，情怀不再？]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>锤子</tag>
        <tag>发布会</tag>
        <tag>相声</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ表情昵称代码]]></title>
    <url>%2Fposts%2F2016-10-05-qqbiaoqingcode%2F</url>
    <content type="text"><![CDATA[仅供娱乐！ &nbsp; /wx /微笑 /pz /撇嘴 /se /色 /fd /发呆 /dy /得意 /ll /流泪 /hx /害羞 /bz /闭嘴 /shui /睡 /dk /大哭 /gg /尴尬 /fn /发怒 /tp /调皮 /cy /呲牙 /jy /惊讶 /ng /难过 /kuk /酷 /lengh /冷汗 /zk /抓狂 /tuu /吐 /tx /偷笑 /ka /可爱 /baiy /白眼 /am /傲慢 /jie /饥饿 /kun /困 /jk /惊恐 /lh /流汗 /hanx /憨笑 /db /大兵 /fendou /奋斗 /zhm /咒骂 /yiw(i) /疑问 /xu /嘘... /yun /晕 /zhem /折磨 /shuai /衰 /kl /骷髅 /qiao /敲打 /zj /再见 /ch /擦汗 /kb /抠鼻 /gz /鼓掌 /qd /糗大了 /huaix /坏笑 /zhh /左哼哼 /yhh /右哼哼 /hq /哈欠 /bs /鄙视 /wq /委屈 /kk /快哭了 /yx /阴险 /qq /亲亲 /xia /吓 /kel /可怜 /cd /菜刀 /xig /西瓜 /pj /啤酒 /lq /篮球 /pp /乒乓 /kf /咖啡 /fan /饭 /zt /猪头 /mg /玫瑰 /dx /凋谢 /sa /示爱 /xin /爱心 /xs /心碎 /dg /蛋糕 /shd /闪电 /zhd /炸弹 /dao /刀 /zq /足球 /pch /瓢虫 /bb /便便 /yl /月亮 /ty /太阳 /lw /礼物 /yb /拥抱 /qiang /强 /ruo /弱 /ws /握手 /shl /胜利 /bq /抱拳 /gy /勾引 /qt /拳头 /cj /差劲 /aini /爱你 /bu /不 /hd /好 /aiq /爱情 /fw /飞吻 /tiao /跳跳 /fad /发抖 /oh /怄火 /zhq /转圈 /kt /磕头 /ht /回头 /tsh /跳绳 /hsh /挥手 /jd /激动 /jw /街舞 /xw /献吻 /zuotj /左太极 /youtj /右太极]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QQ</tag>
        <tag>表情包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TingFirefox正式发布]]></title>
    <url>%2Fposts%2F2016-09-23-tingfirefox%2F</url>
    <content type="text"><![CDATA[一个月之前，TingChrome发布的时候就计划紧接着发布TingFirefox版本，但是一直拖着拖着，就这样拖了一个月。码农天生对Firefox情有独钟，怎能少得了？ Slogan： 你想要的一切，TingFirefox都会给你！TingFirefox 是基于 Firefox 制作的免费浏览器。 加强Firefox的标签页浏览功能 优化Firefox的启动速度 &nbsp; &nbsp; &nbsp; 责任声明本站仅仅提供一个观摩学习的环境，将不对本站提及的任何资源负法律责任。 如果您下载使用，表示您已经同意自己承担软件使用带来的一切后果！ &nbsp; 下载链接： http://browser.iyu.pub/ &nbsp; &nbsp;]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>浏览器</tag>
        <tag>Browser</tag>
        <tag>自研软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TingChrome 终于正式发布了]]></title>
    <url>%2Fposts%2F2016-08-29-tingchrome%2F</url>
    <content type="text"><![CDATA[千呼万唤，TingChrome终于发布了！！！ &nbsp; Slogan： 你想要的一切，TingChrome都会给你！&nbsp; TingChrome 是基于 Google Chrome 制作的免费浏览器。 集成过滤 视频广告、网页广告 等扩展 采用特殊的缓存技术加速网站的打开 &nbsp; &nbsp; 责任声明本站仅仅提供一个观摩学习的环境，将不对本站提及的任何资源负法律责任。 如果您下载使用，表示您已经同意自己承担软件使用带来的一切后果！ &nbsp; &nbsp; 下载链接： https://browser.iyu.pub/]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>浏览器</tag>
        <tag>Browser</tag>
        <tag>自研软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国FAST即将睁天眼：世界最大单口径望远镜]]></title>
    <url>%2Fposts%2F2016-07-25-fastelescope%2F</url>
    <content type="text"><![CDATA[&nbsp; 由中国研制和建设的世界最大单口径望远镜――500米口径球面射电望远镜(Five hundred meters Aperture Spherical Telescope，简称FAST)将于今年9月投入使用。该望远镜将被用于探索太空，可追寻地外生命尤其“外星人”(学名“地外智慧生命”)。 &nbsp; 这个被誉为“中国天眼”的FAST与号称“地面最大机器”的德国波恩100米射电望远镜相比，其灵敏度将提高约10倍;与被评为“人类20世纪10大工程”之首的美国阿雷西博305米射电望远镜相比，其综合性能提高约10倍。专家们认为它在今后二三十年时间内仍能保持世界一流地位。FAST可遥望百亿光年星际;这意味着，远在百亿光年外的射电信号，它也有可能“捕捉”到。 基于FAST的强大功能，如果银河系(直径约为15万光年)内存在外星人，他们的信息就很可能被发现。国际科研项目“搜寻外星人计划”(SETI)的首席科学家丹・沃西默最近向中方提出，希望在FAST加装设备，可合作搜索外星人信号。 寻找外星人是否对人类有威胁，对此问题学术界一直都有争论;半个世纪来，“外星人威胁论”比较流行。例如：1974年，阿雷西博射电望远镜向距离地球25000光年的球状星团M13发送无线电信号;诺贝尔物理奖得主、英国天文学家马丁・赖尔得知此事后，就给联合国写信极力反对人类主动与外星人建立联系;在他看来这些信息很可能会暴露地球人的存在，有可能招来杀身之祸。又如：英国进化生物学家西蒙・莫里斯2011年在《皇家学会哲学汇刊(A辑)》撰文指出：外星人的进化过程可能与达尔文理论本质上是一样的，这就意味着外星人可能很像我们人类;毫不掩盖地说，他们甚至可能也拥有暴力倾向。 有“当代宇宙大王”之称的英国物理学家史蒂芬・霍金2012年在接受英国广播公司(BBC)记者采访时更是语出惊人：“宇宙中存在外星人，地球人试图与他们交流是非常危险的;如果外星人决定来拜访我们，那么结果可能和当年欧洲人到达美洲一样，美洲原住民并没有得到什么好处;外星人如果威胁地球人，其主要目的是掠夺地球上的资源。”不知道什么原因，霍金去年却与俄罗斯风险投资家尤里・米尔纳共同领导着一个名为“突破聆听”(The Breakthrough Listen)的寻找外星人项目。有趣的是，最近美国脸书创始人马克・扎克伯格也加入了这项寻找外星人的伟大事业中。 然而，一些科学家并不同意“外星人威胁论”。他们从外星人的智慧与科技，甚至是人类自身对外星人的心理作用来说明外星人对地球人并不构成威胁。中国科学家及未来学家周海中就是这一观点的拥护者。他1999年在《科学美国人(中文版)》撰文指出：担心外星人威胁是完全没有必要的，因为只要是高级智慧生命，他们的理智在决定着他们必须有分寸地对待其他智慧生命体;外星人与地球人将来是能够和平共处、友好合作和共同发展的。 无独有偶，美国天文学家大卫・莫里森2011年在接受英国《新科学家》记者采访时也表示：如果一颗距离地球数百或者数千光年的行星发出的无线电信号被我们接收到，这个文明的先进程度一定超过人类;如果一个文明能够存在数十万年，它一定能解决我们面临的一系列问题，所以没有必要掠夺地球上的资源。他风趣地说：“如果外星人来访，我会好好款待他们。” 毫无疑问，FAST投入使用后，研究人员将得以继续探寻地外生命尤其外星人。如果能找到外星人，那将是人类历史上最伟大的发现;届时，我们可邀请远方的外星人朋友来相会，共商发展大计，共谋合作愿景。 &nbsp; &nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Fast</tag>
        <tag>望远镜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑苹果常见问题]]></title>
    <url>%2Fposts%2F2016-03-22-blackapple-wenti%2F</url>
    <content type="text"><![CDATA[由于经常系统升级，反复出现一些问题，特地整理下并记录下来。 1.修改显存从512MB到1GB的按顺序执行以下4行代码： cd /S*/L*/Ext*/AppleIntelSNBGraphicsFB.kext/C*/M* sudo cp AppleIntelSNBGraphicsFB AppleIntelSNBGraphicsFB.backup sudo perl -pi -e 's|\xC7\x45\xBC\x00\x00\x00\x20|\xc7\x45\xBC\x00\x00\x00\x40|g' AppleIntelSNBGraphicsFB sudo touch /S*/L*/Extensions 2.修复开机正常亮度和VGA HDMI： sudo perl -pi -e 's|\x01\x02\x04\x00\x10\x07\x00\x00\x10\x07\x00\x00\x05\x03\x00\x00\x02\x00\x00\x00\x30\x00\x00\x00\x02\x05\x00\x00\x00\x04\x00\x00\x07\x00\x00\x00\x03\x04\x00\x00\x00\x04\x00\x00\x09\x00\x00\x00\x04\x06\x00\x00\x00\x04\x00\x00\x09\x00\x00\x00|\x01\x02\x03\x00\x12\x13\x00\x00\x12\x13\x00\x00\x05\x03\x00\x00\x02\x00\x00\x00\x30\x00\x00\x00\x02\x05\x00\x00\x00\x08\x00\x00\x06\x00\x00\x00\x06\x02\x00\x00\x01\x00\x00\x00\x09\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00|g' /System/Library/Extensions/AppleIntelSNBGraphicsFB.kext/Contents/MacOS/AppleIntelSNBGraphicsFB 修复权限重建缓存（很重要，防止不能进系统了，可以用Kext Utility修复），然后删除系统盘Extra/Extensions中的驱动（一定要删除，防止冲突），再重启（提前重启你就进不去了）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Apple</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress整站迁移]]></title>
    <url>%2Fposts%2F2015-12-21-wordpressqianyi%2F</url>
    <content type="text"><![CDATA[**wordpress整站迁移步骤：** 1、备份数据库。用数据库备份工具备份老站的mysql数据库(.sql) 2、备份wordpress网站程序。 3、新建mysql数据库，利用数据库备份工具，导入原来网站的.sql的数据库备份文件。 4、将第2步中，原来的网站程序上传到新网站下。 5、删除网站根目录下的wp数据库配置文件wp-config.php，然后在浏览器中输入网站域名访问，安装wordpress。 至此，网站完美迁移成功。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
        <tag>网站搬家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取音乐mp3外链的方法]]></title>
    <url>%2Fposts%2F2015-12-09-getmp3link%2F</url>
    <content type="text"><![CDATA[记得以前经常在鹅厂的空间添加背景音乐，一开始用的是百度音乐外链，后来封了。 今天在写页面的时候，寻找音乐外链。 因为是网易云音乐的脑残粉，就试着抓下网易云音乐的外链。 外链接口： http://music.163.com/api/song/detail/?id=歌曲ID&amp;ids=%5B歌曲ID%5D&amp;csrf_token= （只要把上面链接中的“歌曲ID”换成歌曲的链接中的ID就行） &nbsp; For example： 朴树的“且听风吟”：http://music.163.com/#/song?id=139359 将”id=139359”中的“139359”替换到上面的外链中 即： http://music.163.com/api/song/detail/?id=139359&amp;ids=%5B139359%5D&amp;csrf_token= 在浏览器上打开，可以得到一个json &nbsp; 到这里，你应该会发现 mp3的外链吧。不错，就是”mp3Url“后面的，即： "mp3Url":"http://m2.music.126.net/Z3kPN3AAQFUd3WbiZtQgKQ==/7943971512260105.mp3" &nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>mp3</tag>
        <tag>音乐</tag>
        <tag>外链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat配置WebService]]></title>
    <url>%2Fposts%2F2015-12-02-tomcat-webservice%2F</url>
    <content type="text"><![CDATA[1.下载jax-ws依赖包 http://jax-ws.java.net 2.将jaxws-RI\lib下的包复制到tomcat\shared\lib下 3.编辑conf\catalina.properties 找到common.loader配置项，增加${catalina.home}/shared/lib/*.jar,${catalina.home}/shared/lib 路径]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12306抢票软件大搜罗]]></title>
    <url>%2Fposts%2F2015-12-01-12306soft%2F</url>
    <content type="text"><![CDATA[搜罗了如下的抢票软件： （1）12306.net 软件分享：http://yunpan.cn/c3ScEk7YEw6cG 访问密码 e59b （2）12306Bypass分流抢票软件 软件分享：http://yunpan.cn/c3Sc2btNE4wZz 访问密码 bc76 （3）猎豹抢票大师 软件分享：http://yunpan.cn/c3Vq8prQGZeTj 访问密码 81e0 （4）百度抢票专版 软件分享：http://yunpan.cn/c3VqtqdvR69QU 访问密码 4da7 （5）QQ抢票专版 软件分享：http://yunpan.cn/c3VqXFe5diUsB 访问密码 1081 （6）搜狗抢票专版 软件分享：http://yunpan.cn/c3VPSeJdxRmKx 访问密码 9e3b 若使用搜狗抢票专版，可以使用搜狗预约抢票，挺不错的功能！ 网址：http://mse.sogou.com/yuepiao]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>12306</tag>
        <tag>抢票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String和ByteBuffer互转]]></title>
    <url>%2Fposts%2F2015-11-05-string-bytebuffer%2F</url>
    <content type="text"><![CDATA[String 转换 ByteBuffer： //String 转换 ByteBuffer public static ByteBuffer getByteBuffer(String str) { return ByteBuffer.wrap(str.getBytes()); } ByteBuffer 转换 String： //ByteBuffer 转换 String public static String getString(ByteBuffer buffer) { Charset charset = null; CharsetDecoder decoder = null; CharBuffer charBuffer = null; try { charset = Charset.forName("UTF-8"); decoder = charset.newDecoder(); //用这个的话，只能输出来一次结果，第二次显示为空 // charBuffer = decoder.decode(buffer); charBuffer = decoder.decode(buffer.asReadOnlyBuffer()); return charBuffer.toString(); } catch (Exception ex) { ex.printStackTrace(); return "error"; } }]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 自动备份mysql并加入定时任务]]></title>
    <url>%2Fposts%2F2015-10-27-shell-mysql-backup%2F</url>
    <content type="text"><![CDATA[1.使用mysqldump备份MySQL数据库 新建一个shell文件 touch backup.sh 编辑shell文件 vi backup.sh 输入下列内容： #!/bin/bash mysqldump --opt -uuser -ppassword | gzip &gt; /mysqlbackup/mysql`date +%Y-%m-%d_%H%M%S`.sql.gz #删除超过7天的备份数据，保留3个月里的 10号 20号 30号的备份数据 find /mysqlbackup/ -name "*[1-9].sql.gz" -type f -mtime +7 -exec rm -rf {} \; &gt; /dev/null 2&gt;&amp;1 #删除超过3个月的所有备份数据 find /mysqlbackup/ -name "*.sql.gz" -type f -mtime +92 -exec rm -rf {} \; &gt; /dev/null 2&gt;&amp;1 2.修改文件属性，使其可执行 chmod +x /mysqlbackup/backup.sh 3.加入定时任务 编辑/etc/crontab vi /etc/crontab 添加如下代码： # m h dom mon dow user command 30 01 * * 0 root /mysqlbackup/backup.sh 这样表示每个周日的上午1点30分执行shell文件 4.重新启动crond使设置生效 service cron stop #停止 service cron start #启动 /etc/init.d/cron restart #重启]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>CentOS</tag>
        <tag>Fedora</tag>
        <tag>shell</tag>
        <tag>脚本</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inno Setup 5.5版本中文语言包]]></title>
    <url>%2Fposts%2F2015-10-19-inno-setup-zh%2F</url>
    <content type="text"><![CDATA[; *** Inno Setup version 5.5.0+ Chinese messages *** ; ; To download user-contributed translations of this file, go to: ; http://www.jrsoftware.org/is3rdparty.php ; ; Note: When translating this text, do not add periods (.) to the end of ; messages that didn't have them already, because on those messages Inno ; Setup adds the periods automatically (appending a period would result in ; two periods being displayed). [LangOptions] ; The following three entries are very important. Be sure to read and ; understand the '[LangOptions] section' topic in the help file. LanguageName=Chinese LanguageID=$0409 LanguageCodePage=0 ; If the language you are translating to requires special font faces or ; sizes, uncomment any of the following entries and change them accordingly. ;DialogFontName= ;DialogFontSize=8 ;WelcomeFontName=Verdana ;WelcomeFontSize=12 ;TitleFontName=Arial ;TitleFontSize=29 ;CopyrightFontName=Arial ;CopyrightFontSize=8 [Messages] ; *** Application titles SetupAppTitle=安装 SetupWindowTitle=安装 - %1 UninstallAppTitle=反安装 UninstallAppFullTitle=%1 反安装 ; *** Misc. common InformationTitle=安装信息 ConfirmTitle=提示 ErrorTitle=错误 ; *** SetupLdr messages SetupLdrStartupMessage=现在将安装 %1。是否继续? LdrCannotCreateTemp=不能创建临时文件。安装中止！ LdrCannotExecTemp=不能在临时目录中解压文件，安装过程中止！ ; *** Startup error messages LastErrorMessage=%1.%n%n 错误 %2: %3 SetupFileMissing=在安装目录中找不到文件 %1 。请更正该问题或者获得一个新的文件。 SetupFileCorrupt=安装文件被占用。请获得一个新的安装文件。 SetupFileCorruptOrWrongVer=安装文件被占用, 或者安装文件的版本不对。请更正该问题或者获得一个新文件。 NotOnThisPlatform=该程序不能在 %1 下运行。 OnlyOnThisPlatform=该程序必须在 %1 下运行。 OnlyOnTheseArchitectures=该程序只能在以下WINDOWS版本下运行:%n%n%1 MissingWOW64APIs=该版本需要64位的安装程序。要更正该问题，请安装 Service Pack %1。 WinVersionTooLowError=该软件需要 %1 版本号 %2 或者更高。 WinVersionTooHighError=该软件不能在 %1 版本号 %2 或者更高版本中安装。 AdminPrivilegesRequired=您在安装该程序时必须是管理员权限。 PowerUserPrivilegesRequired=您在安装程序是必须是管理员权限或者高权限用户权限。 SetupAppRunningError=安装程序检测到 %1 正在运行。%n%n请关闭它的所有实例。然后单击“确认”继续安装，或者单击“取消”退出。UninstallAppRunningError=反安装程序检测到 %1 正在运行。%n%n请关闭它的所有实例。然后单击“确认”继续安装，或者单击“取消”退出。 UninstallAppRunningError=Uninstall has detected that %1 is currently running.%n%nPlease close all instances of it now, then click OK to continue, or Cancel to exit. InvalidParameter=命令行中包含无效的参数:%n%n%1 SetupAlreadyRunning=安装程序已经运行. WindowsVersionNotSupported=该程序不支持当前的Windows版本. WindowsServicePackRequired=该程序要求 %1 Service Pack %2 或者更高版本. ; *** Misc. errors ErrorCreatingDir=安装程序不能创建目录 "%1" ErrorTooManyFilesInDir=不能在目录"%1" 下创建文件。因为该目录下有太多的文件了。 ; *** Setup common messages ExitSetupTitle=退出安装 ExitSetupMessage=安装还未完成。如果现在退出，程序将结束安装。%n%n您可以在下次继续安装。%n%n退出安装？ AboutSetupMenuItem=关于安装程序[&A]... AboutSetupTitle=关于安装程序 AboutSetupMessage=%1 版本 %2%n%3%n%n%1 主页:%n%4 AboutSetupNote= TranslatorNote= ; *** Buttons ButtonBack=< 上一步[&B] ButtonNext=下一步[&N] > ButtonInstall=安装[&I] ButtonOK=确认 ButtonCancel=取消 ButtonYes=市[&Y] ButtonYesToAll=全部确认[&A] ButtonNo=否[&N] ButtonNoToAll=全部否认[&o] ButtonFinish=完成[&F] ButtonBrowse=浏览[&B]... ButtonWizardBrowse=浏览[&r]... ButtonNewFolder=新建文件夹[&M] ; *** "Select Language" dialog messages SelectLanguageTitle=选择安装语言种类 SelectLanguageLabel=选择该语言作为安装语言: ; *** Common wizard text ClickNext=单击“下一步”继续，或者单击“取消”退出本安装程序。 BeveledLabel= BrowseDialogTitle=浏览文件夹 BrowseDialogLabel=在下面的列表中选择一个目录, 然后单击“确认”继续。 NewFolderName=新文件夹 ; *** "Welcome" wizard page WelcomeLabel1=欢迎进入 [name] 安装向导 WelcomeLabel2=将在您的电脑上安装 [name/ver] 。%n%n建议在继续安装之前先退出其它运行的程序。 ; *** "Password" wizard page WizardPassword=密码 PasswordLabel1=本安装程序受密码保护。 PasswordLabel3=请输入密码，密码区分大小写。然后单击“下一步”继续。 PasswordEditLabel=密码[&P]: IncorrectPassword=输入的密码不正确，请重新输入。 ; *** "License Agreement" wizard page WizardLicense=用户许可协议 LicenseLabel=请在继续之前仔细阅读用户许可协议。 LicenseLabel3=请仔细阅读下面的用户许可协议。在继续安装之前，您必须接受该协议。 LicenseAccepted=我接受协议[&a]。 LicenseNotAccepted=我不接受协议[&d] ; *** "Information" wizard pages WizardInfoBefore=提示 InfoBeforeLabel=在继续安装之前请仔细阅读以下重要的信息。 InfoBeforeClickLabel=当您准备好继续安装时，单击“继续”。 WizardInfoAfter=信息 InfoAfterLabel=在继续安装之前请仔细阅读以下重要的信息。 InfoAfterClickLabel=当您准备好继续安装时，单击“继续”。 ; *** "User Information" wizard page WizardUserInfo=用户信息 UserInfoDesc=请输入您的信息。 UserInfoName=用户名[&U]: UserInfoOrg=组织[&O]: UserInfoSerial=序列号[&S]: UserInfoNameRequired=您必须输入一个名称。 ; *** "Select Destination Location" wizard page WizardSelectDir=选择目标位置 SelectDirDesc=您将把[name]安装在哪里? SelectDirLabel3=安装程序将把[name]安装在下面的文件夹中。 SelectDirBrowseLabel=继续安装, 请单击“下一步”。如果需要选择其它目录，请单击“浏览”。 DiskSpaceMBLabel=为了安装本软件，至少需要 [mb] MB 的空闲磁盘空间。 InvalidPath=您比如输入一个含盘符的路径名称。比如:%n%nC:\APP%n%n 或者一个网络路径，例如:%n%n\\server\share InvalidDrive=您选择的磁盘或者网络路径不存在或者不能访问。请重新选择其它的磁盘或者网络路径。 DiskSpaceWarningTitle=磁盘空间不足。 DiskSpaceWarning=安装程序至少需要 %1 KB 空闲磁盘空间来安装本软件。但是选择的磁盘上只有 %2 KB 空间可用。%n%n 您确认继续？ DirNameTooLong=该文件夹的名称太长。 InvalidDirName=该文件夹的名字太长。 BadDirName32=文件夹名称中不能包括以下的任何字符:%n%n%1 DirExistsTitle=文件夹已经存在 DirExists=文件夹:%n%n%1%n%n已经存在。您想继续安装? DirDoesntExistTitle=文件夹不存在 DirDoesntExist=文件夹:%n%n%1%n%n不存在。您想创建该文件夹? CannotInstallToNetworkDrive=程序不能被安装到网络磁盘上. CannotInstallToUNCPath=程序不能被安装到一个 UNC 路径上. ; *** "Select Components" wizard page WizardSelectComponents=选择组件 SelectComponentsDesc=哪些组件需要安装? SelectComponentsLabel2=选择您想要安装的组件; 去掉您不想安装的组件。当您准备好后，请单击“下一步” 。 FullInstallation=完全安装 ; if possible don't translate 'Compact' as 'Minimal' (I mean 'Minimal' in your language) CompactInstallation=精简安装 CustomInstallation=自定义安装 NoUninstallWarningTitle=组件存在 NoUninstallWarning=安装程序检测到以下组件已经被安装到您的电脑中:%n%n%1%n%n不选择它们将不在您的电脑中安装。%n%n您想这样继续吗? ComponentSize1=%1 KB ComponentSize2=%1 MB ComponentsDiskSpaceMBLabel=当前选择项至少需要 [mb] MB 的空闲磁盘空间才能安装。 ; *** "Select Additional Tasks" wizard page WizardSelectTasks=选择附加任务 SelectTasksDesc=您想选择哪个附加任务? SelectTasksLabel2=选择在安装[name]时执行的附加任务后单击“下一步”。 ; *** "Select Start Menu Folder" wizard page WizardSelectProgramGroup=选择开始菜单文件夹 SelectStartMenuFolderDesc=您想在哪里放置软件的快捷方式? SelectStartMenuFolderLabel3=安装程序将在下面的文件夹中创建软件的快捷方式。 SelectStartMenuFolderBrowseLabel=继续安装，请单击“下一步”。如果您想选择其它文件夹，单击“浏览”。 MustEnterGroupName=您必须输入一个文件夹名称。 GroupNameTooLong=文件夹名称或者路径名称太长。 InvalidGroupName=文件夹名称非法。 BadGroupName=文件夹名字中不能包含下面的字符:%n%n%1 NoProgramGroupCheck2=不创建开始菜单中的文件夹[&D] ; *** "Ready to Install" wizard page WizardReady=准备开始安装 ReadyLabel1=安装程序开始在您的电脑中安装[name]. ReadyLabel2a=单击“安装”开始安装本软件,或者单击“上一步”修改安装设置。 ReadyLabel2b=单击“安装”开始安装本软件。 ReadyMemoUserInfo=用户信息: ReadyMemoDir=安装目标位置: ReadyMemoType=安装种类: ReadyMemoComponents=选中的组件: ReadyMemoGroup=开始菜单文件夹: ReadyMemoTasks=附加任务: ; *** "Preparing to Install" wizard page WizardPreparing=准备安装 PreparingDesc=安装程序准备在您的电脑中安装[name]。 PreviousInstallNotCompleted=安装/反安装一个以前的程序没有完成。您需要重新启动您的电脑来完成安装工作。%n%n当重新启动您的电脑后，请运行安装程序来完成安装[name]。 CannotContinue=安装程序不能继续执行。请单击“取消”退出。 ;ApplicationsFound=The following applications are using files that need to be updated by Setup. It is recommended that you allow Setup to automatically close these applications. ApplicationsFound=需要被安装程序更新的文件正被以下应用程序使用。建议由安装程序自动结束这些应用程序。 ;ApplicationsFound2=The following applications are using files that need to be updated by Setup. It is recommended that you allow Setup to automatically close these applications. After the installation has completed, Setup will attempt to restart the applications. ApplicationsFound2=需要被安装程序安装的文件正在被以下应用程序使用。建议由安装程序自动结束这些应用程序。当安装完成后，将会尝试重启这些应用程序。 CloseApplications=&Automatically close the applications DontCloseApplications=&Do not close the applications ; *** "Installing" wizard page WizardInstalling=安装中 InstallingLabel=安装程序正在安装[name],请等待。 ; *** "Setup Completed" wizard page FinishedHeadingLabel=[name]安装完成 FinishedLabelNoIcons=安装程序已经在您的电脑中安装了[name]。 FinishedLabel=安装程序已经成功在您的电脑上安装了[name]。如果需要执行，请单击本软件图标。 ClickFinish=单击“完成”退出本安装程序. FinishedRestartLabel=为了完成[name]的安装, 安装程序必须重新启动您的电脑。您想现在就重新启动吗? FinishedRestartMessage=为了完成[name]的安装, 安装程序必须重新启动您的电脑。%n%您想现在就重新启动吗? ShowReadmeCheck=是的,我想查看 README 文件 YesRadio=是的，我想重新启动计算机[&Y] NoRadio=不，我将稍后重新启动计算机[&N] ; used for example as 'Run MyProg.exe' RunEntryExec=运行 %1 ; used for example as 'View Readme.txt' RunEntryShellExec=查看 %1 ; *** "Setup Needs the Next Disk" stuff ChangeDiskTitle=安装程序需要下一个安装盘 SelectDiskLabel2=请插入安装盘 %1 并且单击“确认”。%n%n如果该盘不是下面显示的盘，请输入正确的路径或者单击“浏览”。 PathLabel=目录[&P]: FileNotInDir2=在 "%2" 中没有发现文件。请插入正确的磁盘或者选择其它的文件夹。 SelectDirectoryLabel=请输入下一个磁盘中的正确位置。 ; *** Installation phase messages SetupAborted=安装没有完成。%n%n请修复错误并重新安装。 EntryAbortRetryIgnore=单击“重试”重新尝试，单击“忽略”将继续安装，或者单击“取消”退出安装。 ; *** Installation status messages StatusCreateDirs=创建目录中... StatusExtractFiles=解压文件中... StatusCreateIcons=创建快捷方式中... StatusCreateIniEntries=创建INI单元中... StatusCreateRegistryEntries=创建注册表内容中... StatusRegisterFiles=注册文件中... StatusSavingUninstall=保存反安装信息中... StatusRunProgram=正在完成安装... StatusRollback=恢复原来修改的内容中... StatusClosingApplications=正在关闭应用程序... StatusRestartingApplications=正在重启应用程序... ; *** Misc. errors ErrorInternal2=内部错误: %1 ErrorFunctionFailedNoCode=%1 失败 ErrorFunctionFailed=%1 失败; 代码 %2 ErrorFunctionFailedWithMessage=%1 错误; 代码 %2.%n%3 ErrorExecutingProgram=不能执行文件:%n%1 ; *** Registry errors ErrorRegOpenKey=在打开注册表键时发生错误:%n%1\%2 ErrorRegCreateKey=在创建注册表键时发生错误:%n%1\%2 ErrorRegWriteKey=在些注册表键时发生错误:%n%1\%2 ; *** INI errors ErrorIniEntry=在创建INI文件时发生错误 "%1". ; *** File copying errors FileAbortRetryIgnore=单击“重试”再试一次，单击“忽略”忽略该文件，或者单击“取消”退出安装程序。 FileAbortRetryIgnore2=单击“重试”再试一次，单击“忽略”忽略该文件继续安装，或者单击“取消”退出安装程序。 SourceIsCorrupted=源文件被使用 SourceDoesntExist=源文件 "%1" 不存在 ExistingFileReadOnly=该已经存在的文件是只读属性。%n%n单击“重试”删除只读属性并重新尝试，单击“忽略”忽略该文件，或者单击“取消”退出安装程序。 ErrorReadingExistingDest=当试图读取一个已经存在的文件时发生了错误: FileExists=该文件已经存在。%n%n您想覆盖它吗? ExistingFileNewer=已经存在的文件比安装程序试图安装的文件要新。建议您保留该文件。%n%n您想保留已经存在的文件吗? ErrorChangingAttr=当试图改变一个存在的文件的属性时发生了错误: ErrorCreatingTemp=当试图在目标目录中创建一个文件时发生了错误: ErrorReadingSource=当试图读取一个文件时发生了错误: ErrorCopying=当试图复制一个文件时发生了错误: ErrorReplacingExistingFile=当试图覆盖已经存在的文件时发生错误: ErrorRestartReplace=重新启动置换失败: ErrorRenamingTemp=当在目标目录中重命名文件时发生错误: ErrorRegisterServer=不能注册 DLL/OCX: %1 ErrorRegSvr32Failed=RegSvr32 执行失败, 错误码: %1 ErrorRegisterTypeLib=不能注册以下类型库: %1 ; *** Post-installation errors ErrorOpeningReadme=当打开 README 文件时发生错误。 ErrorRestartingComputer=安装程序不能重新启动电脑。请手动启动。 ; *** Uninstaller messages UninstallNotFound=文件 "%1" 不存在。不能反安装。 UninstallOpenError=文件 "%1" 不能打开。不能反安装。 UninstallUnsupportedVer=反安装记录文件 "%1" 不是基于本安装程序的版本。不能完成软件的删除工作。 UninstallUnknownEntry=一个未知的实体 (%1) 存在于反安装记录文件中。 ConfirmUninstall=您确定完全删除 %1 和相关组件吗? UninstallOnlyOnWin64=该安装程序只能在64位的Windows上执行反安装工作。 OnlyAdminCanUninstall=该安装程序只能在您具有管理员权限时才能执行反安装工作。 UninstallStatusLabel= %1 正在被删除，请稍等。 UninstalledAll=%1 被成功地从您的电脑中删除。 UninstalledMost=%1 删除完成。%n%n有某些组件无法被删除。您可能需要手动删除它们。 UninstalledAndNeedsRestart=为了完成 %1 的删除工作, 您必须重新启动电脑。%n%n您想现在就重新启动吗? UninstallDataCorrupted=文件"%1" 被占用。不能完成删除工作。 ; *** Uninstallation phase messages ConfirmDeleteSharedFileTitle=删除共享程序文件? ConfirmDeleteSharedFile2=系统指出以下的共享程序文件将不再被使用。您是否想删除这些共享文件?%n%n如果这些文件删除后，其他程序仍然要使用它，可能其它程序的功能将受影响。如果您不能肯定，请选择“否”。让这些文件保留在系统中不会对系统造成损害。 SharedFileNameLabel=文件名: SharedFileLocationLabel=位置: WizardUninstalling=反安装 StatusUninstalling=反安装 %1 中... ; *** Shutdown block reasons ShutdownBlockReasonInstallingApp=安装 %1. ShutdownBlockReasonUninstallingApp=卸载 %1. ; The custom messages below aren't used by Setup itself, but if you make ; use of them in your scripts, you'll want to translate them. [CustomMessages] NameAndVersion=%1 版本 %2 AdditionalIcons=附加图标: CreateDesktopIcon=创建桌面图标[&d] CreateQuickLaunchIcon=创建快速启动图标[&Q] ProgramOnTheWeb=%1 on the Web UninstallProgram=反安装 %1 LaunchProgram=执行 %1 AssocFileExtension=用文件扩展名 %2 匹配[&A] %1? AssocingFileExtension=正在用文件扩展名 %2 匹配[&A] %1 中...]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>InnoSetup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux使用tomcat做下载服务器]]></title>
    <url>%2Fposts%2F2015-10-15-linux-tomcat-download%2F</url>
    <content type="text"><![CDATA[tomcat的安装就不赘述了。 1.进入tomcat的如下目录： /tomcat7/conf/Catalina/localhost 2.新建一个xml文件 我这里在做APP的自动更新，所以就新建一个app.xml如下： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;Context path=”/app” reloadable=”true” docBase=”/appupdate” crossContext=”true”&gt; &lt;/Context&gt; 说明：/app为通过ip地址访问的虚拟目录，它被指向/appupdate 3.编辑tomcat下conf/web.xml 找到如下代码： &nbsp; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &nbsp; 将 默认的 &lt;param-value&gt;false&lt;/param-value&gt;改为 &lt;param-value&gt;true&lt;/param-value&gt; 结果如下所示： &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; 4.重启Tomcat service tomcat restart 5.访问文件： 访问：http://域名:8080/app/ 就可以看到目录下的文件了。 &nbsp; &nbsp; &nbsp;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Fedora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat的catalina.out日志的cronolog分割]]></title>
    <url>%2Fposts%2F2015-09-28-tomcat-catalina-out%2F</url>
    <content type="text"><![CDATA[由于最近的项目使用了tomcat应用服务器，产生的日志文件挺大的，主要是调试中打印的一些信息占空间，比如说System.out和log等等。tomcat 的catalina.out文件的不断扩大，导致系统磁盘空间边变小，所以想到了cronolog工具。 2018.01.19修改： 1.重新上传文件 2.修改图片的显示 安装过程如下： 1、下载 wget https://src.fedoraproject.org/repo/pkgs/cronolog/cronolog-1.6.2.tar.gz/a44564fd5a5b061a5691b9a837d04979/cronolog-1.6.2.tar.gz 本来想直接wget的，但是经过测试好像压缩包有问题，之后只能在本地下载再scp到服务器。 贴上我的分享：点我下载 2、解压缩 # tar zxvf cronolog-1.6.2.tar.gz &nbsp; 3、进入cronolog安装文件所在目录 # cd cronolog-1.6.2 &nbsp; 4、运行安装 # ./configure # make # make install &nbsp; 5、查看cronolog安装后所在目录（验证安装是否成功） # which cronolog 正常情况下显示： /usr/local/sbin/cronolog &nbsp; 要想分割tomcat的catalina.out，需作如下工作： Tomcat7以前的版本： （1）注释掉（#） touch “$CATALINA_BASE”/logs/catalina.out （2）修改tomcat bin目录下的catalina.sh文件中的两处 org.apache.catalina.startup.Bootstrap "$@" start \ >> "$CATALINA_BASE" /logs/catalina.out 2>&1 & 为 org.apache.catalina.startup.Bootstrap "$@" start 2>&1 \ | /usr/local/sbin/cronolog "$CATALINA_BASE" /logs/catalina.%Y-%m-%d.out >> /dev/null & 如下图所示： 完成之后重起Tomcat就可以了。 隔天看logs文件中是否有catalina.2015-09-13.out样式的日志。 &nbsp; Tomcat7以后的版本： 1 第一步 将 if [ -z "$CATALINA_OUT" ] ; then CATALINA_OUT=”$CATALINA_BASE”/logs/catalina.out fi 修改为 if [ -z "$CATALINA_OUT" ] ; then CATALINA_OUT=”$CATALINA_BASE”/logs/catalina.out.%Y-%m-%d fi 2 第二步 将 touch "$CATALINA_OUT" 改为 #touch "$CATALINA_OUT" 3 第三步 将 org.apache.catalina.startup.Bootstrap "$@" start \ >> "$CATALINA_OUT" 2>&1 "&" 修改为 org.apache.catalina.startup.Bootstrap "$@" start 2>&1 \ | /usr/local/sbin/cronolog "$CATALINA_OUT" >> /dev/null & 完成之后重起Tomcat就可以了。 隔天看logs文件中是否有catalina.out.2015-09-13样式的日志。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>Ubuntu</tag>
        <tag>Tomcat</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装Tomcat]]></title>
    <url>%2Fposts%2F2015-09-18-ubuntu-tomcat%2F</url>
    <content type="text"><![CDATA[一、下载tomcat (1)方法一：先下载到本地，然后ftp上传到服务器 官方 Apache Tomcat 的下载页面： http://tomcat.apache.org/download-70.cgi (2)方法二：直接在服务器下载（windows版本的区分32位与64位，ubuntu（linux）版本的不区分） http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.64/bin/apache-tomcat-7.0.64.tar.gz (3)方法三：去我的云盘下载 https://yunpan.cn/c6kfTbwPQxRSb 访问密码 ce9c &nbsp; 二、解压安装 先解压 tar zxvf apache-tomcat-7.0.64.tar.gz -C /java 然后改名为tomcat7 ca /java mv apache-tomcat-7.0.64 tomcat7 更改用户 cd /java/tomcat7 chown -R root . chgrp -R root . **三、配置环境变量** vi /etc/profile 在最后面加上如下两句 CATALINA_HOME=/java/tomcat7 export CATALINA_HOME保存后退出vi 刷新变量使配置立即生效 source /etc/profile 进入tomcat的bin目录 cd $CATALINA_HOME/bin 或者: cd /java/tomcat7/bin 修改catalina.sh vi catalina.sh 找到如下这行 # OS specific support. $var _must_ be set to either true or false. 在这行下面新增如下配置语句 指定tomcat的目录以及jdk的目录 CATALINA_HOME=/java/tomcat7 JAVA_HOME=/java/jdk7 保存后退出vi 尝试下启动tomcat是否成功 在tomcat下的bin目录下直接运行startup.sh sh startup.sh 或者 ./startup.sh 四、安装tomcat服务 当前所在目录是tomcat的bin目录 cp catalina.sh /etc/init.d/tomcat 让tomcat在服务器启动时就启动，配置以下语句 update-rc.d -f tomcat defaults 这样就可以用service启动tomcat了： service tomcat start 关闭tomcat: service tomcat stop 五、查看tomcat日志 cd进入tomcat下的logs目录 即/java/tomcat7/logs 关于日志的切割问题，可以查看我的另外一篇博客：Tomcat的catalina.out日志的cronolog分割 tail -f catalina.out ok，到这里，tomcat就安装完毕了。 &nbsp;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>Ubuntu</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git配置多个SSH-Key]]></title>
    <url>%2Fposts%2F2015-09-17-git-ssh-key%2F</url>
    <content type="text"><![CDATA[Git 如何配置多个 SSH-Key 背景当有多个git账号时，比如： a. 一个gitlab，用于公司内部的工作开发； b. 一个github，用于自己进行一些开发活动； c. 一个gitee，用于其他的一些开发活动； 解决方法（1）生成一个gitlab用的SSH-Key ssh-keygen -t rsa -C &#39;xxx@iyu.pub&#39; -f ~/.ssh/id_rsa_gitlab （2）生成一个github用的SSH-Key ssh-keygen -t rsa -C &#39;xxx@iyu.pub&#39; -f ~/.ssh/id_rsa_github (3)生成一个gitee用的SSH-Key ssh-keygen -t rsa -C &#39;xxx@iyu.pub&#39; -f ~/.ssh/id_rsa_gitee (4)在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径） # gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github # github Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab (5) 用ssh命令分别测试 1.ssh -T git@gitlab.com 成功返回 ==&gt; Welcome to GitLab, @xxx! 2.ssh -T git@github.com 成功返回 ==&gt; Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 3.ssh -T git@gitee.com 成功返回 ==&gt; Hi xxx! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Gitlab</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公共 DNS 域名解析服务]]></title>
    <url>%2Fposts%2F2015-09-11-publicdns%2F</url>
    <content type="text"><![CDATA[平时收集的一些DNS： 百度 DNS：180.76.76.76 阿里 DNS ： 223.5.5.5 和 223.6.6.6 腾讯Public DNS+ : 119.29.29.29 Google : 8.8.8.8 和 8.8.4.4 114dns : 114.114.114.114 &nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java推送天气API]]></title>
    <url>%2Fposts%2F2015-09-08-java-weather-api%2F</url>
    <content type="text"><![CDATA[因为最近在做一个项目，涉及一个小模块——推送天气。根据城市名去找天气的一些信息，比如说，高低温度，实时温度，天气状况，湿度，空气质量AQI等等。 反复找了好多天气API，最后发现小米的API挺不错的，是json格式的数据，方便读取数据。 http://weatherapi.market.xiaomi.com/wtr-v2/weather?cityId= 比如说：深圳的天气代码为101280601 在浏览器上访问http://weatherapi.market.xiaomi.com/wtr-v2/weather?cityId=101280601 如果出现乱码，相信你应该知道怎么解决！ 访问之后，我们拿到如下所示的数据： 相信聪明的你知道怎么看这些数据，转换成如下： &nbsp; 拿到这样的json格式的数据，那就好处理了。 先写一个方法： public static byte[] readInputStream(InputStream inputStream) throws IOException { byte[] buffer = new byte[1024]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((len = inputStream.read(buffer)) != -1) { bos.write(buffer, 0, len); } bos.close(); return bos.toByteArray(); } 再访问API调取数据，直接读取就行： URL url = new URL(“http://weatherapi.market.xiaomi.com/wtr-v2/weather?cityId=101280601&quot;); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); InputStream inputStream = conn.getInputStream(); // 通过输入流获得网站数据 byte[] getData = readInputStream(inputStream); // 获得网站的二进制数据 String data = new String(getData, “utf-8”); System.out.println(“从网页上获取的json:” + data); JSONObject jsonObject01 = JSONObject.fromObject(data); JSONObject jsonObject02 = JSONObject.fromObject(jsonObject01.getJSONObject(“realtime”)); System.out.println(“湿度：” + jsonObject02.getString(“SD”)); System.out.println(“天气：” + jsonObject02.getString(“weather”)); JSONObject jsonObject03 = JSONObject.fromObject(jsonObject01.getJSONObject(“today”)); System.out.println(“高温：” + jsonObject03.getDouble(“tempMax”)); System.out.println(“低温：” + jsonObject03.getDouble(“tempMin”)); JSONObject jsonObject04 = JSONObject.fromObject(jsonObject01.getJSONObject(“aqi”)); System.out.println(“空气质量：” + jsonObject04.getInt(“aqi”)); &nbsp; 这就可以得到自己想读取的数据了。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站时钟]]></title>
    <url>%2Fposts%2F2015-09-07-webclock%2F</url>
    <content type="text"><![CDATA[&lt;div style="width:180px; height:74px; margin:-20px auto 10px auto; overflow:hidden;"&gt; &lt;object width="200" height="88" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=7,0,19,0" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"&gt; &lt;param value="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf" name="movie"&gt; &lt;param value="high" name="quality"&gt; &lt;param value="transparent" name="wmode"&gt; &lt;embed width="200" height="88" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" wmode="transparent" quality="high" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf"&gt; &lt;/object&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress添加网站图标icon]]></title>
    <url>%2Fposts%2F2015-08-27-wordpressicon%2F</url>
    <content type="text"><![CDATA[WordPress 如何添加网站图标icon？ 制作网站图标首先去制作icon的网站（我用的是http://www.bitbug.net/）制作图标图片，大小最好是1616，或者3232的，不要过大了，生成之后下载即可，然后把这个ico格式的图片改名为favicon.ico，直接用FTP软件上传到WordPress根目录。 编辑代码进入WordPress后台，找到“外观”模版下的“编辑”功能，并且编辑“顶部”(header.php)代码。在&lt;head&gt;……&lt;/head&gt;中放入以下代码即可。＜link rel=”shortcut icon” href=”http://www.iyu.pub/favicon.ico&quot;＞中间的网址替换成你的网站地址。 制作完成更新代码，然后刷新网站，即可看到网站的图标了。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《错误》- 郑愁予]]></title>
    <url>%2Fposts%2F2015-08-06-poem-mistake%2F</url>
    <content type="text"><![CDATA[郑愁予-错误 我打江南走过 那等在季节里的容颜如莲花的开落 东风不来，三月的柳絮不飞 你的心如小小的寂寞的城 恰若青石的街道向晚 跫音不项，三月的春帷不揭 你底心是小小的窗扉紧掩 我达达的马蹄声是美丽的错误 我不是归人，是个过客...... 英文译文**Mistake** I passed through the South of Yangzi The face waiting at the turn of seasons, like a lotusflower, blooms and wilts Without the east wind, the willow catkins in Marchdo not futter Your heart is like the lonesome little town Like its streets of cobblestones near nightfall When footfalls are silent and the bed curtains ofMarch not unveiled Your heart is a little window tightly shut My clattering hooves are beautiful mistakes I am not a homecoming man but a passing traveler …]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生十大困惑]]></title>
    <url>%2Fposts%2F2015-08-01-renshengshidakunhuo%2F</url>
    <content type="text"><![CDATA[人生十大困惑 有些事，我们总是弄不懂， 有些人，我们总是猜不透， 有些道，我们总是悟不尽， 有些理，我们总是想不通， 有些坎，我们总是跨不过， 有些伤，我们总是治不好， 有些天，我们总是睡不着， 有些地，我们总是去不了， 有些情，我们总是说不出， 有些爱，我们总是得不到。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实现显示网站运行时间]]></title>
    <url>%2Fposts%2F2015-07-13-php-web-runtime%2F</url>
    <content type="text"><![CDATA[使用PHP实现–显示网站的运行时间 PHP代码：&lt;?php // 设置时区 date_default_timezone_set(&#39;Asia/Shanghai&#39;); /** * 秒转时间，格式 年 月 日 时 分 秒 * @param int $time * @return array|boolean */ function Sec2Time($time)&#123; if(is_numeric($time))&#123; $value = array( &quot;years&quot; =&gt; 0, &quot;days&quot; =&gt; 0, &quot;hours&quot; =&gt; 0, &quot;minutes&quot; =&gt; 0, &quot;seconds&quot; =&gt; 0,); if($time &gt;= 31556926)&#123; $value[&quot;years&quot;] = floor($time/31556926); $time = ($time%31556926); &#125; if($time &gt;= 86400)&#123; $value[&quot;days&quot;] = floor($time/86400); $time = ($time%86400); &#125; if($time &gt;= 3600)&#123; $value[&quot;hours&quot;] = floor($time/3600); $time = ($time%3600); &#125; if($time &gt;= 60)&#123; $value[&quot;minutes&quot;] = floor($time/60); $time = ($time%60); &#125; $value[&quot;seconds&quot;] = floor($time); return (array) $value; &#125;else&#123; return (bool) FALSE; &#125; &#125; // 本站创建的时间 $site_create_time = strtotime(&#39;2015-07-01 00:00:00&#39;); $time = time() - $site_create_time; $uptime = Sec2Time($time); ?&gt; HTML代码：本站已运行： &lt;span style=&quot;color:red;&quot;&gt; &lt;?php echo $uptime[&#39;years&#39;]; ?&gt;年 &lt;?php echo $uptime[&#39;days&#39;]; ?&gt;天 &lt;?php echo $uptime[&#39;hours&#39;]; ?&gt;小时 &lt;?php echo $uptime[&#39;minutes&#39;]; ?&gt;分 &lt;?php echo $uptime[&#39;seconds&#39;]; ?&gt;秒 &lt;/span&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江南烟雨(转载)]]></title>
    <url>%2Fposts%2F2015-07-10-jiangnanyanyu%2F</url>
    <content type="text"><![CDATA[转自散文吧http://www.sanwen8.cn/subject/1391202/ 一&emsp;&emsp;关于故乡的记忆，总是很遥远，远到只能在梦里，才能梦见故乡那栋老房子，在岁月中渐渐隐褪了曾经的色彩；梦见门前的那棵梧桐树，叶子绿了、黄了，落了、抽芽了，任时光的年轮划上一圈又一圈；梦见村口那眼冬暖夏凉的泉，每天氤氲着一股白色的雾气，在人们来来往往水桶撞击的声音中，吟唱着最古老的歌谣。还有，还有外婆在老屋门前一声声地呼唤，带着质朴的乡音，带着最温馨的回忆，飘荡，从梦境到现实，从现实到梦境。 &emsp;&emsp;关于故乡的记忆，总是很近，很近。近到可以听见细雨敲窗，雨打芭蕉；近到可以轻易激起心头泛起的，关于故乡的点滴回忆。桃红柳绿，东风暗换年华，但故乡是心头永远的朱砂，总能轻易地勾起心中最深的记忆与牵挂。 &emsp;&emsp;故乡，是一条纤细的乡村小路，小路上杂草丛生，漫过了白色的球鞋，打湿了清晨的裤脚，一直通向校园的方向，通向遥远的，未知的地方。 &emsp;&emsp;春天来了，水田里的禾苗仿若一个个娇小的绿色人儿，在微风中轻轻地招手，一眼望去，是那一望无际的绿色海洋，这里，孕育着庄稼人一年的希望。 &emsp;&emsp;花开了，开在屋前后那高高的田坎上，开在春风拂过的山岗上。一直以来，对于桃花就有着一种别样的喜爱。桃红点点，粉红的花瓣，随着微风 ，轻轻飘落，零落了多少女儿娇柔的心事。惜春常恨春归早，那时候的我，怎懂得韶华易逝的道理。看着那漫天飞舞的桃花瓣，只是觉得好美，好美。伸出手，让花瓣一片一片，自指尖飘落，纷飞成一季最美、纯洁的梦。那个桃花树下的小小姑娘，扎着短短的马尾巴，就这样眼巴巴地，看着那一树桃红，仿佛透过那朵朵盛开的粉红的花朵，看见了一树的硕果累累，馋了嘴，馋了梦，馋了那一季的美好的童年。 &emsp;&emsp;夏天来了。河水沸腾了。两岸杨柳依依，临水梳妆，一双美眸，静静凝望着不远处，在小河里嬉戏玩闹的大人、小孩。小河的胸怀是宽广的，她默默地容纳着来自心灵人们从心灵深处迸发的欢愉，成为这个季节，大自然最清凉的馈赠。 &emsp;&emsp;田地间，成片成片的玉米地，绿油油的，仿佛一排排卫士，守候着自己的家园。村落间、山林间，时常听见布谷鸟千年不变的吟唱，吟唱着一曲朴实、勤劳的歌谣。我总觉得布谷鸟是在叫“豌豆、包谷”，似是而是，听来感觉是那么一回事。离开故乡以后，就再也听不见它的吟唱了，自然也不知道它究竟唱得什么，但我知道，那一声声啼叫，早已经烙在了我的灵魂深处，在某一个午夜梦回，将我带进那个小小山村，带进那片田园，听一曲而来自布谷鸟的天籁。 &emsp;&emsp;秋天来了。秋，是喜悦，是收获，是农民洋溢的笑脸，是那一把把挥洒的汗水。 &emsp;&emsp;这个时节的农事多，打谷子、收玉米，挖红薯，接踵而来的农事，压弯了农民的脊梁，喜悦着农民酣睡的梦乡。对于孩子来说，这个季节是山地田野间肆意的玩闹，是枝头的硕果累累。各种水果，都卖弄着最成熟的风姿。一个个柿子，高高地挂在枝头，仿佛一个个灯笼，煞是好看。橘子已经开始黄了，可孩子们就喜欢那酸酸甜甜的味道，这个在树上摘，几个在树下巴巴地望着，等着树上的孩子扔下来，然后争相抢着，闹着。枣树下，孩子们一个个拿着常常的竹杠，伸长了脖子，敲敲这颗，敲敲那颗。叫嚷着，这里、这里，那边、那边还有……童声，交织成一片欢喜，在秋的田野，编织着丰收的歌谣。 &emsp;&emsp;我是喜欢冬天的。记忆里的那银装素裹的世界，多少次浮上心头。故乡的冬，没有毛主席笔下的“千里冰封，万里雪飘。”故乡的雪，是安静的。它轻盈地落在山头，轻盈地漫过小河，无声敲打着农户的窗口，将一片雪白的世界悄悄带来。 &emsp;&emsp;冬，是寂静的，偶尔，村落间会传来狗吠的声音。声音落下，枝头的白雪犹如被惊吓了一般，“扑哧哧”落下，溅起细碎的花朵，开在冬季，开在那些孩子的梦里。 &emsp;&emsp;小河醉了，将一枕清梦深藏，藏进来年的春；山野醉了，银装素裹，分外妖娆；农人醉了，酣睡的梦里，酝酿着这一年的喜悦与短暂的休憩…… &emsp;&emsp;故乡是一个梦的摇篮，盛满在希望的田野间，斑斓在千年耕耘的山山水水间。沟沟壑壑的土地上，挥洒着多少农民的汗水，埋藏着多少年复一年的希望与憧憬。田地就是希望，勤劳便是未来，双手可以撑起一段又一段岁月。 二&emsp;&emsp;故乡有山，有水，山清水秀。 &emsp;&emsp;山，必然有着山的魂魄。山的魂魄名为豪迈，一曲曲山歌，粗狂、豪迈，带着原始最朴质的旋律，带着山里人的那份“野性”，从嗓子里吼出来，从灵魂中迸发而出。 &emsp;&emsp;水，必然有着水的灵性。水的灵性是柔情。那水，静静地依偎着这片土地，宛若一条绿色的丝带，成为这片土地上美丽的风景。她宛若一个温润的邻家姑娘，顾盼间，柔情万千。 &emsp;&emsp;有了山，有了水，故乡就有了活力。故乡的四面都被青山的环抱着。春天来了，小草绿了，河水动了，燕子也开始忙碌地衔着春泥。水田里，青青的禾苗贪婪地吮吸着春水，你若细细聆听，必然可以听见麦苗拔节的声音。 &emsp;&emsp;杨柳依依，桃红柳绿，这个时节，自然少不了烟雨朦胧。 &emsp;&emsp;烟雨，是一副山水画！属于耕者的画面。 &emsp;&emsp;岁月在时光的深处划上了不同的符号，而烟雨必然是属于故乡最独特的符号。我没有去过真正的江南，不懂得江南烟雨的那份空灵与美丽，只是肆意地任凭想象的种子在心头绽放成故乡烟雨的模样。 &emsp;&emsp;故乡，是厚重的，而耕者，则是故乡的标志，是一个年代最独特的印记。岁月将曾经挺直的脊梁，一点一点压弯，弯成了耕者最后的画面，弯成了生活最初的模样。 &emsp;&emsp;斜风细雨，天空中的燕子，低低地飞翔着，时不时地掠过耕者的头顶，似乎在悄悄地打量，又或者在低低地呢喃。 &emsp;&emsp;耕者的吆喝、老牛的呐喊、细雨的呢喃，勾勒出故乡最初的轮廓。这轮廓间，泾渭分明，动静交织，在岁月中若隐若现，清晰着关于一个年代的记忆。 &emsp;&emsp;雨，在屋檐处滴答成一首静谧的曲子，若一位少女，将自己的一腔心事，静静地倾诉着。 &emsp;&emsp;有雨的日子，老人们总是斜依在那已经微微有些破旧的、沾满了油渍的沙发上。听着雨声，慵懒地打发着那些闲碎的光阴。他们微闭着眼睛，似乎在将岁月中那些暖暖的记忆反复回味。他们的笑容，浅浅地，脸上的皱纹如同枯萎的花儿一般，保留着最后的姿态。 &emsp;&emsp;女人们坐在堂屋里，听着滴答的雨声，一边拉着鞋底，一边将村子里那些陈旧的芝麻绿豆的小事，翻转。生活的往事，便在唾沫横飞中落定，犹如那些土屋中旮旯犄角里堆积的层层尘埃，一点一点被时光掩埋。 &emsp;&emsp;里屋，孩子们不能若天晴一般在田地间玩耍，此时的他们，仿佛被束缚的鸟儿一般，眼巴巴地看着那落雨的屋檐，看看细雨蒙蒙的天空，任由心思在雨中奔跑着，或者，干脆在大人的呵斥中在院子里嬉戏，任由细雨轻吻着那些稚嫩天真的笑颜。 &emsp;&emsp;有雨，那些圈养的鸡便无精打采地在屋檐下躲着雨，这里一堆，那里一垛的，时不时地抖落着羽毛上沾染的雨滴，时不时地 用爪子在地上划上几道爪印，又或者“咯咯”“咯咯”叫上几声，仿佛也在嘀咕着，“这雨啥时候可以停啊？” &emsp;&emsp;…… &emsp;&emsp;烟雨的日子，故乡是静谧的。远处的青山，静静地打量着，任凭细雨蒙蒙，将往日的尘埃一点一点洗刷，山更绿了。河边的柳，静静地梳理着垂下的发丝，若一位温婉的姑娘，正含羞与这场烟雨相约。路边的野草，不知名的花儿，也随着微风轻轻地摆动着腰肢，贪婪地吮吸着甘甜的“乳汁”。 &emsp;&emsp;烟雨，是故乡的魂，淅淅沥沥下在游子的心头。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获取文本区某一行数据]]></title>
    <url>%2Fposts%2F2015-07-09-java-text%2F</url>
    <content type="text"><![CDATA[Java获取文本中某一行数据的方法： 第一种方法String strArray[] = message.split(&quot;\n&quot;); for(int i=0; i&lt;strArray.length;i++)&#123; System.out.println(&quot;第&quot;+ (i+1) +&quot;行数据为：&quot;+strArray[i]); &#125; 第二种方法JTextArea area = new JTextArea(); area.setText(&quot;fasfsadf\nafdasdfsad\nsafasvcxb\n&quot;); System.out.println(area.getText()); StringTokenizer tokenizer = new StringTokenizer(area.getText(),&quot;\n&quot;); while(tokenizer.hasMoreTokens()) &#123; System.out.println(tokenizer.nextToken()); &#125; for(String str:area.getText().split(&quot;\n&quot;))&#123; System.out.println(str); &#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[残荷听雨]]></title>
    <url>%2Fposts%2F2015-07-07-canhetingyu%2F</url>
    <content type="text"><![CDATA[有一种高贵，总让我匍匐膜拜；有一种圣洁，总让我敬重仰视。 那就是残荷，挺立于泥淖之中高贵而圣洁的灵魂花朵。 平生是那么地喜欢荷，不仅因为她美丽的外表，更因为她高洁的品格。中通外直、不蔓不枝是荷花的个性；美而不艳、媚而不俗是荷花的风姿；出淤泥而不染、濯清涟而不妖是她的志向；纯洁高雅、可远观而不可亵玩是她的品德。喜欢荷花“花娇映红玉，艳影照清漪”中的那份宁静；喜欢荷花“三秋庭绿尽迎霜，惟有荷花守红死”的忠贞。 初冬时节，飘雨的午后。独自一人，静立在荷塘边，听雨，与残荷。那雨，浸透了思绪，让人忘了时间，忘了自己，宛如一幅孤零零的剪影，倒映在残荷随意泼就而成的水墨画里，与残荷一起溶入静穆的烟雨中。 残荷的美是一种苍凉悲壮的凄美!落叶知寒，栖鸟南迁，满目萧然，荷已成殇。冷雨中的残荷，落尽繁华，枯黄憔悴，历尽风雨沧桑，世俗无暇顾盼。没有了沁人心脾的幽香，没有了文人骚客的礼赞。悲苦的冷雨落在残荷上，孤寂与落寞溢满一塘。雨点淡淡地漾开，好像在微微地叹息着。看那一塘残荷，满目萍碎，在风雨中，有的高擎着黑褐色的叶子，有的被风雨摧残折断倒立在水中；叶子有的残破，有的蜷曲，有的倒伏泥淖之中或昂首向天，或低头沉尽，—或相互依偎，或枝叶相交……尘世的荣衰，世态的炎凉，莲的心事，谁人能懂? “秋阴不散霜飞晚，留得残荷听雨声。”残荷的美是一种历经沧桑之后的心境，苍凉而悠远；那是经过了万千红尘之后的淡定，脆弱而不屈；那是繁华落尽之后，于凄风冷雨中依然坚守的优雅与从容。也许在她的心中藏着一个美丽的梦，待来年的盛夏，满塘的荷花依旧会在荷叶的拥托之中，亭亭玉立，香远益清。含苞的娇羞欲语，怒放的潇洒舒展。粉荷美艳，白荷净洁，演绎万种风情。 聆听荷的心语，领略荷傲人的风姿。残荷听雨，就是让心在最纯净最圣洁的诗句间游走，就是让心灵积淀一份清澈，就是让灵魂多一次净化。感念着四季的轮回，感念着生命的流逝，我唯愿生命如荷：在繁华褪尽的萧索里，保持生命与生俱来的不屈和圣洁；在凄风冷雨的逆境中，保持灵魂的那份纯真与高贵。 残荷，我向你膜拜：为你的不屈，为你枯搞形骸荧茕而立的气度，为你不以物喜不以己悲的坦然，为蕴藏在你生命中那份孤傲与自信! 静心听雨，仿佛是在聆听生命渐行渐远的足音；听残荷承雨，又仿佛在聆听自己寂寞的心语。一种发自生命深处的感念油然而生：生命当以圣洁为本，灵魂当以高贵为伴，香消玉殒风骨犹在，身形憔悴香气长存。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除wordpress侧边栏功能的wordpress.org和feed链接]]></title>
    <url>%2Fposts%2F2015-07-06-wordpressuse%2F</url>
    <content type="text"><![CDATA[在wordpress功能版块有登入\登出，管理，Feed以外，还有一个wordpress，如何删除它们呢? 具体做法： 找到网站wordpress安装目录 在wp_includes文件夹下面有一个default-widgets.php的文件 在此文件里搜索查找&lt;li标签里带有rss2_url，comments_rss2_url，wordpress.org的三段代码全部删除掉。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现网页跳转后可隐藏跳转后网址的代码]]></title>
    <url>%2Fposts%2F2015-07-03-jsjump%2F</url>
    <content type="text"><![CDATA[网页跳转后，隐藏跳转后网址 方法一&lt;script&gt; window.onload=new function()&#123; window.location=&#39;/home/index.html&#39; &#125;; &lt;/script&gt; 方法二&lt;frameset framespacing=&quot;0&quot; border=&quot;0&quot; rows=&quot;0&quot; frameborder=&quot;0&quot;&gt; &lt;frame name=&quot;main&quot; src=&quot;http://www.iyu.pub/&quot; scrolling=&quot;auto&quot; noresize&gt; &lt;/frameset&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计网站访问量的PHP代码]]></title>
    <url>%2Fposts%2F2015-07-02-clicknumbyphp%2F</url>
    <content type="text"><![CDATA[使用PHP统计网站的访问量 &lt;?php session_start(); if(!isset($_SESSION[‘name’]))&#123; $counterFile = “counter.txt”; $fp = fopen($counterFile,”a+”); $num = fgets($fp,5); $num=$num+1; print “您是第 “.”$num”.” 位访客”; &#125;else&#123; $counterFile = “counter.txt”; $fp = fopen($counterFile,”a+”); $num = fgets($fp,5); $num=$num; print “您是第 “.”$num”.” 位访客”; &#125; fclose($fp); if(!isset($_SESSION[‘name’]))&#123; $fpp=fopen($counterFile,”w”); fwrite($fpp, $num); fclose($fpp);&#125;else&#123;exit(); &#125; $name=”test”; $_SESSION[‘name’]=$name; ?&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计网站运行时间的JavaScript代码]]></title>
    <url>%2Fposts%2F2015-07-02-runtimebyjs%2F</url>
    <content type="text"><![CDATA[有时候需要在静态页上显示网站的运行时间，所以用JavaScript实现。 &lt;span id=”showsectime” style=”color:#FF0000;”&gt;网站已安全运行1天1时1分1秒&lt;/span&gt; &lt;script type=”text/javascript”&gt; function NewDate(str) &#123; str = str.split(‘-‘); var date = new Date(); date.setUTCFullYear(str[0], str[1] – 1, str[2]); date.setUTCHours(0, 0, 0, 0); return date; &#125; function showsectime() &#123; var birthDay =NewDate(“2014-08-14”); var today=new Date(); var timeold=today.getTime()-birthDay.getTime(); var sectimeold=timeold/1000 var secondsold=Math.floor(sectimeold); var msPerDay=246060*1000; var e_daysold=timeold/msPerDay; var daysold=Math.floor(e_daysold); var e_hrsold=(daysold-e_daysold)-24; var hrsold=Math.floor(e_hrsold); var e_minsold=(hrsold-e_hrsold)-60; var minsold=Math.floor((hrsold-e_hrsold)*-60); var seconds=Math.floor((minsold-e_minsold)*-60).toString(); document.getElementById(“showsectime”).innerHTML = “网站已安全运行”+daysold+”天”+hrsold+”时”+minsold+”分”+seconds+”秒”; setTimeout(showsectime, 1000); &#125; showsectime(); &lt;/script&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听风行 旗下所有站点大全]]></title>
    <url>%2Fposts%2F2015-07-01-allsite%2F</url>
    <content type="text"><![CDATA[不知不觉，撸了一个又一个网站，好多都在吃灰，今天整理下。 主要网站 No. 网站 链接 1 听风行官网 http://iyu.pubhttp://www.iyu.pub 2 听风行博客 http://blog.iyu.pub 3 TingBrowser浏览器 http://browser.iyu.pub 工具网站 No. 网站 链接 1 抖音视频在线解析下载 http://douyin.iyu.pub 2 Tmusic http://music.iyu.pub 3 听风行影视 http://v.iyu.pub(目前网站的视频采集好像有点问题，有时间捉捉虫) 4 VIP视频解析 http://vip.iyu.pubhttp://vip2.iyu.pubhttp://vip3.iyu.pub 5 图床 http://img.iyu.pub 6 壁纸 http://wall.iyu.pub 7 元素周期表 http://fun.iyu.pub/ 8 装逼神器 http://b.iyu.pub 9 百度云直链解析 http://bd.iyu.pub 10 IPTV高清在线直播 http://tv.iyu.pub 游戏网站 No. 网站 链接 1 五子棋 http://wuziqi.iyu.pub 2 中国象棋 http://chess.iyu.pub/ 3 2048 http://2048.iyu.pub/ 4 奇葩版FlappyBird http://textbird.iyu.pub 5 方块版FlappyBird http://rectbird.iyu.pub/ 6 马里奥 http://mario.iyu.pub 7 水果忍者 http://fruit.iyu.pub/ 8 吃豆人 http://chidouren.iyu.pub/ 9 重力下落积木 http://toy.iyu.pub]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>听风行</tag>
        <tag>站点</tag>
      </tags>
  </entry>
</search>
