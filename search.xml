<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot源码分析(10)-SpringBoot的内置生命周期事件]]></title>
    <url>%2Fposts%2F2020-11-24-SpringBoot-Source-10%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringBoot的内置生命周期事件 上一篇分析了SpringBoot启动时广播生命周期事件的原理，关键步骤总结： 为广播SpringBoot内置生命周期事件做前期准备： 1）首先加载ApplicationListener监听器实现类； 2）其次加载SPI扩展类EventPublishingRunListener。 SpringBoot启动时利用EventPublishingRunListener广播生命周期事件，然后ApplicationListener监听器实现类监听相应的生命周期事件执行一些初始化逻辑的工作。 1.SpringBoot生命周期事件源码分析SpringBoot的生命周期事件，类结构图： 由上图可以看到事件类之间的关系： 最顶级的父类是JDK的事件基类EventObject； 然后Spring的事件基类ApplicationEvent继承了JDK的事件基类EventObject； 其次SpringBoot的生命周期事件基类SpringApplicationEvent继承了Spring的事件基类ApplicationEvent； 最后SpringBoot具体的7个生命周期事件类再继承了SpringBoot的生命周期事件基类SpringApplicationEvent。 1.1 JDK的事件基类EventObjectEventObject类是JDK的事件基类，是所有Java事件类的基本，即所有的Java事件类都直接或间接继承于该类，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940public class EventObject implements java.io.Serializable &#123; private static final long serialVersionUID = 5516075349620653480L; /** * The object on which the Event initially occurred. */ protected transient Object source; /** * Constructs a prototypical Event. * * @param source The object on which the Event initially occurred. * @exception IllegalArgumentException if source is null. */ public EventObject(Object source) &#123; if (source == null) throw new IllegalArgumentException(&quot;null source&quot;); this.source = source; &#125; /** * The object on which the Event initially occurred. * * @return The object on which the Event initially occurred. */ public Object getSource() &#123; return source; &#125; /** * Returns a String representation of this EventObject. * * @return A a String representation of this EventObject. */ public String toString() &#123; return getClass().getName() + &quot;[source=&quot; + source + &quot;]&quot;; &#125;&#125; 可以看到EventObject类只有一个属性source，这个属性是用来记录最初事件是发生在哪个类。 比如在SpringBoot启动过程中会触发ApplicationStartingEvent事件，而这个事件最初是在SpringApplication类中触发的，因此source就是SpringApplication对象。 1.2 Spring的事件基类ApplicationEventApplicationEvent继承了JDK的事件基类EventObject类，是Spring的事件基类，被所有Spring的具体事件类继承，源码如下： 123456789101112131415161718192021222324252627public abstract class ApplicationEvent extends EventObject &#123; /** use serialVersionUID from Spring 1.2 for interoperability. */ private static final long serialVersionUID = 7099057708183571937L; /** System time when the event happened. */ private final long timestamp; /** * Create a new ApplicationEvent. * @param source the object on which the event initially occurred (never &#123;@code null&#125;) */ public ApplicationEvent(Object source) &#123; super(source); this.timestamp = System.currentTimeMillis(); &#125; /** * Return the system time in milliseconds when the event happened. */ public final long getTimestamp() &#123; return this.timestamp; &#125;&#125; 可以看到ApplicationEvent有且仅有一个属性timestamp，该属性是用来记录事件发生的时间。 1.3 SpringBoot的事件基类SpringApplicationEventSpringApplicationEvent类继承了Spring的事件基类ApplicationEvent，是所有SpringBoot内置生命周期事件的父类，源码如下： 12345678910111213141516171819@SuppressWarnings(&quot;serial&quot;)public abstract class SpringApplicationEvent extends ApplicationEvent &#123; private final String[] args; public SpringApplicationEvent(SpringApplication application, String[] args) &#123; super(application); this.args = args; &#125; public SpringApplication getSpringApplication() &#123; return (SpringApplication) getSource(); &#125; public final String[] getArgs() &#123; return this.args; &#125;&#125; 可以看到SpringApplicationEvent有且仅有一个属性args，该属性就是SpringBoot启动时的命令行参数即标注@SpringBootApplication启动类中main函数的参数。 2.SpringBoot具体的生命周期事件类接下来分析一下SpringBoot内置生命周期事件即SpringApplicationEvent的7个具体子类。 2.1 ApplicationStartingEvent123456789101112public class ApplicationStartingEvent extends SpringApplicationEvent &#123; /** * Create a new &#123;@link ApplicationStartingEvent&#125; instance. * @param application the current application * @param args the arguments the application is running with */ public ApplicationStartingEvent(SpringApplication application, String[] args) &#123; super(application, args); &#125;&#125; SpringBoot开始启动时便会发布ApplicationStartingEvent事件，其发布时机在环境变量Environment或容器ApplicationContext创建前但在注册ApplicationListener具体监听器之后，标志标志SpringApplication开始启动。 2.2 ApplicationEnvironmentPreparedEvent12345678910111213141516171819202122232425public class ApplicationEnvironmentPreparedEvent extends SpringApplicationEvent &#123; private final ConfigurableEnvironment environment; /** * Create a new &#123;@link ApplicationEnvironmentPreparedEvent&#125; instance. * @param application the current application * @param args the arguments the application is running with * @param environment the environment that was just created */ public ApplicationEnvironmentPreparedEvent(SpringApplication application, String[] args, ConfigurableEnvironment environment) &#123; super(application, args); this.environment = environment; &#125; /** * Return the environment. * @return the environment */ public ConfigurableEnvironment getEnvironment() &#123; return this.environment; &#125;&#125; 可以看到ApplicationEnvironmentPreparedEvent事件多了一个environment属性，作用是利用事件发布订阅机制，相应监听器可以从ApplicationEnvironmentPreparedEvent事件中取出environment变量，然后可以为environment属性增加属性值或读出environment变量中的值。 例如： ConfigFileApplicationListener监听器就是监听了ApplicationEnvironmentPreparedEvent事件，然后取出ApplicationEnvironmentPreparedEvent事件的environment属性，然后再为environment属性增加application.properties配置文件中的环境变量值。 当SpringApplication已经开始启动且环境变量Environment已经创建后，并且为环境变量Environment配置了命令行和Servlet等类型的环境变量后，此时会发布ApplicationEnvironmentPreparedEvent事件。 监听ApplicationEnvironmentPreparedEvent事件的第一个监听器是ConfigFileApplicationListener，因为是ConfigFileApplicationListener监听器还要为环境变量Environment增加application.properties配置文件中的环境变量；此后还有一些也是监听ApplicationEnvironmentPreparedEvent事件的其他监听器监听到此事件时，此时环境变量Environment几乎已经完全准备好了。 思考： 监听同一事件的监听器们执行监听逻辑时是有顺序的，可以想一下这个排序逻辑是什么时候排序的？还有为什么要这样排序呢？ 2.3 ApplicationContextInitializedEvent12345678910111213141516171819202122232425public class ApplicationContextInitializedEvent extends SpringApplicationEvent &#123; private final ConfigurableApplicationContext context; /** * Create a new &#123;@link ApplicationContextInitializedEvent&#125; instance. * @param application the current application * @param args the arguments the application is running with * @param context the context that has been initialized */ public ApplicationContextInitializedEvent(SpringApplication application, String[] args, ConfigurableApplicationContext context) &#123; super(application, args); this.context = context; &#125; /** * Return the application context. * @return the context */ public ConfigurableApplicationContext getApplicationContext() &#123; return this.context; &#125;&#125; 可以看到ApplicationContextInitializedEvent事件多了个ConfigurableApplicationContext类型的context属性，context属性的作用同样是为了相应监听器可以拿到这个context属性执行一些逻辑。 ApplicationContextInitializedEvent事件在ApplicationContext容器创建后，且为ApplicationContext容器设置了environment变量和执行了ApplicationContextInitializers的初始化方法后但在bean定义加载前触发，标志ApplicationContext已经初始化完毕。 扩展： 可以看到ApplicationContextInitializedEvent是在为context容器配置environment变量后触发，此时ApplicationContextInitializedEvent等事件只要有context容器的话，那么其他需要environment环境变量的监听器只需要从context中取出environment变量即可，从而ApplicationContextInitializedEvent等事件没必要再配置environment属性。 2.4 ApplicationPreparedEvent12345678910111213141516171819202122232425public class ApplicationPreparedEvent extends SpringApplicationEvent &#123; private final ConfigurableApplicationContext context; /** * Create a new &#123;@link ApplicationPreparedEvent&#125; instance. * @param application the current application * @param args the arguments the application is running with * @param context the ApplicationContext about to be refreshed */ public ApplicationPreparedEvent(SpringApplication application, String[] args, ConfigurableApplicationContext context) &#123; super(application, args); this.context = context; &#125; /** * Return the application context. * @return the context */ public ConfigurableApplicationContext getApplicationContext() &#123; return this.context; &#125;&#125; 同样可以看到ApplicationPreparedEvent事件多了个ConfigurableApplicationContext类型的context属性，多了context属性的作用是能让监听该事件的监听器们能拿到context属性，监听器拿到context属性一般有如下作用： 从事件中取出context属性，然后可以增加一些后置处理器，比如ConfigFileApplicationListener监听器监听到ApplicationPreparedEvent事件后，然后取出context变量，通过context变量增加了PropertySourceOrderingPostProcessor这个后置处理器； 通过context属性取出beanFactory容器，然后注册一些bean，比如LoggingApplicationListener监听器通过ApplicationPreparedEvent事件的context属性取出beanFactory容器,然后注册了springBootLoggingSystem这个单例bean； 通过context属性取出Environment环境变量，然后就可以操作环境变量，比如PropertiesMigrationListener。 ApplicationPreparedEvent事件在ApplicationContext容器已经完全准备好时但在容器刷新前触发，在这个阶段bean定义已经加载完毕还有environment已经准备好可以用了。 2.5 ApplicationStartedEvent12345678910111213141516171819202122232425public class ApplicationStartedEvent extends SpringApplicationEvent &#123; private final ConfigurableApplicationContext context; /** * Create a new &#123;@link ApplicationStartedEvent&#125; instance. * @param application the current application * @param args the arguments the application is running with * @param context the context that was being created */ public ApplicationStartedEvent(SpringApplication application, String[] args, ConfigurableApplicationContext context) &#123; super(application, args); this.context = context; &#125; /** * Return the application context. * @return the context */ public ConfigurableApplicationContext getApplicationContext() &#123; return this.context; &#125;&#125; ApplicationStartedEvent事件将在容器刷新后但ApplicationRunner和CommandLineRunner的run方法执行前触发，标志Spring容器已经刷新，此时容器已经准备完毕了。 扩展： 这里提到了ApplicationRunner和CommandLineRunner接口有啥作用呢？一般会在Spring容器刷新完毕后，此时可能有一些系统参数等静态数据需要加载，此时就可以实现了ApplicationRunner或CommandLineRunner接口来实现静态数据的加载。 2.6 ApplicationReadyEvent12345678910111213141516171819202122232425public class ApplicationReadyEvent extends SpringApplicationEvent &#123; private final ConfigurableApplicationContext context; /** * Create a new &#123;@link ApplicationReadyEvent&#125; instance. * @param application the current application * @param args the arguments the application is running with * @param context the context that was being created */ public ApplicationReadyEvent(SpringApplication application, String[] args, ConfigurableApplicationContext context) &#123; super(application, args); this.context = context; &#125; /** * Return the application context. * @return the context */ public ConfigurableApplicationContext getApplicationContext() &#123; return this.context; &#125;&#125; ApplicationReadyEvent事件在调用完ApplicationRunner和CommandLineRunner的run方法后触发，此时标志SpringApplication已经正在运行。 2.7 ApplicationFailedEvent12345678910111213141516171819202122232425262728293031323334353637public class ApplicationFailedEvent extends SpringApplicationEvent &#123; private final ConfigurableApplicationContext context; private final Throwable exception; /** * Create a new &#123;@link ApplicationFailedEvent&#125; instance. * @param application the current application * @param args the arguments the application was running with * @param context the context that was being created (maybe null) * @param exception the exception that caused the error */ public ApplicationFailedEvent(SpringApplication application, String[] args, ConfigurableApplicationContext context, Throwable exception) &#123; super(application, args); this.context = context; this.exception = exception; &#125; /** * Return the application context. * @return the context */ public ConfigurableApplicationContext getApplicationContext() &#123; return this.context; &#125; /** * Return the exception that caused the failure. * @return the exception */ public Throwable getException() &#123; return this.exception; &#125;&#125; 可以看到ApplicationFailedEvent事件除了多了一个context属性外，还多了一个Throwable类型的exception属性用来记录SpringBoot启动失败时的异常。 ApplicationFailedEvent事件在SpringBoot启动失败时触发，标志SpringBoot启动失败。 总结SpringBoot启动过程中要触发的各种生命周期事件 发布顺序 时间 用途 1 ApplicationStartingEvent 在SpringApplication启动时，在环境变量Environment或者容器ApplicationContext创建前触发，标志SpringApplication开始启动。 2 ApplicationEnvironmentPreparedEvent 当SpringApplication已经开始启动且环境变量Environment已经准备好时触发，标志环境变量已经准备好。 3 ApplicationContextInitializedEvent ApplicationContextInitializers的初始化方法已经被调用，即从spring.factories中加载的initializers已经执行ApplicationContext初始化逻辑但在bean定义加载前触发，标志ApplicationContext已经初始化完毕。 4 ApplicationPreparedEvent 在Spring容器刷新refresh前触发 5 ApplicationStartedEvent 在spring容器刷新后触发，但在调用ApplicationRunner和CommandLineRunner的run方法调用前触发，标志spring容器已经刷新，此时所有的bean实例等都已经加载了。 6 ApplicationReadyEvent 只要SpringApplication可以接收服务请求时即调用完ApplicationRunner和CommandLineRunner的run方法后触发，此时标志SpringApplication已经正在运行，即启动成功。 7 ApplicationFailedEvent 若SpringApplication未能成功启动时则会catch住异常发布ApplicationFailedEvent事件，标志ApplicationFailedEvent启动失败。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(9)-SpringBoot的事件监听机制]]></title>
    <url>%2Fposts%2F2020-11-23-SpringBoot-Source-09%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringBoot的事件监听机制 上一篇分析了SpringApplication对象的构建过程及SpringBoot自己实现的一套SPI机制，关键步骤总结： SpringApplication对象的构造过程其实就是给SpringApplication类的6个成员变量赋值； SpringBoot通过以下步骤实现自己的SPI机制： 1)首先获取线程上下文类加载器; 2)然后利用上下文类加载器从spring.factories配置文件中加载所有的SPI扩展实现类并放入缓存中; 3)根据SPI接口从缓存中取出相应的SPI扩展实现类; 4)实例化从缓存中取出的SPI扩展实现类并返回。 1.SpringBoot广播内置生命周期事件流程分析在SpringBoot启动过程中，每个不同的启动阶段会分别广播不同的内置生命周期事件，然后相应的监听器会监听这些事件来执行一些初始化逻辑工作。比如ConfigFileApplicationListener会监听onApplicationEnvironmentPreparedEvent事件来加载配置文件application.properties的环境变量等。 为了探究SpringBoot广播内置生命周期事件流程，回顾一下SpringBoot的启动流程代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); // 【0】新建一个SpringApplicationRunListeners对象用于触发SpringBoot启动过程中的生命周期事件 SpringApplicationRunListeners listeners = getRunListeners(args); // 【1】》》》》》触发【ApplicationStartingEvent】事件，标志SpringApplication开始启动 listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 【2】》》》》》触发【ApplicationEnvironmentPreparedEvent】事件，此时会去加载application.properties等配置文件的环境变量，同时也有标志环境变量已经准备好的意思 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); // 【3】》》》》》触发【ApplicationContextInitializedEvent】事件，标志context容器被创建且已准备好 // 【4】》》》》》触发【ApplicationPreparedEvent】事件，标志Context容器已经准备完成 prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; // 【5】》》》》》触发【ApplicationStartedEvent】事件，标志spring容器已经刷新，此时所有的bean实例都已经加载完毕 listeners.started(context); callRunners(context, applicationArguments); &#125; // 【6】》》》》》触发【ApplicationFailedEvent】事件，标志SpringBoot启动失败 catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; // 【7】》》》》》触发【ApplicationReadyEvent】事件，标志SpringApplication已经正在运行即已经成功启动，可以接收服务请求了。 listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125; 可以看到SpringBoot在启动过程中首先会先新建一个SpringApplicationRunListeners对象用于触发SpringBoot启动过程中的各种生命周期事件，比如触发ApplicationStartingEvent,ApplicationEnvironmentPreparedEvent和ApplicationContextInitializedEvent等事件，然后相应的监听器会执行一些SpringBoot启动过程中的初始化逻辑。那么，监听这些SpringBoot的生命周期事件的监听器们是何时被加载实例化的呢？根据之前的分析SpringApplication的构建过程吗？这些执行初始化逻辑的监听器们正是在SpringApplication的构建过程中根据ApplicationListener接口去spring.factories配置文件中加载并实例化的。 1.1 为广播SpringBoot内置生命周期事件做前期准备1.1.1 加载ApplicationListener监听器实现类前面分析到，在构建SpringApplication对象时的setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));这句代码做的事情就是从spring.factories中加载出ApplicationListener事件监听接口的SPI扩展实现类然后添加到SpringApplication对象的listeners集合中，用于后续监听SpringBoot启动过程中的事件，来执行一些初始化逻辑工作。 SpringBoot启动时的具体监听器们都实现了ApplicationListener接口，其在spring.factories部分配置如下： spring-boot-2.1.0.RELEASE\spring-boot-project\spring-boot\src\main\resources\META-INF\spring.factories 1234567891011# Application Listenersorg.springframework.context.ApplicationListener=\org.springframework.boot.ClearCachesApplicationListener,\org.springframework.boot.builder.ParentContextCloserApplicationListener,\org.springframework.boot.context.FileEncodingApplicationListener,\org.springframework.boot.context.config.AnsiOutputApplicationListener,\org.springframework.boot.context.config.ConfigFileApplicationListener,\org.springframework.boot.context.config.DelegatingApplicationListener,\org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\org.springframework.boot.context.logging.LoggingApplicationListener,\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener 1.1.2 加载SPI扩展类EventPublishingRunListener前面讲到，在SpringBoot的启动过程中首先会先新建一个SpringApplicationRunListeners对象用于触发SpringBoot启动过程中的生命周期事件，来看下SpringApplicationRunListeners listeners = getRunListeners(args);这句代码： 12345678private SpringApplicationRunListeners getRunListeners(String[] args) &#123; // 构造一个由SpringApplication.class和String[].class组成的types Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; // 1) 根据SpringApplicationRunListener接口去spring.factories配置文件中加载其SPI扩展实现类 // 2) 构建一个SpringApplicationRunListeners对象并返回 return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));&#125; 将重点放到getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args)这句代码，getSpringFactoriesInstances这个方法在之前分析SpringBoot的SPI机制时已经详细分析过。可以看到SpringBoot此时又是根据SpringApplicationRunListener这个SPI接口去spring.factories中加载相应的SPI扩展实现类，直接去spring.factories中看看SpringApplicationRunListener有哪些SPI实现类： 123# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\org.springframework.boot.context.event.EventPublishingRunListener 可以看到，SpringApplicationRunListener只有EventPublishingRunListener这个SPI实现类。 EventPublishingRunListener在SpringBoot启动过程的不同阶段触发不同的SpringBoot的生命周期事件，即SpringApplicationRunListeners对象没有承担广播事件的职责，而最终是委托EventPublishingRunListener来广播事件的。 因为从spring.factories中加载EventPublishingRunListener类后还会实例化该类，那么再跟进EventPublishingRunListener的源码，看看其是如何承担触发SpringBoot生命周期事件这一职责的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123; private final SpringApplication application; private final String[] args; //拥有一个SimpleApplicationEventMulticaster事件广播器来广播事件 private final SimpleApplicationEventMulticaster initialMulticaster; public EventPublishingRunListener(SpringApplication application, String[] args) &#123; this.application = application; this.args = args; // 新建一个事件广播器SimpleApplicationEventMulticaster对象 this.initialMulticaster = new SimpleApplicationEventMulticaster(); // 遍历在构造SpringApplication对象时从spring.factories配置文件中获取的事件监听器 for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123; // 将从spring.factories配置文件中获取的事件监听器们添加到事件广播器initialMulticaster对象的相关集合中 this.initialMulticaster.addApplicationListener(listener); &#125; &#125; @Override public int getOrder() &#123; return 0; &#125; // 》》》》》触发【ApplicationStartingEvent】事件 @Override public void starting() &#123; this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args)); &#125; // 》》》》》触发【ApplicationEnvironmentPreparedEvent】事件 @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; this.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment)); &#125; // 》》》》》触发【ApplicationContextInitializedEvent】事件 @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; this.initialMulticaster.multicastEvent(new ApplicationContextInitializedEvent(this.application, this.args, context)); &#125; // 》》》》》触发【ApplicationPreparedEvent】事件 @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; for (ApplicationListener&lt;?&gt; listener : this.application.getListeners()) &#123; if (listener instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) listener).setApplicationContext(context); &#125; context.addApplicationListener(listener); &#125; this.initialMulticaster.multicastEvent(new ApplicationPreparedEvent(this.application, this.args, context)); &#125; // 》》》》》触发【ApplicationStartedEvent】事件 @Override public void started(ConfigurableApplicationContext context) &#123; context.publishEvent(new ApplicationStartedEvent(this.application, this.args, context)); &#125; // 》》》》》触发【ApplicationReadyEvent】事件 @Override public void running(ConfigurableApplicationContext context) &#123; context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context)); &#125; // 》》》》》触发【ApplicationFailedEvent】事件 @Override public void failed(ConfigurableApplicationContext context, Throwable exception) &#123; ApplicationFailedEvent event = new ApplicationFailedEvent(this.application, this.args, context, exception); if (context != null &amp;&amp; context.isActive()) &#123; // Listeners have been registered to the application context so we should // use it at this point if we can context.publishEvent(event); &#125; else &#123; // An inactive context may not have a multicaster so we use our multicaster to // call all of the context&#x27;s listeners instead if (context instanceof AbstractApplicationContext) &#123; for (ApplicationListener&lt;?&gt; listener : ((AbstractApplicationContext) context).getApplicationListeners()) &#123; this.initialMulticaster.addApplicationListener(listener); &#125; &#125; this.initialMulticaster.setErrorHandler(new LoggingErrorHandler()); this.initialMulticaster.multicastEvent(event); &#125; &#125; private static class LoggingErrorHandler implements ErrorHandler &#123; private static Log logger = LogFactory.getLog(EventPublishingRunListener.class); @Override public void handleError(Throwable throwable) &#123; logger.warn(&quot;Error calling ApplicationEventListener&quot;, throwable); &#125; &#125;&#125; 可以看到EventPublishingRunListener类实现了SpringApplicationRunListener接口，SpringApplicationRunListener接口定义了SpringBoot启动时触发生命周期事件的接口方法，而EventPublishingRunListener类正是通过实现SpringApplicationRunListener接口的starting,environmentPrepared和contextPrepared等方法来广播SpringBoot不同的生命周期事件，直接看下SpringApplicationRunListener接口源码好了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public interface SpringApplicationRunListener &#123; /** * Called immediately when the run method has first started. Can be used for very * early initialization. */ void starting(); /** * Called once the environment has been prepared, but before the * &#123;@link ApplicationContext&#125; has been created. * @param environment the environment */ void environmentPrepared(ConfigurableEnvironment environment); /** * Called once the &#123;@link ApplicationContext&#125; has been created and prepared, but * before sources have been loaded. * @param context the application context */ void contextPrepared(ConfigurableApplicationContext context); /** * Called once the application context has been loaded but before it has been * refreshed. * @param context the application context */ void contextLoaded(ConfigurableApplicationContext context); /** * The context has been refreshed and the application has started but * &#123;@link CommandLineRunner CommandLineRunners&#125; and &#123;@link ApplicationRunner * ApplicationRunners&#125; have not been called. * @param context the application context. * @since 2.0.0 */ void started(ConfigurableApplicationContext context); /** * Called immediately before the run method finishes, when the application context has * been refreshed and all &#123;@link CommandLineRunner CommandLineRunners&#125; and * &#123;@link ApplicationRunner ApplicationRunners&#125; have been called. * @param context the application context. * @since 2.0.0 */ void running(ConfigurableApplicationContext context); /** * Called when a failure occurs when running the application. * @param context the application context or &#123;@code null&#125; if a failure occurred before * the context was created * @param exception the failure * @since 2.0.0 */ void failed(ConfigurableApplicationContext context, Throwable exception);&#125; 再接着分析EventPublishingRunListener这个类，可以看到其有一个重要的成员属性initialMulticaster，该成员属性是SimpleApplicationEventMulticaster类对象，该类正是承担了广播SpringBoot启动时生命周期事件的职责,即EventPublishingRunListener对象没有承担广播事件的职责，而最终是委托SimpleApplicationEventMulticaster来广播事件的。 从EventPublishingRunListener的源码中也可以看到在starting,environmentPrepared和contextPrepared等方法中也正是通过调用SimpleApplicationEventMulticaster类对象的multicastEvent方法来广播事件的。 思考 SpringBoot启动过程中触发事件时事件广播者是层层委托职责的，起初由SpringApplicationRunListeners对象承担，然后SpringApplicationRunListeners对象将广播事件职责委托给EventPublishingRunListener对象，最终EventPublishingRunListener对象将广播事件的职责委托给SimpleApplicationEventMulticaster对象。为什么要层层委托这么做呢？ 前面讲到从spring.factories中加载出EventPublishingRunListener类后会实例化，而实例化必然会通过EventPublishingRunListener的构造函数来进行实例化，接下来分析下EventPublishingRunListener的构造函数源码： 1234567891011public EventPublishingRunListener(SpringApplication application, String[] args) &#123; this.application = application; this.args = args; // 新建一个事件广播器SimpleApplicationEventMulticaster对象 this.initialMulticaster = new SimpleApplicationEventMulticaster(); // 遍历在构造SpringApplication对象时从spring.factories配置文件中获取的事件监听器 for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123; // 将从spring.factories配置文件中获取的事件监听器们添加到事件广播器initialMulticaster对象的相关集合中 this.initialMulticaster.addApplicationListener(listener); &#125;&#125; 可以看到在EventPublishingRunListener的构造函数中有一个for循环会遍历之前从spring.factories中加载的监听器们，然后添加到集合中缓存起来，用于以后广播各种事件时直接从这个集合中取出来即可，而不用再去spring.factories中加载，提高效率。 1.2 广播SpringBoot的内置生命周期事件从spring.factories配置文件中加载并实例化EventPublishingRunListener对象后，那么在SpringBoot的启动过程中会触发一系列SpringBoot内置的生命周期事件，从以上SpringBoot启动过程中的源码，可以看到在SpringBoot的启动过程中总共会触发7种不同类型的生命周期事件，来标志SpringBoot的不同启动阶段，同时，这些生命周期事件的监听器也会执行一些启动过程中的初始化逻辑。 以下是SpringBoot启动过程中要触发的事件类型，其中ApplicationFailedEvent在SpringBoot启动过程中遇到异常才会触发： ApplicationStartingEvent ApplicationEnvironmentPreparedEvent ApplicationContextInitializedEvent ApplicationPreparedEvent ApplicationStartedEvent ApplicationFailedEvent ApplicationReadyEvent 以listeners.starting();这句代码为例，看看EventPublishingRunListener对象触发事件的源码： 12345678public void starting() &#123; // 遍历listeners集合，这里实质取出的就是刚才从spring.factories中取出的SPI实现类EventPublishingRunListener // 而EventPublishingRunListener对象承担了SpringBoot启动过程中负责广播不同的生命周期事件 for (SpringApplicationRunListener listener : this.listeners) &#123; // 调用EventPublishingRunListener的starting方法来广播ApplicationStartingEvent事件 listener.starting(); &#125;&#125; 继续跟进listener.starting();的源码: 1234567// 》》》》》触发【ApplicationStartingEvent】事件@Overridepublic void starting() &#123; // EventPublishingRunListener对象将发布ApplicationStartingEvent这件事情委托给了initialMulticaster对象 // 调用initialMulticaster的multicastEvent方法来触发ApplicationStartingEvent事件 this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));&#125; 可以看到，EventPublishingRunListener对象将发布ApplicationStartingEvent这件事情委托给了SimpleApplicationEventMulticaster对象initialMulticaster,,而initialMulticaster对象最终会调用其multicastEvent方法来触发ApplicationStartingEvent事件。 2.SpringBoot的内置生命周期事件总结SpringBoot启动过程中要触发的各种生命周期事件 发布顺序 时间 用途 1 ApplicationStartingEvent 在SpringApplication启动时，在环境变量Environment或者容器ApplicationContext创建前触发，标志SpringApplication开始启动。 2 ApplicationEnvironmentPreparedEvent 当SpringApplication已经开始启动且环境变量Environment已经准备好时触发，标志环境变量已经准备好。 3 ApplicationContextInitializedEvent ApplicationContextInitializers的初始化方法已经被调用，即从spring.factories中加载的initializers已经执行ApplicationContext初始化逻辑但在bean定义加载前触发，标志ApplicationContext已经初始化完毕。 4 ApplicationPreparedEvent 在Spring容器刷新refresh前触发 5 ApplicationStartedEvent 在spring容器刷新后触发，但在调用ApplicationRunner和CommandLineRunner的run方法调用前触发，标志spring容器已经刷新，此时所有的bean实例等都已经加载了。 6 ApplicationReadyEvent 只要SpringApplication可以接收服务请求时即调用完ApplicationRunner和CommandLineRunner的run方法后触发，此时标志SpringApplication已经正在运行，即启动成功。 7 ApplicationFailedEvent 若SpringApplication未能成功启动时则会catch住异常发布ApplicationFailedEvent事件，标志ApplicationFailedEvent启动失败。 总结SpringBoot启动过程中会触发7种类型的生命周期事件，标志不同的启动阶段，然后相应的监听器会监听这些事件来执行一些初始化逻辑工作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(8)-SpringApplication对象的构建过程]]></title>
    <url>%2Fposts%2F2020-11-22-SpringBoot-Source-08%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringApplication对象的构建过程 上一篇分析了SpringBoot的启动流程，关键步骤总结： 构建SpringApplication对象，用于启动SpringBoot； 从spring.factories配置文件中加载EventPublishingRunListener对象用于在不同的启动阶段触发不同的生命周期事件； 准备环境变量，包括系统变量，环境变量，命令行参数及配置文件（比如application.properties）等； 创建容器ApplicationContext; 为第4步创建的容器对象做一些初始化工作，准备一些容器属性值等，同时调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等； 刷新容器，这一步至关重要，是重点中的重点，太多复杂逻辑在这里实现； 调用ApplicationRunner和CommandLineRunner的run方法，可以实现这两个接口在容器启动后来加载一些业务数据等; 在SpringBoot启动过程中，每个不同的启动阶段会分别触发不同的内置生命周期事件，然后相应的监听器会监听这些事件来执行一些初始化逻辑工作比如ConfigFileApplicationListener会监听onApplicationEnvironmentPreparedEvent事件来加载环境变量等。 1.SpringApplication对象的构建过程之前在讲解SpringBoot的启动流程中，有看到新建了一个SpringApplication对象用来启动SpringBoot项目。那么，就来看看SpringApplication对象的构建过程，同时分析下SpringBoot自己实现的SPI机制。 开始分析SpringApplication对象的构造过程，因为一个对象的构造无非就是在其构造函数里给它的一些成员属性赋值，很少包含其他额外的业务逻辑（当然有时候可能也会在构造函数里开启一些线程啥的）。那么，先来看下构造SpringApplication对象时需要用到的一些成员属性： 1234567891011121314151617//SpringBoot的启动类即包含main函数的主类private Set&lt;Class&lt;?&gt;&gt; primarySources;//包含main函数的主类private Class&lt;?&gt; mainApplicationClass;//资源加载器private ResourceLoader resourceLoader;//应用类型private WebApplicationType webApplicationType;//初始化器private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;//监听器private List&lt;ApplicationListener&lt;?&gt;&gt; listeners; 可以看到构建SpringApplication对象时主要是给上面代码中的六个成员属性赋值，接着来看SpringApplication对象的构造过程。 先回到上一篇文章讲解的构建SpringApplication对象的代码处: 1234public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; // 构建一个SpringApplication对象，并调用其run方法来启动 return new SpringApplication(primarySources).run(args);&#125; 跟进SpringApplication的构造函数中： 1234public SpringApplication(Class&lt;?&gt;... primarySources) &#123; // 继续调用SpringApplication另一个构造函数 this(null, primarySources);&#125; 继续跟进SpringApplication另一个构造函数： 123456789101112131415public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; // 【1】给resourceLoader属性赋值，注意传入的resourceLoader参数为null this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); // 【2】给primarySources属性赋值，传入的primarySources其实就是SpringApplication.run(MainApplication.class, args);中的MainApplication.class this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // 【3】给webApplicationType属性赋值，根据classpath中存在哪种类型的类来确定是哪种应用类型 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 【4】给initializers属性赋值，利用SpringBoot自定义的SPI从spring.factories中加载ApplicationContextInitializer接口的实现类并赋值给initializers属性 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 【5】给listeners属性赋值，利用SpringBoot自定义的SPI从spring.factories中加载ApplicationListener接口的实现类并赋值给listeners属性 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 【6】给mainApplicationClass属性赋值，即这里要推断哪个类调用了main函数，然后再赋值给mainApplicationClass属性，用于后面启动流程中打印一些日志。 this.mainApplicationClass = deduceMainApplicationClass();&#125; 可以看到构建SpringApplication对象时其实就是给前面讲的6个SpringApplication类的成员属性赋值而已，做一些初始化工作： 给resourceLoader属性赋值，resourceLoader属性，资源加载器，此时传入的resourceLoader参数为null； 给primarySources属性赋值，primarySources属性即SpringApplication.run(SpringBootSampleNikoApplication.class,args);中传入的SpringBootSampleNikoApplication.class，该类为SpringBoot项目的启动类，主要通过该类来扫描Configuration类加载bean； 给webApplicationType属性赋值，webApplicationType属性，代表应用类型，根据classpath存在的相应Application类来判断。因为后面要根据webApplicationType来确定创建哪种Environment对象和创建哪种ApplicationContext； 给initializers属性赋值，initializers属性为List&lt;ApplicationContextInitializer&lt;?&gt;&gt;集合，利用SpringBoot的SPI机制从spring.factories配置文件中加载，后面在初始化容器的时候会应用这些初始化器来执行一些初始化工作。SpringBoot自己实现的SPI机制比较重要； 给listeners属性赋值，listeners属性为List&lt;ApplicationListener&lt;?&gt;&gt;集合，同样利用利用SpringBoot的SPI机制从spring.factories配置文件中加载。因为SpringBoot启动过程中会在不同的阶段触发一些事件，所以这些加载的监听器们就是来监听SpringBoot启动过程中的一些生命周期事件的； 给mainApplicationClass属性赋值，mainApplicationClass属性表示包含main函数的类，即这里要推断哪个类调用了main函数，然后把这个类的全限定名赋值给mainApplicationClass属性，用于后面启动流程中打印一些日志。 1.1 推断项目应用类型接着分析构造SpringApplication对象的第【3】步WebApplicationType.deduceFromClasspath();这句代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public enum WebApplicationType &#123; /** * The application should not run as a web application and should not start an * embedded web server. */ NONE, /** * The application should run as a servlet-based web application and should start an * embedded servlet web server. */ SERVLET, /** * The application should run as a reactive web application and should start an * embedded reactive web server. */ REACTIVE; private static final String[] SERVLET_INDICATOR_CLASSES = &#123; &quot;javax.servlet.Servlet&quot;, &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; &#125;; private static final String WEBMVC_INDICATOR_CLASS = &quot;org.springframework.&quot; + &quot;web.servlet.DispatcherServlet&quot;; private static final String WEBFLUX_INDICATOR_CLASS = &quot;org.&quot; + &quot;springframework.web.reactive.DispatcherHandler&quot;; private static final String JERSEY_INDICATOR_CLASS = &quot;org.glassfish.jersey.servlet.ServletContainer&quot;; private static final String SERVLET_APPLICATION_CONTEXT_CLASS = &quot;org.springframework.web.context.WebApplicationContext&quot;; private static final String REACTIVE_APPLICATION_CONTEXT_CLASS = &quot;org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext&quot;; static WebApplicationType deduceFromClasspath() &#123; // 若classpath中不存在&quot;org.springframework.&quot; + &quot;web.servlet.DispatcherServlet&quot;和&quot;org.glassfish.jersey.servlet.ServletContainer&quot; // 则返回WebApplicationType.REACTIVE，表明是reactive应用 if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) &#123; return WebApplicationType.REACTIVE; &#125; // 若&#123; &quot;javax.servlet.Servlet&quot;,&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; &#125; // 都不存在在classpath，则说明是不是web应用 for (String className : SERVLET_INDICATOR_CLASSES) &#123; if (!ClassUtils.isPresent(className, null)) &#123; return WebApplicationType.NONE; &#125; &#125; // 最终返回普通的web应用 return WebApplicationType.SERVLET; &#125; ....&#125; 如上代码，根据classpath判断应用类型，即通过反射加载classpath判断指定的标志类存在与否来分别判断是Reactive应用，Servlet类型的web应用还是普通的应用。 1.2 推断哪个类调用了main函数分析构造SpringApplication对象的第【6】步this.mainApplicationClass = deduceMainApplicationClass();这句代码： 123456789101112131415161718private Class&lt;?&gt; deduceMainApplicationClass() &#123; try &#123; // 获取StackTraceElement对象数组stackTrace，StackTraceElement对象存储了调用栈相关信息（比如类名，方法名等） StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); // 遍历stackTrace数组 for (StackTraceElement stackTraceElement : stackTrace) &#123; // 若stackTraceElement记录的调用方法名等于main if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123; // 那么就返回stackTraceElement记录的类名即包含main函数的类名 return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null;&#125; 可以看到deduceMainApplicationClass方法的主要作用就是从StackTraceElement调用栈数组中获取哪个类调用了main方法，然后再返回赋值给mainApplicationClass属性，然后用于后面启动流程中打印一些日志。 2.SpringBoot的SPI机制原理SpringBoot没有使用Java的SPI机制，而是自定义实现了一套自己的SPI机制。SpringBoot利用自定义实现的SPI机制可以加载初始化器实现类，监听器实现类和自动配置类等等。如果要添加自动配置类或自定义监听器，那么很重要的一步就是在spring.factories中进行配置，然后才会被SpringBoot加载。 好了，那么接下来就来重点分析下SpringBoot是如何是实现自己的SPI机制的。 前面构造SpringApplication对象的第【4】步和第【5】步代码，因为第【4】步和第【5】步都是利用SpringBoot的SPI机制来加载扩展实现类，这里只分析第【4】步的setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));这句代码，看看getSpringFactoriesInstances方法中SpringBoot是如何实现自己的一套SPI来加载ApplicationContextInitializer初始化器接口的扩展实现类的？ 1234private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123; // 继续调用重载的getSpringFactoriesInstances方法进行加载 return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);&#125; 继续跟进重载的getSpringFactoriesInstances方法： 12345678910111213private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; // 【1】获得类加载器 ClassLoader classLoader = getClassLoader(); // Use names and ensure unique to protect against duplicates // 【2】将接口类型和类加载器作为参数传入loadFactoryNames方法，从spring.factories配置文件中进行加载接口实现类 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 【3】实例化从spring.factories中加载的接口实现类 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); // 【4】进行排序 AnnotationAwareOrderComparator.sort(instances); // 【5】返回加载并实例化好的接口实现类 return instances;&#125; 可以看到，SpringBoot自定义实现的SPI机制代码中最重要的是上面代码的【1】,【2】,【3】步，这3步下面分别进行重点分析。 2.1 获得类加载器Java的SPI机制默认是利用线程上下文类加载器去加载扩展类的，那么，SpringBoot自己实现的SPI机制又是利用哪种类加载器去加载spring.factories配置文件中的扩展实现类呢？ 分析第【1】步的ClassLoader classLoader = getClassLoader();这句代码： 12345678public ClassLoader getClassLoader() &#123; // 前面在构造SpringApplicaiton对象时，传入的resourceLoader参数是null，因此不会执行if语句里面的逻辑 if (this.resourceLoader != null) &#123; return this.resourceLoader.getClassLoader(); &#125; // 获取默认的类加载器 return ClassUtils.getDefaultClassLoader();&#125; 继续跟进getDefaultClassLoader方法： 12345678910111213141516171819202122232425262728// ClassUtils.javapublic static ClassLoader getDefaultClassLoader() &#123; ClassLoader cl = null; try &#123; // 【重点】获取线程上下文类加载器 cl = Thread.currentThread().getContextClassLoader(); &#125; catch (Throwable ex) &#123; // Cannot access thread context ClassLoader - falling back... &#125; // 这里的逻辑不会执行 if (cl == null) &#123; // No thread context class loader -&gt; use class loader of this class. cl = ClassUtils.class.getClassLoader(); if (cl == null) &#123; // getClassLoader() returning null indicates the bootstrap ClassLoader try &#123; cl = ClassLoader.getSystemClassLoader(); &#125; catch (Throwable ex) &#123; // Cannot access system ClassLoader - oh well, maybe the caller can live with null... &#125; &#125; &#125; // 返回刚才获取的线程上下文类加载器 return cl;&#125; 可以看到，原来SpringBoot的SPI机制中也是用线程上下文类加载器去加载spring.factories文件中的扩展实现类的！ 2.2 加载spring.factories配置文件中的SPI扩展类再来看下第【2】步中的SpringFactoriesLoader.loadFactoryNames(type, classLoader)这句代码是如何加载spring.factories配置文件中的SPI扩展类的？ 12345678// SpringFactoriesLoader.javapublic static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; // factoryClass即SPI接口，比如ApplicationContextInitializer,EnableAutoConfiguration等接口 String factoryClassName = factoryClass.getName(); // 【主线，重点关注】继续调用loadSpringFactories方法加载SPI扩展类 return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 继续跟进loadSpringFactories方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// SpringFactoriesLoader.java/** * The location to look for factories. * &lt;p&gt;Can be present in multiple JAR files. */public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; // 以classLoader作为键先从缓存中取，若能取到则直接返回 MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; // 若缓存中无记录，则去spring.factories配置文件中获取 try &#123; // 这里加载所有jar包中包含&quot;MATF-INF/spring.factories&quot;文件的url路径 Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); // 遍历urls路径，将所有spring.factories文件的键值对（key:SPI接口类名 value:SPI扩展类名） // 加载放到 result集合中 while (urls.hasMoreElements()) &#123; // 取出一条url URL url = urls.nextElement(); // 将url封装到UrlResource对象中 UrlResource resource = new UrlResource(url); // 利用PropertiesLoaderUtils的loadProperties方法将spring.factories文件键值对内容加载进Properties对象中 Properties properties = PropertiesLoaderUtils.loadProperties(resource); // 遍历刚加载的键值对properties对象 for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; // 取出SPI接口名 String factoryClassName = ((String) entry.getKey()).trim(); // 遍历SPI接口名对应的实现类即SPI扩展类 for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123; // SPI接口名作为key，SPI扩展类作为value放入result中 result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; // 以classLoader作为key，result作为value放入cache缓存 cache.put(classLoader, result); // 最终返回result对象 return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); &#125;&#125; 如上代码，loadSpringFactories方法主要做的事情就是利用之前获取的线程上下文类加载器将classpath中的所有spring.factories配置文件中所有SPI接口的所有扩展实现类给加载出来，然后放入缓存中。 注意，这里是一次性加载所有的SPI扩展实现类，所以之后根据SPI接口就直接从缓存中获取SPI扩展类了，就不用再次去spring.factories配置文件中获取SPI接口对应的扩展实现类了。比如之后的获取ApplicationListener,FailureAnalyzer和EnableAutoConfiguration接口的扩展实现类都直接从缓存中获取即可。 思考1： 这里为啥要一次性从spring.factories配置文件中获取所有的扩展类放入缓存中呢？而不是每次都是根据SPI接口去spring.factories配置文件中获取呢？ 思考2： 还记得之前讲的SpringBoot的自动配置源码时提到的AutoConfigurationImportFilter这个接口的作用吗？现在应该能更清楚的理解这个接口的作用了吧。 将所有的SPI扩展实现类加载出来后，此时再调用getOrDefault(factoryClassName, Collections.emptyList())方法根据SPI接口名去筛选当前对应的扩展实现类，比如这里传入的factoryClassName参数名为ApplicationContextInitializer接口，那么这个接口将会作为key从刚才缓存数据中取出ApplicationContextInitializer接口对应的SPI扩展实现类。从spring.factories中获取的ApplicationContextInitializer接口对应的所有SPI扩展实现类。 2.3 实例化从spring.factories中加载的SPI扩展类前面从spring.factories中获取到ApplicationContextInitializer接口对应的所有SPI扩展实现类后，此时会将这些SPI扩展类进行实例化。 再来看下前面的第【3】步的实例化代码：List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);。 123456789101112131415161718192021222324private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) &#123; // 新建instances集合，用于存储稍后实例化后的SPI扩展类对象 List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size()); // 遍历name集合，names集合存储了所有SPI扩展类的全限定名 for (String name : names) &#123; try &#123; // 根据全限定名利用反射加载类 Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader); // 断言刚才加载的SPI扩展类是否属于SPI接口类型 Assert.isAssignable(type, instanceClass); // 获得SPI扩展类的构造器 Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes); // 实例化SPI扩展类 T instance = (T) BeanUtils.instantiateClass(constructor, args); // 添加进instances集合 instances.add(instance); &#125; catch (Throwable ex) &#123; throw new IllegalArgumentException(&quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex); &#125; &#125; // 返回 return instances;&#125; 上面代码主要做的事情就是实例化SPI扩展类。 思考3： SpringBoot为何弃用Java的SPI而自定义了一套SPI？ 总结好了，知识点总结下： 分析了SpringApplication对象的构造过程； 分析了SpringBoot自己实现的一套SPI机制。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(7)-SpringBoot的启动流程]]></title>
    <url>%2Fposts%2F2020-11-21-SpringBoot-Source-07%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringBoot的启动流程 上一篇分析了SpringBoot内置的各种Starter的构建原理，关键点总结： spring-boot-starter-xxx起步依赖没有一行代码，而是直接或间接依赖了xxx-autoconfigure模块，而xxx-autoconfigure模块承担了spring-boot-starter-xxx起步依赖自动配置的实现； xxx-autoconfigure自动配置模块引入了一些可选依赖，这些可选依赖不会被传递到spring-boot-starter-xxx起步依赖中，这是起步依赖构建的关键点； spring-boot-starter-xxx起步依赖显式引入了一些对自动配置起作用的可选依赖，因此会触发 xxx-autoconfigure自动配置的逻辑（比如创建某些符合条件的配置bean）； 经过前面3步的准备，项目只要引入了某个起步依赖后，就可以开箱即用了，而不用手动去创建一些bean等。 1.编写一个SpringBoot启动类运行一个SpringBoot项目，引入相关Starter和相关依赖后，再编写一个启动类，然后在这个启动类标上@SpringBootApplication注解，然后就可以启动运行项目了，如下代码： 12345678@SpringBootApplicationpublic class SpringBootSampleNikoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSampleNikoApplication.class, args); &#125;&#125; 如上代码，在SpringBootSampleNikoApplication启动类上标注了@SpringBootApplication注解，然后在main函数中调用SpringApplication.run(SpringBootSampleNikoApplication.class, args);这句代码就完成了SpringBoot的启动流程，非常简单。 2.@SpringBootApplication来分析下标注在启动类上的@SpringBootApplication注解，直接上源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration// TODO 这两个排除过滤器TypeExcludeFilter和AutoConfigurationExcludeFilter暂不知道啥作用@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ // 等同于EnableAutoConfiguration注解的exclude属性 @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ // 等同于EnableAutoConfiguration注解的excludeName属性 @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default &#123;&#125;; /** * Base packages to scan for annotated components. Use &#123;@link #scanBasePackageClasses&#125; * for a type-safe alternative to String-based package names. * @return base packages to scan * @since 1.3.0 */ // 等同于ComponentScan注解的basePackages属性 @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;) String[] scanBasePackages() default &#123;&#125;; /** * Type-safe alternative to &#123;@link #scanBasePackages&#125; for specifying the packages to * scan for annotated components. The package of each class specified will be scanned. * &lt;p&gt; * Consider creating a special no-op marker class or interface in each package that * serves no purpose other than being referenced by this attribute. * @return base packages to scan * @since 1.3.0 */ // 等同于ComponentScan注解的basePackageClasses属性 @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125; 可以看到，@SpringBootApplication注解是一个组合注解，主要由@SpringBootConfiguration,@EnableAutoConfiguration和@ComponentScan这三个注解组合而成。 因此@SpringBootApplication注解主要作为一个配置类，能够触发包扫描和自动配置的逻辑，从而使得SpringBoot的相关bean被注册进Spring容器。 3.SpringBoot的怎样启动？SpringApplication类是用来启动SpringBoot项目的，可以在java的main方法中启动，目前知道这些就足够了。下面看下SpringApplication.run(SpringBootSampleNikoApplication.class, args);这句代码的源码： 12345// run方法是一个静态方法，用于启动SpringBootpublic static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123; // 继续调用静态的run方法 return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);&#125; 在上面的静态run方法里又继续调用另一个静态run方法： 1234public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; // 构建一个SpringApplication对象，并调用其run方法来启动 return new SpringApplication(primarySources).run(args);&#125; 可以看到构建了一个SpringApplication对象，然后再调用其run方法来启动SpringBoot项目。关于SpringApplication对象是如何构建的，后面再分析，现在直接来看下启动流程的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public ConfigurableApplicationContext run(String... args) &#123; // new 一个StopWatch用于统计run启动过程花了多少时间 StopWatch stopWatch = new StopWatch(); // 开始计时 stopWatch.start(); ConfigurableApplicationContext context = null; // exceptionReporters 集合用来存储异常报告器，用来报告SpringBoot启动过程的异常 Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 配置headless属性，即“java.awt.headless”属性，默认为ture // 其实是想设置该应用程序,即使没有检测到显示器,也允许其启动.对于服务器来说,是不需要显示器的,所以要这样设置. configureHeadlessProperty(); // 【1】从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners // EventPublishingRunListener 对象主要用来触发SpringBoot启动过程中内置的一些生命周期事件，标志每个不同启动阶段 SpringApplicationRunListeners listeners = getRunListeners(args); // 启动SpringApplicationRunListener的监听，表示SpringApplication开始启动。 // 》》》》》触发【ApplicationStartingEvent】事件 listeners.starting(); try &#123; // 创建ApplicationArguments对象，封装了args参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 【2】准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值， // JNDI属性值，以及配置文件（比如application.properties）等，注意这些环境变量是有优先级的 // 》》》》》触发【ApplicationEnvironmentPreparedEvent】事件 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 配置spring.beaninfo.ignore属性，默认为true，即跳过搜索BeanInfo classes. configureIgnoreBeanInfo(environment); // 【3】控制台打印SpringBoot的bannner标志 Banner printedBanner = printBanner(environment); // 【4】根据不同类型创建不同类型的spring applicationcontext容器 // 因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象 context = createApplicationContext(); // 【5】从spring.factories配置文件中加载异常报告期实例，这里加载的是FailureAnalyzers // 注意FailureAnalyzers的构造器要传入ConfigurableApplicationContext，因为要从context中获取beanFactory和environment // ConfigurableApplicationContext是AnnotationConfigServletWebServerApplicationContext的父接口 exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); // 【6】为刚创建的AnnotationConfigServletWebServerApplicationContext容器对象做一些初始化工作，准备一些容器属性值等 // 1）为AnnotationConfigServletWebServerApplicationContext的属性AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner设置environgment属性 // 2）根据情况对ApplicationContext应用一些相关的后置处理，比如设置resourceLoader属性等 // 3）在容器刷新前调用各个ApplicationContextInitializer的初始化方法，ApplicationContextInitializer是在构建SpringApplication对象时从spring.factories中加载的 // 4）》》》》》触发【ApplicationContextInitializedEvent】事件，标志context容器被创建且已准备好 // 5）从context容器中获取beanFactory，并向beanFactory中注册一些单例bean，比如applicationArguments，printedBanner // 6）TODO 加载bean到application context，注意这里只是加载了部分bean比如mainApplication这个bean，大部分bean应该是在AbstractApplicationContext.refresh方法中被加载？这里留个疑问先 // 7）》》》》》触发【ApplicationPreparedEvent】事件，标志Context容器已经准备完成 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 【7】刷新容器，这一步至关重要，以后会在分析Spring源码时详细分析，主要做了以下工作： // 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等； // 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样 // 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等 // 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置 // 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化 // 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器： // BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前） // 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的 // 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等 // 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中 // 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器 // 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events // 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。 // 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件 refreshContext(context); // 【8】执行刷新容器后的后置处理逻辑，注意这里为空方法 afterRefresh(context, applicationArguments); // 停止stopWatch计时 stopWatch.stop(); // 打印日志 if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; // 》》》》》触发【ApplicationStartedEvent】事件，标志spring容器已经刷新，此时所有的bean实例都已经加载完毕 listeners.started(context); // 【9】调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西比如加载一些业务数据等 callRunners(context, applicationArguments); &#125; // 【10】若启动过程中抛出异常，此时用FailureAnalyzers来报告异常 // 并》》》》》触发【ApplicationFailedEvent】事件，标志SpringBoot启动失败 catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; // 》》》》》触发【ApplicationReadyEvent】事件，标志SpringApplication已经正在运行即已经成功启动，可以接收服务请求了。 listeners.running(context); &#125; // 若出现异常，此时仅仅报告异常，而不会触发任何事件 catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; // 【11】最终返回容器 return context;&#125; 如上代码就是SpringBoot的启动流程了，主要步骤也已经标注【x】，主要步骤总结： 从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来触发内置的生命周期事件; 准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等; 控制台打印SpringBoot的bannner标志； 根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象； 从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常； 为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等； 刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释； 执行刷新容器后的后置处理逻辑，注意这里为空方法； 调用ApplicationRunner和CommandLineRunner的run方法，实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等; 报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常; 最终返回容器对象，这里调用方法没有声明对象来接收。 当然在SpringBoot启动过程中，每个不同的启动阶段会分别触发不同的内置生命周期事件，比如在准备environment前会触发ApplicationStartingEvent事件，在environment准备好后会触发ApplicationEnvironmentPreparedEvent事件，在刷新容器前会触发ApplicationPreparedEvent事件等，总之SpringBoot总共内置了7个生命周期事件，除了标志SpringBoot的不同启动阶段外，同时一些监听器也会监听相应的生命周期事件从而执行一些启动初始化逻辑。 总结好了，SpringBoot的启动流程就已经分析完了，这篇内容主要对SpringBoot的启动流程有一个整体的认识。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(6)-SpringBoot内置的Starter构建原理]]></title>
    <url>%2Fposts%2F2020-11-20-SpringBoot-Source-06%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringBoot内置的Starter构建原理 上一篇分析了SpringBoot外部配置属性值是如何被绑定到XxxProperties类属性上的相关源码，重要步骤总结： 首先是@EnableConfigurationProperties注解import了EnableConfigurationPropertiesImportSelector后置处理器； EnableConfigurationPropertiesImportSelector后置处理器又向Spring容器中注册了ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar这两个bean； 其中ConfigurationPropertiesBeanRegistrar向Spring容器中注册了XxxProperties类型的bean；ConfigurationPropertiesBindingPostProcessorRegistrar向Spring容器中注册了ConfigurationBeanFactoryMetadata和ConfigurationPropertiesBindingPostProcessor两个后置处理器； ConfigurationBeanFactoryMetadata后置处理器在初始化bean factory时将@Bean注解的元数据存储起来，以便在后续的外部配置属性绑定的相关逻辑中使用； ConfigurationPropertiesBindingPostProcessor后置处理器将外部配置属性值绑定到XxxProperties类属性的逻辑委托给ConfigurationPropertiesBinder对象，然后ConfigurationPropertiesBinder对象又最终将属性绑定的逻辑委托给Binder对象来完成。 可见，重要的是上面的第5步。 1.思考SpringBoot内置了各种Starter起步依赖，使用起来非常方便，大大减轻了我们的开发工作。有了Starter起步依赖，我们不用去考虑这个项目需要什么库，这个库的groupId和artifactId是什么？更不用担心引入这个版本的库后会不会跟其他依赖有没有冲突。 例如：现在开发一个web项目，只要引入spring-boot-starter-web这个起步依赖就可以了，不用考虑要引入哪些版本的哪些依赖了。以前还要考虑引入哪些依赖库，比如要引入spring-web和spring-webmvc依赖等；此外，还要考虑引入这些库的哪些版本才不会跟其他库冲突等问题。 由于起步依赖跟自动配置的关系是如影随形的关系，因此本篇先站在maven项目构建的角度来宏观分析下我们平时使用的SpringBoot内置的各种Starter是怎样构建的？ 2.Maven传递依赖的optional标签在分析SpringBoot内置的各种Starter构建原理前，先来认识下Maven的optional标签，因为这个标签起到至关重要的作用。Maven的optional标签表示可选依赖即不可传递的意思，下面直接举个例子来说明。 比如有A,B和C三个库，C依赖B，B依赖A。下面看下这三个库的pom.xml文件： A的pom.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;groupId&gt;com.ymbj&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; B的pom.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;groupId&gt;com.ymbj&lt;/groupId&gt; &lt;artifactId&gt;B&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--注意是可选依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.ymbj&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; C的pom.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;groupId&gt;com.ymbj&lt;/groupId&gt; &lt;artifactId&gt;C&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.ymbj&lt;/groupId&gt; &lt;artifactId&gt;B&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 上面三个A,B和C库的pom.xml可知，B库依赖A库，然后C库又依赖了B库，那么请想一下，Maven打包构建C库后，A库有没有被引进来？ 答案肯定是没有，因为B库引入A库依赖时使用了&lt;optional&gt;true&lt;/optional&gt;，即将Maven的optional标签值设为了true，此时C库再引入B库依赖时，A库是不会被引入到C库的。 同时跟Maven传递依赖有关的还有一个exclusions标签，这个表示将某个库的某个子依赖排除掉。 3.SpringBoot内置的各种Starter是怎样构建的先来看一下SpringBoot源码内部模块图： SpringBoot的Starter的构建的原理实质就是自动配置，因上图可以看到SpringBoot源码项目内部跟Starter及其自动配置有关的模块有四个：spring-boot-starters,spring-boot-actuator-autoconfigure,spring-boot-autoconfigure和spring-boot-test-autoconfigure。 那么，spring-boot-starters模块跟后面三个自动配置有关的模块xxx-autoconfigure模块的关系是怎样的呢？ 此时我们先来看看spring-boot-starters模块里面的结构是怎样的？ 可以看到spring-boot-starters模块包含了SpringBoot内置的各种starter：spring-boot-starter-xxx。由于SpringBoot内置的各种starter太多，以常用的spring-boot-starter-web起步依赖来分析。 首先看下spring-boot-starter-web模块内部结构： 可以看到spring-boot-starter-web模块里面只有.flattened-pom.xml和pom.xml文件，而没有任何代码！ 若要用到SpringBoot的web功能时引入spring-boot-starter-web起步依赖即可，而现在spring-boot-starter-web模块里面没有一行代码，那么spring-boot-starter-web究竟是如何构建的呢？会不会跟spring-boot-autoconfigure自动配置模块有关？ 此时就需要看下spring-boot-starter-web模块的pom.xml文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;$&#123;revision&#125;&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;name&gt;Spring Boot Web Starter&lt;/name&gt; &lt;description&gt;Starter for building web, including RESTful, applications using Spring MVC. Uses Tomcat as the default embedded container&lt;/description&gt; &lt;properties&gt; &lt;main.basedir&gt;$&#123;basedir&#125;/../../..&lt;/main.basedir&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以看到，spring-boot-starter-web模块依赖了spring-boot-starter,spring-boot-starter-tomcat,spring-web和spring-webmvc等模块，居然没有依赖spring-boot-autoconfigure自动配置模块! 由于spring-boot-starter-web模块肯定跟spring-boot-autoconfigure自动配置模块有关，所以spring-boot-starter-web模块肯定是间接依赖了spring-boot-autoconfigure自动配置模块。 spring-boot-starter模块是大部分spring-boot-starter-xxx模块依赖的基础模块，是核心的Starter，包括了自动配置，日志和YAML支持。关注下spring-boot-starter的pom.xml文件，看看是否依赖了spring-boot-autoconfigure自动配置模块。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;$&#123;revision&#125;&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;name&gt;Spring Boot Starter&lt;/name&gt; &lt;description&gt;Core starter, including auto-configuration support, logging and YAML&lt;/description&gt; &lt;properties&gt; &lt;main.basedir&gt;$&#123;basedir&#125;/../../..&lt;/main.basedir&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以看到，正是spring-boot-starter模块依赖了spring-boot-autoconfigure自动配置模块！因此，到了这里就可以得出结论了：spring-boot-starter-web模块没有一行代码，但是其通过spring-boot-starter模块间接依赖了spring-boot-autoconfigure自动配置模块，从而实现了其起步依赖的功能。 再来看下spring-boot-autoconfigure自动配置模块的内部包结构： 可以知道spring-boot-starter-web起步依赖的自动配置功能原来是由spring-boot-autoconfigure模块的web包下的类实现的。 到了这里spring-boot-starter-web起步依赖的构建基本原理就搞清楚了，但是还有一个特别重要的关键点我们还没分析。这个关键点跟Maven的optional标签有的作用有关。 思考一个问题：平时开发web项目为什么引入了spring-boot-starter-web这个起步依赖后，spring-boot-autoconfigure模块的web相关的自动配置类就会起自动起作用呢？ 某个自动配置类起作用往往是由于classpath中存在某个类，这里以DispatcherServletAutoConfiguration这个自动配置类为切入点去分析。 先看下DispatcherServletAutoConfiguration能够自动配置的条件是啥？ 1234567@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(DispatcherServlet.class)@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)public class DispatcherServletAutoConfiguration &#123;&#125; DispatcherServletAutoConfiguration能够自动配置的条件之一是@ConditionalOnClass(DispatcherServlet.class)，即只有classpath中存在DispatcherServlet.class这个类，那么DispatcherServletAutoConfiguration自动配置相关逻辑才能起作用。 而DispatcherServlet这个类是在spring-webmvc这个依赖库中的 再看下spring-boot-autoconfigure模块的pom.xml文件引入spring-webmvc这个依赖的情况： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; spring-boot-autoconfigure模块引入的spring-webmvc这个依赖时optional被设置为true，原来是可选依赖。即spring-webmvc这个依赖库只会被导入到spring-boot-autoconfigure模块中，而不会被导入到间接依赖spring-boot-autoconfigure模块的spring-boot-starter-web这个起步依赖中。 此时，再来看看spring-boot-starter-web的pom.xml文件的依赖情况： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web起步依赖显式引入了spring-webmvc这个依赖库，即引入spring-webmvc时没有optional这个标签，又因为DispatcherServlet这个类是在spring-webmvc这个依赖库中的,从而classpath中存在DispatcherServlet这个类，因此DispatcherServletAutoConfiguration这个自动配置类就生效了。当然，web相关的其他自动配置类生效也是这个原理。 至此，明白了spring-boot-autoconfigure模块为什么要把引入的spring-webmvc这个依赖作为可选依赖了，其目的就是为了在spring-boot-starter-web起步依赖中能显式引入spring-webmvc这个依赖（这个起决定性作用），从而开发web项目只要引入了spring-boot-starter-web起步依赖，那么web相关的自动配置类就生效，从而可以开箱即用​这个就是spring-boot-starter-web这个起步依赖的构建原理了。 前面提到的spring-boot-starter-actuator,spring-boot-starter-test及其他内置的spring-boot-starter-xxx的起步依赖的构建原理也是如此，只不过spring-boot-starter-actuator依赖的是spring-boot-actuator-autoconfigure，spring-boot-starter-test依赖的是spring-boot-test-autoconfigure模块罢了。 思考：spring-boot-actuator-autoconfigure的pom.xml文件引入了20多个可选依赖，而为什么spring-boot-starter-actuator起步依赖只引入了micrometer-core这个依赖呢？ 4.模仿SpringBoot包结构自定义一个Starter分析了SpringBoot内置的各种Starter的构建原理，我们可以自己动手实践一下自定义Starter。 自定义starter的demo资料： https://github.com/jinyue233/mock-spring-boot-autoconfiguration https://github.com/mybatis/spring-boot-starter 总结SpringBoot内置的各种Starter的构建原理分析就到此结束了，关键点总结： spring-boot-starter-xxx起步依赖没有一行代码，而是直接或间接依赖了xxx-autoconfigure模块，而xxx-autoconfigure模块承担了spring-boot-starter-xxx起步依赖自动配置的实现； xxx-autoconfigure自动配置模块引入了一些可选依赖，这些可选依赖不会被传递到spring-boot-starter-xxx起步依赖中，这是起步依赖构建的关键点； spring-boot-starter-xxx起步依赖显式引入了一些对自动配置起作用的可选依赖； 经过前面3步的准备，项目只要引入了某个起步依赖后，就可以开箱即用了，而不用手动去创建一些bean等。 参考资料 https://dayarch.top/p/maven-dependency-optional-transitive.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(5)-SpringBoot 的配置属性值的绑定流程]]></title>
    <url>%2Fposts%2F2020-11-19-SpringBoot-Source-05%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringBoot 的配置属性值的绑定流程 上一篇分析了SpringBoot的自动配置的相关源码，自动配置主要有以下几个重要的步骤： 从spring.factories配置文件中加载自动配置类； 加载的自动配置类中排除掉@EnableAutoConfiguration注解的exclude属性指定的自动配置类； 然后再用AutoConfigurationImportFilter接口去过滤自动配置类是否符合其标注注解（若有标注的话）@ConditionalOnClass,@ConditionalOnBean和@ConditionalOnWebApplication的条件，若都符合的话则返回匹配结果； 然后触发AutoConfigurationImportEvent事件，告诉ConditionEvaluationReport条件评估报告器对象来分别记录符合条件和exclude的自动配置类。 最后spring再将最后筛选后的自动配置类导入IOC容器中 继续来分析SpringBoot的自动配置的相关源码，我们来分析下@EnableConfigurationProperties和@ConfigurationProperties这两个注解，来探究下外部配置属性值是如何被绑定到@ConfigurationProperties注解的类属性中的？ Example：以配置web项目的服务器端口为例，若我们要将服务器端口配置为9999，那么需要在application.properties配置文件中配置server.port=9999，此时该配置值9999就将会绑定到被@ConfigurationProperties注解的类ServerProperties的属性port上，从而使得配置生效。 1.@EnableConfigurationProperties以前面的设置服务器端口的例子来分析，先直接来看看ServerProperties的源码，应该能找到源码的入口： 12345678910@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)public class ServerProperties &#123; /** * Server HTTP port. */ private Integer port; ...&#125; 可以看到，ServerProperties类上标注了@ConfigurationProperties这个注解，服务器属性配置前缀为server，是否忽略未知的配置值（ignoreUnknownFields）设置为true。 那么再来看下@ConfigurationProperties这个注解的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ConfigurationProperties &#123; /** * The name prefix of the properties that are valid to bind to this object. Synonym * for &#123;@link #prefix()&#125;. A valid prefix is defined by one or more words separated * with dots (e.g. &#123;@code &quot;acme.system.feature&quot;&#125;). * @return the name prefix of the properties to bind */ // 前缀别名 @AliasFor(&quot;prefix&quot;) String value() default &quot;&quot;; /** * The name prefix of the properties that are valid to bind to this object. Synonym * for &#123;@link #value()&#125;. A valid prefix is defined by one or more words separated with * dots (e.g. &#123;@code &quot;acme.system.feature&quot;&#125;). * @return the name prefix of the properties to bind */ // 前缀 @AliasFor(&quot;value&quot;) String prefix() default &quot;&quot;; /** * Flag to indicate that when binding to this object invalid fields should be ignored. * Invalid means invalid according to the binder that is used, and usually this means * fields of the wrong type (or that cannot be coerced into the correct type). * @return the flag value (default false) */ // 忽略无效的配置属性 boolean ignoreInvalidFields() default false; /** * Flag to indicate that when binding to this object unknown fields should be ignored. * An unknown field could be a sign of a mistake in the Properties. * @return the flag value (default true) */ // 忽略未知的配置属性 boolean ignoreUnknownFields() default true;&#125; @ConfigurationProperties这个注解的作用就是将外部配置的配置值绑定到其注解的类的属性上，可以作用于配置类或配置类的方法上。可以看到@ConfigurationProperties注解除了有设置前缀，是否忽略一些不存在或无效的配置等属性等外，这个注解没有其他任何的处理逻辑，可以看到@ConfigurationProperties是一个标志性的注解，源码入口不在这里。 这里讲的是服务器的自动配置，来看下自动配置类ServletWebServerFactoryAutoConfiguration的源码： 1234567891011@Configuration@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@ConditionalOnClass(ServletRequest.class)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(ServerProperties.class)@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)public class ServletWebServerFactoryAutoConfiguration &#123;&#125; 可以看到，ServletWebServerFactoryAutoConfiguration自动配置类中有一个@EnableConfigurationProperties注解，且注解值是前面讲的ServerProperties.class，因此@EnableConfigurationProperties注解肯定就是关注的重点了。 再来看下@EnableConfigurationProperties注解的源码： 123456789101112131415@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(EnableConfigurationPropertiesImportSelector.class)public @interface EnableConfigurationProperties &#123; /** * Convenient way to quickly register &#123;@link ConfigurationProperties&#125; annotated beans * with Spring. Standard Spring Beans will also be scanned regardless of this value. * @return &#123;@link ConfigurationProperties&#125; annotated beans to register */ // 这个值指定的类就是@ConfigurationProperties注解标注的类，其将会被注册到spring容器中 Class&lt;?&gt;[] value() default &#123;&#125;;&#125; @EnableConfigurationProperties注解的主要作用就是为@ConfigurationProperties注解标注的类提供支持，即对将外部配置属性值（比如application.properties配置值）绑定到@ConfigurationProperties标注的类的属性中。 SpringBoot源码中还存在了ConfigurationPropertiesAutoConfiguration这个自动配置类，同时spring.factories配置文件中的EnableAutoConfiguration接口也配置了ConfigurationPropertiesAutoConfiguration，这个自动配置类上也有@EnableConfigurationProperties这个注解，堆属性绑定进行了默认开启。 那么，@EnableConfigurationProperties这个注解对属性绑定提供怎样的支持呢？ 可以看到@EnableConfigurationProperties这个注解上还标注了@Import(EnableConfigurationPropertiesImportSelector.class)，其导入了EnableConfigurationPropertiesImportSelector，因此可以肯定的是@EnableConfigurationProperties这个注解对属性绑定提供的支持必定跟EnableConfigurationPropertiesImportSelector有关。 接下来分析EnableConfigurationPropertiesImportSelector，是如何承担将外部配置属性值绑定到@ConfigurationProperties标注的类的属性中的。 2.EnableConfigurationPropertiesImportSelectorEnableConfigurationPropertiesImportSelector类的作用主要用来处理外部属性绑定的相关逻辑，其实现了ImportSelector接口的selectImports方法可以向容器中注册bean。 那么，看下EnableConfigurationPropertiesImportSelector覆写的selectImports方法： 1234567891011121314class EnableConfigurationPropertiesImportSelector implements ImportSelector &#123; // IMPORTS数组即是要向spring容器中注册的bean private static final String[] IMPORTS = &#123; ConfigurationPropertiesBeanRegistrar.class.getName(), ConfigurationPropertiesBindingPostProcessorRegistrar.class.getName() &#125;; @Override public String[] selectImports(AnnotationMetadata metadata) &#123; // 返回ConfigurationPropertiesBeanRegistrar和 ConfigurationPropertiesBindingPostProcessorRegistrar的全限定名 // 即上面两个类将会被注册到Spring容器中 return IMPORTS; &#125;&#125; 可以看到EnableConfigurationPropertiesImportSelector类中的selectImports方法中返回的是IMPORTS数组，而这个IMPORTS是一个常量数组，值是ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar。即EnableConfigurationPropertiesImportSelector的作用是向Spring容器中注册了ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar这两个bean。 在EnableConfigurationPropertiesImportSelector类中没看到处理外部属性绑定的相关逻辑，其只是注册了ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar这两个bean,接下来我们再看下注册的这两个bean类。 2.1 ConfigurationPropertiesBeanRegistrar先来看下ConfigurationPropertiesBeanRegistrar这个类的源码： 1234567891011121314public static class ConfigurationPropertiesBeanRegistrar implements ImportBeanDefinitionRegistrar &#123; // metadata是 AnnotationMetadata 对象，存储了某个配置类的元数据 @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; // （1）得到 @EnableConfigurationProperties注解的所有属性值, // 比如 @EnableConfigurationProperties(ServerProperties.class),那么得到的值是ServerProperties.class // （2）然后再将得到的@EnableConfigurationProperties注解的所有属性值注册到容器中 getTypes(metadata).forEach((type) -&gt; register(registry, (ConfigurableListableBeanFactory) registry, type)); &#125; ...&#125; ConfigurationPropertiesBeanRegistrar是EnableConfigurationPropertiesImportSelector的内部类，其实现了ImportBeanDefinitionRegistrar接口，覆写了registerBeanDefinitions方法。可见，ConfigurationPropertiesBeanRegistrar又是用来注册一些bean definition的，即也是向Spring容器中注册一些bean。 在ConfigurationPropertiesBeanRegistrar实现的registerBeanDefinitions中，可以看到主要做了两件事： 调用getTypes方法获取@EnableConfigurationProperties注解的属性值XxxProperties； 调用register方法将获取的属性值XxxProperties注册到Spring容器中，用于以后和外部属性绑定时使用。 来看下getTypes方法的源码： 123456789private List&lt;Class&lt;?&gt;&gt; getTypes(AnnotationMetadata metadata) &#123; // 得到 @EnableConfigurationProperties注解的所有属性值, // 比如 @EnableConfigurationProperties(ServerProperties.class),那么得到的值是ServerProperties.class MultiValueMap&lt;String, Object&gt; attributes = metadata .getAllAnnotationAttributes( EnableConfigurationProperties.class.getName(), false); // 将属性值取出装进List集合并返回 return collectClasses((attributes != null) ? attributes.get(&quot;value&quot;) : Collections.emptyList());&#125; getTypes方法里面的逻辑很简单，即将@EnableConfigurationProperties注解里面的属性值XxxProperties（比如ServerProperties.class）取出并装进List集合并返回。 由getTypes方法拿到@EnableConfigurationProperties注解里面的属性值XxxProperties（比如ServerProperties.class）后，此时再遍历将XxxProperties逐个注册进Spring容器中，来看下register方法： 12345678910private void register(BeanDefinitionRegistry registry, ConfigurableListableBeanFactory beanFactory, Class&lt;?&gt; type) &#123; // 得到type的名字，一般用类的全限定名作为bean name String name = getName(type); // 根据bean name判断beanFactory容器中是否包含该bean if (!containsBeanDefinition(beanFactory, name)) &#123; // 若不包含，那么注册bean definition registerBeanDefinition(registry, name, type); &#125;&#125; 2.2 ConfigurationPropertiesBindingPostProcessorRegistrar可以看到ConfigurationPropertiesBindingPostProcessorRegistrar类名字又是以Registrar单词为结尾，说明其肯定又是导入一些bean definition的。直接看源码： 12345678910111213141516171819202122232425262728293031323334353637383940public class ConfigurationPropertiesBindingPostProcessorRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 若容器中没有注册ConfigurationPropertiesBindingPostProcessor这个处理属性绑定的后置处理器， // 那么将注册ConfigurationPropertiesBindingPostProcessor和ConfigurationBeanFactoryMetadata这两个bean // 注意onApplicationEnvironmentPreparedEvent事件加载配置属性在先，然后再注册一些后置处理器用来处理这些配置属性 if (!registry.containsBeanDefinition(ConfigurationPropertiesBindingPostProcessor.BEAN_NAME)) &#123; // (1)注册ConfigurationPropertiesBindingPostProcessor后置处理器，用来对配置属性进行后置处理 registerConfigurationPropertiesBindingPostProcessor(registry); // (2)注册一个ConfigurationBeanFactoryMetadata类型的bean， // 注意ConfigurationBeanFactoryMetadata实现了BeanFactoryPostProcessor，然后其会在postProcessBeanFactory中注册一些元数据 registerConfigurationBeanFactoryMetadata(registry); &#125; &#125; // 注册ConfigurationPropertiesBindingPostProcessor后置处理器 private void registerConfigurationPropertiesBindingPostProcessor( BeanDefinitionRegistry registry) &#123; GenericBeanDefinition definition = new GenericBeanDefinition(); definition.setBeanClass(ConfigurationPropertiesBindingPostProcessor.class); definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition( ConfigurationPropertiesBindingPostProcessor.BEAN_NAME, definition); &#125; // 注册ConfigurationBeanFactoryMetadata后置处理器 private void registerConfigurationBeanFactoryMetadata( BeanDefinitionRegistry registry) &#123; GenericBeanDefinition definition = new GenericBeanDefinition(); definition.setBeanClass(ConfigurationBeanFactoryMetadata.class); definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(ConfigurationBeanFactoryMetadata.BEAN_NAME, definition); &#125;&#125; ConfigurationPropertiesBindingPostProcessorRegistrar类的逻辑非常简单，主要用来注册外部配置属性绑定相关的后置处理器即ConfigurationBeanFactoryMetadata和ConfigurationPropertiesBindingPostProcessor。 那么接下来再来探究下注册的这两个后置处理器又是执行怎样的后置处理逻辑呢？ 2.2.1 ConfigurationBeanFactoryMetadata先来看下ConfigurationBeanFactoryMetadata类源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ConfigurationBeanFactoryMetadata implements BeanFactoryPostProcessor &#123; /** * The bean name that this class is registered with. */ public static final String BEAN_NAME = ConfigurationBeanFactoryMetadata.class.getName(); private ConfigurableListableBeanFactory beanFactory; /** * beansFactoryMetadata集合存储beansFactory的元数据 * key:某个bean的名字 value：FactoryMetadata对象（封装了工厂bean名和工厂方法名） * 比如下面这个配置类： * * @Configuration * public class ConfigA &#123; * @Bean * public BeanXXX methodB（configA, ） &#123; * return new BeanXXX(); * &#125; * &#125; * * 那么：key值为&quot;methodB&quot;，value为FactoryMetadata（configA, methodB）对象，其bean属性值为&quot;configA&quot;,method属性值为&quot;methodB&quot; */ private final Map&lt;String, FactoryMetadata&gt; beansFactoryMetadata = new HashMap&lt;&gt;(); @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; this.beanFactory = beanFactory; // 遍历beanFactory的beanDefinitionName，即每个bean的名字（比如工厂方法对应的bean名字） for (String name : beanFactory.getBeanDefinitionNames()) &#123; // 根据name得到beanDefinition BeanDefinition definition = beanFactory.getBeanDefinition(name); // 工厂方法名：一般是注解@Bean的方法名 String method = definition.getFactoryMethodName(); // 工厂bean名：一般是注解@Configuration的类名 String bean = definition.getFactoryBeanName(); if (method != null &amp;&amp; bean != null) &#123; // 将beanDefinitionName作为Key，封装了工厂bean名和工厂方法名的FactoryMetadata对象作为value装入beansFactoryMetadata中 this.beansFactoryMetadata.put(name, new FactoryMetadata(bean, method)); &#125; &#125; &#125;&#125; ConfigurationBeanFactoryMetadata这个后置处理器，其实现了BeanFactoryPostProcessor接口的postProcessBeanFactory方法，在初始化bean factory时将@Bean注解的元数据存储起来，以便在后续的外部配置属性绑定的相关逻辑中使用。 从上面代码可以看到ConfigurationBeanFactoryMetadata类覆写的postProcessBeanFactory方法做的事情就是将工厂Bean（可以理解为@Configuration注解的类）及其@Bean注解的工厂方法的一些元数据缓存到beansFactoryMetadata集合中，以便后续使用。 由上代码中我们看到了ConfigurationBeanFactoryMetadata类的beansFactoryMetadata集合类型是Map&lt;String, FactoryMetadata&gt;，那么我们再来看下封装相关工厂元数据的FactoryMetadata类： 123456789101112131415161718192021private static class FactoryMetadata &#123; // @Configuration注解的配置类的类名 private final String bean; // @Bean注解的方法名 private final String method; FactoryMetadata(String bean, String method) &#123; this.bean = bean; this.method = method; &#125; public String getBean() &#123; return this.bean; &#125; public String getMethod() &#123; return this.method; &#125;&#125; FactoryMetadata仅有两个属性bean和method，分别表示@Configuration注解的工厂bean和@Bean注解的工厂方法。 例如： 12345678910111213141516/** * beansFactoryMetadata集合存储beansFactory的元数据 * key:某个bean的名字 value：FactoryMetadata对象（封装了工厂bean名和工厂方法名） * 比如下面这个配置类： * * @Configuration * public class ConfigA &#123; * @Bean * public BeanXXX methodB（configA, ） &#123; * return new BeanXXX(); * &#125; * &#125; * * 那么：key值为&quot;methodB&quot;，value为FactoryMetadata（configA, methodB）对象，其bean属性值为&quot;configA&quot;,method属性值为&quot;methodB&quot; */ private final Map&lt;String, FactoryMetadata&gt; beansFactoryMetadata = new HashMap&lt;&gt;(); 为了更好理解上面beansFactoryMetadata集合存储的数据是啥，最好动手调试看看里面装的是什么。总之这里记住一点就好了：ConfigurationBeanFactoryMetadata类的beansFactoryMetadata集合存储的是工厂bean的相关元数据，以便在ConfigurationPropertiesBindingPostProcessor后置处理器中使用。 2.2.2 ConfigurationPropertiesBindingPostProcessor再来看下ConfigurationPropertiesBindingPostProcessorRegistrar类注册的另外一个后置处理器ConfigurationPropertiesBindingPostProcessor，这个后置处理器主要承担了将外部配置属性绑定到@ConfigurationProperties注解标注的XxxProperties类的属性中（比如application.properties配置文件中设置了server.port=9999,那么9999将会绑定到ServerProperties类的port属性中）的实现逻辑。 先来看下ConfigurationPropertiesBindingPostProcessor的源码： 1234567891011121314public class ConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor, PriorityOrdered, ApplicationContextAware, InitializingBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; // ...这里省略实现代码先 &#125; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) &#123; // ...这里省略实现代码先 &#125; // ...省略非关键代码&#125; 可以看到ConfigurationPropertiesBindingPostProcessor后置处理器实现了两个重要的接口InitializingBean和BeanPostProcessor。 InitializingBean接口的afterPropertiesSet方法会在bean属性赋值后调用，用来执行一些自定义的初始化逻辑比如检查某些强制的属性是否有被赋值，校验某些配置或给一些未被赋值的属性赋值。 BeanPostProcessor接口是bean的后置处理器，其有postProcessBeforeInitialization和postProcessAfterInitialization两个勾子方法，分别会在bean初始化前后被调用来执行一些后置处理逻辑，比如检查标记接口或是否用代理包装了bean。 同时以上代码可以看到ConfigurationPropertiesBindingPostProcessor后置处理器覆写了InitializingBean的afterPropertiesSet方法和BeanPostProcessor的postProcessBeforeInitialization方法。 接下来再来探究ConfigurationPropertiesBindingPostProcessor后置处理器覆写的两个方法的源码。 2.2.2.1 在执行外部属性绑定逻辑前先准备好相关元数据和配置属性绑定器先来分析下ConfigurationPropertiesBindingPostProcessor覆写InitializingBean接口的afterPropertiesSet方法： 12345678910111213141516// 这里主要是给 beanFactoryMetadata 和 configurationPropertiesBinder 的属性赋值，用于后面的后置处理器方法处理属性绑定的时候用@Overridepublic void afterPropertiesSet() throws Exception &#123; // We can&#x27;t use constructor injection of the application context because // it causes eager factory bean initialization // 【1】利用afterPropertiesSet这个勾子方法从容器中获取之前注册的ConfigurationBeanFactoryMetadata对象赋给beanFactoryMetadata属性 // （问1）beanFactoryMetadata这个bean是什么时候注册到容器中的？ // （答1）在ConfigurationPropertiesBindingPostProcessorRegistrar类的registerBeanDefinitions方法中将beanFactoryMetadata这个bean注册到容器中 // （问2）从容器中获取beanFactoryMetadata对象后，什么时候会被用到？ // （答2）beanFactoryMetadata对象的beansFactoryMetadata集合保存的工厂bean相关的元数据，在ConfigurationPropertiesBindingPostProcessor类 // 要判断某个bean是否有FactoryAnnotation或FactoryMethod时会根据这个beanFactoryMetadata对象的beansFactoryMetadata集合的元数据来查找 this.beanFactoryMetadata = this.applicationContext.getBean(ConfigurationBeanFactoryMetadata.BEAN_NAME, ConfigurationBeanFactoryMetadata.class); // 【2】new一个ConfigurationPropertiesBinder，用于后面的外部属性绑定时使用 // VALIDATOR_BEAN_NAME=&quot;configurationPropertiesValidator&quot; this.configurationPropertiesBinder = new ConfigurationPropertiesBinder(this.applicationContext, VALIDATOR_BEAN_NAME);&#125; 可以看到以上代码主要逻辑就是在执行外部属性绑定逻辑前先准备好相关元数据和配置属性绑定器，即从Spring容器中获取到之前注册的ConfigurationBeanFactoryMetadata对象赋给ConfigurationPropertiesBindingPostProcessor后置处理器的beanFactoryMetadata属性,还有就是新建一个ConfigurationPropertiesBinder配置属性绑定器对象并赋值给configurationPropertiesBinder属性。 再来看下ConfigurationPropertiesBinder这个配置属性绑定器对象是如何构造的。 12345678910ConfigurationPropertiesBinder(ApplicationContext applicationContext, String validatorBeanName) &#123; this.applicationContext = applicationContext; // 将applicationContext封装到PropertySourcesDeducer对象中并返回 // 获取属性源，主要用于在ConfigurableListableBeanFactory的后置处理方法postProcessBeanFactory中处理 this.propertySources = new PropertySourcesDeducer(applicationContext).getPropertySources(); // 如果没有配置validator的话，这里一般返回的是null this.configurationPropertiesValidator = getConfigurationPropertiesValidator(applicationContext, validatorBeanName); // 检查实现JSR-303规范的bean校验器相关类在classpath中是否存在 this.jsr303Present = ConfigurationPropertiesJsr303Validator.isJsr303Present(applicationContext);&#125; 可以看到在构造ConfigurationPropertiesBinder对象时主要给其相关属性赋值（一般构造器逻辑都是这样）： 给applicationContext属性赋值注入上下文对象； 给propertySources属性赋值，属性源即外部配置值比如application.properties配置的属性值，注意这里的属性源是由ConfigFileApplicationListener这个监听器负责读取的。 给configurationPropertiesValidator属性赋值，值来自Spring容器中名为configurationPropertiesValidator的bean。 给jsr303Present属性赋值，当javax.validation.Validator,javax.validation.ValidatorFactory和javax.validation.bootstrap.GenericBootstrap&quot;这三个类同时存在于classpath中jsr303Present属性值才为true。 关于JSR303：JSR-303是JAVA EE 6中的一项子规范，叫做Bean Validation，Hibernate Validator是Bean Validation的参考实现 。Hibernate Validator提供了JSR 303规范中所有内置constraint 的实现，除此之外还有一些附加的constraint。 2.2.2.2 执行真正的外部属性绑定逻辑【主线】前面分析了那么多，发现都还没到外部属性绑定的真正处理逻辑，前面步骤都是在做一些准备性工作，为外部属性绑定做铺垫。 在执行外部属性绑定逻辑前，准备好了相关元数据和配置属性绑定器后，此时再来看看ConfigurationPropertiesBindingPostProcessor实现BeanPostProcessor接口的postProcessBeforeInitialization后置处理方法了，外部属性绑定逻辑都是在这个后置处理方法里实现。 直接看代码： 12345678910111213141516// 因为是外部配置属性后置处理器，因此这里对@ConfigurationProperties注解标注的XxxProperties类进行后置处理完成属性绑定@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; // 注意，BeanPostProcessor后置处理器默认会对所有的bean进行处理，因此需要根据bean的一些条件进行过滤得到最终要处理的目的bean， // 这里的过滤条件就是判断某个bean是否有@ConfigurationProperties注解 // 【1】从bean上获取@ConfigurationProperties注解,若bean有标注，那么返回该注解；若没有，则返回Null。 // 比如ServerProperty上标注了@ConfigurationProperties注解 ConfigurationProperties annotation = getAnnotation(bean, beanName, ConfigurationProperties.class); // 【2】若标注有@ConfigurationProperties注解的bean，那么则进行进一步处理：将配置文件的配置注入到bean的属性值中 if (annotation != null) &#123; /********主线，重点关注】********/ bind(bean, beanName, annotation); &#125; // 【3】返回外部配置属性值绑定后的bean（一般是XxxProperties对象） return bean;&#125; ConfigurationPropertiesBindingPostProcessor类覆写的postProcessBeforeInitialization方法的做的事情就是将外部属性配置绑定到@ConfigurationProperties注解标注的XxxProperties类上，关键步骤总结如下： 从bean上获取@ConfigurationProperties注解； 若标注有@ConfigurationProperties注解的bean，那么则进行进一步的处理：将外部配置属性值绑定到bean的属性值中后再返回bean；若没有标注有@ConfigurationProperties注解的bean，那么将直接原样返回bean。 注意：后置处理器默认会对每个容器中的bean进行后置处理，因为这里只针对标注有@ConfigurationProperties注解的bean进行外部属性绑定，因此没有标注@ConfigurationProperties注解的bean将不会被处理。 接下来再来看看外部配置属性是如何绑定到@ConfigurationProperties注解的XxxProperties类属性上的呢？ 直接看代码： 1234567891011121314151617181920private void bind(Object bean, String beanName, ConfigurationProperties annotation) &#123; // 【1】得到bean的类型，比如ServerPropertie这个bean得到的类型是：org.springframework.boot.autoconfigure.web.ServerProperties ResolvableType type = getBeanType(bean, beanName); // 【2】获取bean上标注的@Validated注解 Validated validated = getAnnotation(bean, beanName, Validated.class); // 若标注有@Validated注解的话则跟@ConfigurationProperties注解一起组成一个Annotation数组 Annotation[] annotations = (validated != null) ? new Annotation[] &#123; annotation, validated &#125; : new Annotation[] &#123; annotation &#125;; // 【3】返回一个绑定了XxxProperties类的Bindable对象target，这个target对象即被外部属性值注入的目标对象 // （比如封装了标注有@ConfigurationProperties注解的ServerProperties对象的Bindable对象） // 设置annotations属性数组 Bindable&lt;?&gt; target = Bindable.of(type).withExistingValue(bean).withAnnotations(annotations); try &#123; // 【4】执行外部配置属性绑定逻辑 /********【主线，重点关注】********/ this.configurationPropertiesBinder.bind(target); &#125; catch (Exception ex) &#123; throw new ConfigurationPropertiesBindException(beanName, bean, annotation, ex); &#125;&#125; 前面分析了解到 ConfigurationBeanFactoryMetadata覆写的postProcessBeanFactory方法里已经将相关工厂bean的元数据封装到ConfigurationBeanFactoryMetadata类的beansFactoryMetadata集合。 再来看下上面代码中的【1】getBeanType和【2】getAnnotation方法源码： 123456789101112131415161718private ResolvableType getBeanType(Object bean, String beanName) &#123; // 首先获取有没有工厂方法 Method factoryMethod = this.beanFactoryMetadata.findFactoryMethod(beanName); // 若有工厂方法 if (factoryMethod != null) &#123; return ResolvableType.forMethodReturnType(factoryMethod); &#125; // 没有工厂方法，则说明是普通的配置类 return ResolvableType.forClass(bean.getClass());&#125;private &lt;A extends Annotation&gt; A getAnnotation(Object bean, String beanName, Class&lt;A&gt; type) &#123; A annotation = this.beanFactoryMetadata.findFactoryAnnotation(beanName, type); if (annotation == null) &#123; annotation = AnnotationUtils.findAnnotation(bean.getClass(), type); &#125; return annotation;&#125; 注意到上面代码中的beanFactoryMetadata对象没，ConfigurationPropertiesBindingPostProcessor后置处理器的getBeanType和getAnnotation方法分别会调用ConfigurationBeanFactoryMetadata的findFactoryMethod和findFactoryAnnotation方法，而ConfigurationBeanFactoryMetadata的findFactoryMethod和findFactoryAnnotation方法又会依赖存储工厂bean元数据的beansFactoryMetadata集合来寻找是否有FactoryMethod和FactoryAnnotation。因此，到这里就知道之前ConfigurationBeanFactoryMetadata的beansFactoryMetadata集合存储工厂bean元数据的作用了。 3.ConfigurationPropertiesBinder分析this.configurationPropertiesBinder.bind(target);这行代码： 12345678910111213public void bind(Bindable&lt;?&gt; target) &#123; //【1】得到@ConfigurationProperties注解 ConfigurationProperties annotation = target.getAnnotation(ConfigurationProperties.class); Assert.state(annotation != null, () -&gt; &quot;Missing @ConfigurationProperties on &quot; + target); // 【2】得到Validator对象集合，用于属性校验 List&lt;Validator&gt; validators = getValidators(target); // 【3】得到BindHandler对象（默认是IgnoreTopLevelConverterNotFoundBindHandler对象）， // 用于对ConfigurationProperties注解的ignoreUnknownFields等属性的处理 BindHandler bindHandler = getBindHandler(annotation, validators); // 【4】得到一个Binder对象，并利用其bind方法执行外部属性绑定逻辑 /********************【主线，重点关注】********************/ getBinder().bind(annotation.prefix(), target, bindHandler);&#125; 上面代码的主要逻辑是： 先获取target对象（对应XxxProperties类）上的@ConfigurationProperties注解和校验器（若有）; 然后再根据获取的的@ConfigurationProperties注解和校验器来获得BindHandler对象，BindHandler的作用是用于在属性绑定时来处理一些附件逻辑; 最后再获取一个Binder对象，调用其bind方法来执行外部属性绑定的逻辑。 3.1 获取BindHandler对象以便在属性绑定时来处理一些附件逻辑在看getBindHandler方法的逻辑前先来认识下BindHandler是干什么的。 BindHandler是一个父类接口，用于在属性绑定时来处理一些附件逻辑。先看下BindHandler的类图，好有一个整体的认识： 可以看到AbstractBindHandler作为抽象基类实现了BindHandler接口，其有四个具体的子类分别是IgnoreTopLevelConverterNotFoundBindHandler,NoUnboundElementsBindHandler,IgnoreErrorsBindHandler和ValidationBindHandler。 IgnoreTopLevelConverterNotFoundBindHandler：在处理外部属性绑定时的默认BindHandler，当属性绑定失败时会忽略最顶层的ConverterNotFoundException； NoUnboundElementsBindHandler：用来处理配置文件配置的未知的属性； IgnoreErrorsBindHandler：用来忽略无效的配置属性例如类型错误； ValidationBindHandler：利用校验器对绑定的结果值进行校验。 分析完类关系后，再来看下BindHandler接口提供了哪些方法在外部属性绑定时提供一些额外的处理逻辑，直接看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface BindHandler &#123; /** * Default no-op bind handler. */ BindHandler DEFAULT = new BindHandler() &#123; &#125;; /** * Called when binding of an element starts but before any result has been determined. * @param &lt;T&gt; the bindable source type * @param name the name of the element being bound * @param target the item being bound * @param context the bind context * @return the actual item that should be used for binding (may be &#123;@code null&#125;) */ // onStart方法在外部属性绑定前被调用 default &lt;T&gt; Bindable&lt;T&gt; onStart(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindContext context) &#123; return target; &#125; /** * Called when binding of an element ends with a successful result. Implementations * may change the ultimately returned result or perform addition validation. * @param name the name of the element being bound * @param target the item being bound * @param context the bind context * @param result the bound result (never &#123;@code null&#125;) * @return the actual result that should be used (may be &#123;@code null&#125;) */ // onSuccess方法在外部属性成功绑定时被调用，该方法能够改变最终返回的属性值或对属性值进行校验 default Object onSuccess(ConfigurationPropertyName name, Bindable&lt;?&gt; target, BindContext context, Object result) &#123; return result; &#125; /** * Called when binding fails for any reason (including failures from * &#123;@link #onSuccess&#125; calls). Implementations may choose to swallow exceptions and * return an alternative result. * @param name the name of the element being bound * @param target the item being bound * @param context the bind context * @param error the cause of the error (if the exception stands it may be re-thrown) * @return the actual result that should be used (may be &#123;@code null&#125;). * @throws Exception if the binding isn&#x27;t valid */ // onFailure方法在外部属性绑定失败（包括onSuccess方法里的逻辑执行失败）时被调用， // 该方法可以用来catch住相关异常或者返回一个替代的结果（跟微服务的降级结果有点类似） default Object onFailure(ConfigurationPropertyName name, Bindable&lt;?&gt; target, BindContext context, Exception error) throws Exception &#123; throw error; &#125; /** * Called when binding finishes, regardless of whether the property was bound or not. * @param name the name of the element being bound * @param target the item being bound * @param context the bind context * @param result the bound result (may be &#123;@code null&#125;) * @throws Exception if the binding isn&#x27;t valid */ // 当外部属性绑定结束时（不管绑定成功还是失败）被调用 default void onFinish(ConfigurationPropertyName name, Bindable&lt;?&gt; target, BindContext context, Object result) throws Exception &#123; &#125;&#125; 可以看到BindHandler接口定义了onStart,onSuccess,onFailure和onFinish方法，这四个方法分别会在执行外部属性绑定时的不同时段被调用，在属性绑定时用来添加一些额外的处理逻辑，比如在onSuccess方法改变最终绑定的属性值或对属性值进行校验，在onFailure方法catch住相关异常或者返回一个替代的绑定的属性值。 知道了BindHandler是在属性绑定时添加一些额外的处理逻辑后，再来看下getBindHandler方法的逻辑，直接上代码： 12345678910111213141516171819202122232425262728// 注意BindHandler的设计技巧，应该是责任链模式，非常巧妙，值得借鉴private BindHandler getBindHandler(ConfigurationProperties annotation, List&lt;Validator&gt; validators) &#123; // 新建一个IgnoreTopLevelConverterNotFoundBindHandler对象，这是个默认的BindHandler对象 BindHandler handler = new IgnoreTopLevelConverterNotFoundBindHandler(); // 若注解@ConfigurationProperties的ignoreInvalidFields属性设置为true， // 则说明可以忽略无效的配置属性例如类型错误，此时新建一个IgnoreErrorsBindHandler对象 if (annotation.ignoreInvalidFields()) &#123; handler = new IgnoreErrorsBindHandler(handler); &#125; // 若注解@ConfigurationProperties的ignoreUnknownFields属性设置为true， // 则说明配置文件配置了一些未知的属性配置，此时新建一个ignoreUnknownFields对象 if (!annotation.ignoreUnknownFields()) &#123; UnboundElementsSourceFilter filter = new UnboundElementsSourceFilter(); handler = new NoUnboundElementsBindHandler(handler, filter); &#125; // 如果@Valid注解不为空，则创建一个ValidationBindHandler对象 if (!validators.isEmpty()) &#123; handler = new ValidationBindHandler(handler, validators.toArray(new Validator[0])); &#125; // 遍历获取的ConfigurationPropertiesBindHandlerAdvisor集合， // ConfigurationPropertiesBindHandlerAdvisor目前只在测试类中有用到 for (ConfigurationPropertiesBindHandlerAdvisor advisor : getBindHandlerAdvisors()) &#123; // 对handler进一步处理 handler = advisor.apply(handler); &#125; // 返回handler return handler;&#125; getBindHandler方法的逻辑很简单，主要是根据传入的@ConfigurationProperties注解和validators校验器来创建不同的BindHandler具体实现类： 首先new一个IgnoreTopLevelConverterNotFoundBindHandler作为默认的BindHandler; 若@ConfigurationProperties注解的属性ignoreInvalidFields值为true，那么再new一个IgnoreErrorsBindHandler对象，把刚才新建的IgnoreTopLevelConverterNotFoundBindHandler对象作为构造参数传入赋值给AbstractBindHandler父类的parent属性； 若@ConfigurationProperties注解的属性ignoreUnknownFields值为false，那么再new一个UnboundElementsSourceFilter对象，把之前构造的BindHandler对象作为构造参数传入赋值给AbstractBindHandler父类的parent属性； ……以此类推，前一个handler对象作为后一个hangdler对象的构造参数，就这样利用AbstractBindHandler父类的parent属性将每一个handler链起来，最后再得到最终构造的handler。 GET技巧：上面的这个设计模式是不是很熟悉，这个就是责任链模式。学习源码，同时也是学习别人怎么熟练运用设计模式。责任链模式的应用案例有很多，比如Dubbo的各种Filter们（比如AccessLogFilter是用来记录服务的访问日志的，ExceptionFilter是用来处理异常的…），一开始学习java web时的Servlet的Filter,MyBatis的Plugin们以及Netty的Pipeline都采用了责任链模式。 了解了BindHandler的作用后，再来紧跟主线，看属性绑定是如何绑定的？ 3.2 获取Binder对象用于进行属性绑定【主线】这里分析 ConfigurationPropertiesBinder代码中标注【4】的主线代码getBinder().bind(annotation.prefix(), target, bindHandler); 可以看到这句代码主要做了两件事： 调用getBinder方法获取用于属性绑定的Binder对象； 调用Binder对象的bind方法进行外部属性绑定到@ConfigurationProperties注解的XxxProperties类的属性上。 那么我们先看下getBinder方法源码： 123456789101112131415private Binder getBinder() &#123; // Binder是一个能绑定ConfigurationPropertySource的容器对象 if (this.binder == null) &#123; // 新建一个Binder对象，这个binder对象封装了ConfigurationPropertySources， // PropertySourcesPlaceholdersResolver，ConversionService和PropertyEditorInitializer对象 // getConfigurationPropertySources() 将PropertySources对象封装成SpringConfigurationPropertySources对象并返回 // getPropertySourcesPlaceholdersResolver(), getConversionService() 将PropertySources对象封装成PropertySourcesPlaceholdersResolver对象并返回，从容器中获取到ConversionService对象 // getPropertyEditorInitializer() 得到Consumer&lt;PropertyEditorRegistry&gt;对象，这些初始化器用来配置property editors，property editors通常可以用来转换值 this.binder = new Binder(getConfigurationPropertySources(), getPropertySourcesPlaceholdersResolver(), getConversionService(), getPropertyEditorInitializer()); &#125; // 返回binder return this.binder;&#125; 可以看到Binder对象封装了ConfigurationPropertySources,PropertySourcesPlaceholdersResolver,ConversionService和PropertyEditorInitializer这四个对象，Binder对象封装了这四个肯定是在后面属性绑定逻辑中会用到，先看下这四个对象是干嘛的： ConfigurationPropertySources:外部配置文件的属性源，由ConfigFileApplicationListener监听器负责触发读取； PropertySourcesPlaceholdersResolver:解析属性源中的占位符$&#123;&#125;； ConversionService:对属性类型进行转换 PropertyEditorInitializer:用来配置property editors 获取了Binder属性绑定器后，再来看下它的bind方法是如何执行属性绑定的。 123456789101112131415161718public &lt;T&gt; BindResult&lt;T&gt; bind(String name, Bindable&lt;T&gt; target, BindHandler handler) &#123; // ConfigurationPropertyName.of(name)：将name（这里指属性前缀名）封装到ConfigurationPropertyName对象中 // 将外部配置属性绑定到目标对象target中 return bind(ConfigurationPropertyName.of(name), target, handler);&#125;public &lt;T&gt; BindResult&lt;T&gt; bind(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler) &#123; Assert.notNull(name, &quot;Name must not be null&quot;); Assert.notNull(target, &quot;Target must not be null&quot;); handler = (handler != null) ? handler : BindHandler.DEFAULT; // Context是Binder的内部类，实现了BindContext，Context可以理解为Binder的上下文，可以用来获取binder的属性比如Binder的sources属性 Context context = new Context(); // 进行属性绑定，并返回绑定属性后的对象bound，注意bound的对象类型是T，T就是@ConfigurationProperties注解的类比如ServerProperties /********【主线，重点关注】************/ T bound = bind(name, target, handler, context, false); // 将刚才返回的bound对象封装到BindResult对象中并返回 return BindResult.of(bound);&#125; 上面代码中首先创建了一个Context对象，Context是Binder的内部类，为Binder的上下文，利用Context上下文可以获取Binder的属性比如获取Binder的sources属性值并绑定到XxxProperties属性中。然后再紧跟主线看下 bind(name, target, handler, context, false)方法源码： 1234567891011121314151617181920protected final &lt;T&gt; T bind(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Context context, boolean allowRecursiveBinding) &#123; // 清空Binder的configurationProperty属性值 context.clearConfigurationProperty(); try &#123; // 【1】调用BindHandler的onStart方法，执行一系列的责任链对象的该方法 target = handler.onStart(name, target, context); if (target == null) &#123; return null; &#125; // 【2】调用bindObject方法对Bindable对象target的属性进行绑定外部配置的值，并返回赋值给bound对象。 // 例如：比如设置了server.port=9999,那么该方法最终会调用Binder.bindProperty方法，最终返回的bound的value值为9999 /************【主线：重点关注】***********/ Object bound = bindObject(name, target, handler, context, allowRecursiveBinding); // 【3】封装handleBindResult对象并返回，注意在handleBindResult的构造函数中会调用BindHandler的onSucess，onFinish方法 return handleBindResult(name, target, handler, context, bound); &#125; catch (Exception ex) &#123; return handleBindError(name, target, handler, context, ex); &#125;&#125; 接着紧跟主线来看看bindObject方法源码: 1234567891011121314151617181920212223242526272829303132333435private &lt;T&gt; Object bindObject(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Context context, boolean allowRecursiveBinding) &#123; // 从propertySource中的配置属性，获取ConfigurationProperty对象property即application.properties配置文件中若有相关的配置的话， // 那么property将不会为null。例如：假如你在配置文件中配置了spring.profiles.active=dev，那么相应property值为dev；否则为null ConfigurationProperty property = findProperty(name, context); // 若property为null，则不会执行后续的属性绑定相关逻辑 if (property == null &amp;&amp; containsNoDescendantOf(context.getSources(), name)) &#123; // 如果property == null，则返回null return null; &#125; // 根据target类型获取不同的Binder，可以是null（普通的类型一般是Null）,MapBinder,CollectionBinder或ArrayBinder AggregateBinder&lt;?&gt; aggregateBinder = getAggregateBinder(target, context); // 若aggregateBinder不为null比如配置了spring.profiles属性（当然包括其子属性比如spring.profiles.active等） if (aggregateBinder != null) &#123; // 若aggregateBinder不为null，则调用bindAggregate并返回绑定后的对象 return bindAggregate(name, target, handler, context, aggregateBinder); &#125; // 若property不为null if (property != null) &#123; try &#123; // 绑定属性到对象中，比如配置文件中设置了server.port=8888，那么将会最终调用bindProperty方法进行属性设置 return bindProperty(target, context, property); &#125; catch (ConverterNotFoundException ex) &#123; // We might still be able to bind it as a bean Object bean = bindBean(name, target, handler, context, allowRecursiveBinding); if (bean != null) &#123; return bean; &#125; throw ex; &#125; &#125; // 只有@ConfigurationProperties注解的类进行外部属性绑定才会走这里 /***********************【主线，重点关注】****************************/ return bindBean(name, target, handler, context, allowRecursiveBinding);&#125; 由上代码中可以看到bindObject中执行属性绑定的逻辑会根据不同的属性类型进入不同的绑定逻辑中，例如： application.properties配置文件中配置了spring.profiles.active=dev的话，那么将会进入return bindAggregate(name, target, handler, context, aggregateBinder);这个属性绑定的代码逻辑； application.properties配置文件中配置了server.port=9999的话，那么将会进入return bindBean(name, target, handler, context, allowRecursiveBinding);的属性绑定的逻辑。 再次紧跟主线，进入@ConfigurationProperties注解的XxxProperties类的属性绑定逻辑中的bindBean方法中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// name指的是ConfigurationProperties的前缀名private Object bindBean(ConfigurationPropertyName name, Bindable&lt;?&gt; target, BindHandler handler, Context context, boolean allowRecursiveBinding) &#123; // 这里做一些ConfigurationPropertyState的相关检查 if (containsNoDescendantOf(context.getSources(), name) || isUnbindableBean(name, target, context)) &#123; return null; &#125; // 这里新建一个BeanPropertyBinder的实现类对象，注意这个对象实现了bindProperty方法 BeanPropertyBinder propertyBinder = (propertyName, propertyTarget) -&gt; bind( name.append(propertyName), propertyTarget, handler, context, false); /** * (propertyName, propertyTarget) -&gt; bind( * name.append(propertyName), propertyTarget, handler, context, false); * 等价于 * new BeanPropertyBinder() &#123; * Object bindProperty(String propertyName, Bindable&lt;?&gt; target)&#123; * bind(name.append(propertyName), propertyTarget, handler, context, false); * &#125; * &#125; */ // type类型即@ConfigurationProperties注解标注的XxxProperties类 Class&lt;?&gt; type = target.getType().resolve(Object.class); if (!allowRecursiveBinding &amp;&amp; context.hasBoundBean(type)) &#123; return null; &#125; // 这里应用了java8的lambda语法，作为没怎么学习java8的lambda语法的我，不怎么好理解下面的逻辑，哈哈 // 真正实现将外部配置属性绑定到@ConfigurationProperties注解的XxxProperties类的属性中的逻辑应该就是在这句lambda代码了 /*******************【主线】***************************/ return context.withBean(type, () -&gt; &#123; Stream&lt;?&gt; boundBeans = BEAN_BINDERS.stream() .map((b) -&gt; b.bind(name, target, context, propertyBinder)); return boundBeans.filter(Objects::nonNull).findFirst().orElse(null); &#125;); // 根据上面的lambda语句翻译如下： /** 这里的T指的是各种属性绑定对象，比如ServerProperties * return context.withBean(type, new Supplier&lt;T&gt;() &#123; * T get() &#123; * Stream&lt;?&gt; boundBeans = BEAN_BINDERS.stream() * .map((b) -&gt; b.bind(name, target, context, propertyBinder)); * return boundBeans.filter(Objects::nonNull).findFirst().orElse(null); * &#125; * &#125;); */&#125; 从上面代码中，追根究底来到了外部配置属性绑定到XxxProperties类属性中的比较底层的代码了，可以看到属性绑定的逻辑应该就在上面代码标注【主线】的lambda代码处了。这个属于SpringBoot的属性绑定Binder的范畴，Binder相关类是SpringBoot2.0才出现的，即对之前的属性绑定相关代码进行推翻重写了。 总结好了，外部配置属性值是如何被绑定到XxxProperties类属性上的源码分析就到此结束了，重要步骤总结： 首先是@EnableConfigurationProperties注解import了EnableConfigurationPropertiesImportSelector后置处理器； EnableConfigurationPropertiesImportSelector后置处理器又向Spring容器中注册了ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar这两个bean； 其中ConfigurationPropertiesBeanRegistrar向Spring容器中注册了XxxProperties类型的bean；ConfigurationPropertiesBindingPostProcessorRegistrar向Spring容器中注册了ConfigurationBeanFactoryMetadata和ConfigurationPropertiesBindingPostProcessor两个后置处理器； ConfigurationBeanFactoryMetadata后置处理器在初始化bean factory时将@Bean注解的元数据存储起来，以便在后续的外部配置属性绑定的相关逻辑中使用； ConfigurationPropertiesBindingPostProcessor后置处理器将外部配置属性值绑定到XxxProperties类属性的逻辑委托给ConfigurationPropertiesBinder对象，然后ConfigurationPropertiesBinder对象又最终将属性绑定的逻辑委托给Binder对象来完成。 可见，重要的是上面的第5步。 参考资料 https://www.jianshu.com/p/554533f88370]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(4)-SpringBoot 的自动配置]]></title>
    <url>%2Fposts%2F2020-11-18-SpringBoot-Source-04%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringBoot 的自动配置 上一篇我们分析了SpringBoot的条件注解@ConditionalOnXXX的相关源码，总结如下： SpringBoot的所有@ConditionalOnXxx的条件类OnXxxCondition都是继承于SpringBootCondition基类，而SpringBootCondition又实现了Condition接口。 SpringBootCondition基类主要用来打印一些条件注解评估报告的日志，这些条件评估信息全部来源于其子类注解条件类OnXxxCondition，因此其也抽象了一个模板方法getMatchOutcome留给子类去实现来评估其条件注解是否符合条件。 前一篇还有一个重要的知识点没分析，那就是跟过滤自动配置类逻辑有关的AutoConfigurationImportFilter接口，这篇文章来分析一下。 前面分析了跟SpringBoot的自动配置息息相关内置条件注解@ConditionalOnXxx后，现在就开始来分析跟SpringBoot自动配置的相关源码。 1.@SpringBootApplication注解思考下，SpringBoot为何一个标注有@SpringBootApplication注解的启动类通过执行一个简单的run方法就能实现SpringBoot大量Starter的自动配置呢？ 其实SpringBoot自动配置就跟@SpringBootApplication这个注解有关，先来看下这个注解的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default &#123;&#125;; /** * Base packages to scan for annotated components. Use &#123;@link #scanBasePackageClasses&#125; * for a type-safe alternative to String-based package names. * @return base packages to scan * @since 1.3.0 */ @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;) String[] scanBasePackages() default &#123;&#125;; /** * Type-safe alternative to &#123;@link #scanBasePackages&#125; for specifying the packages to * scan for annotated components. The package of each class specified will be scanned. * &lt;p&gt; * Consider creating a special no-op marker class or interface in each package that * serves no purpose other than being referenced by this attribute. * @return base packages to scan * @since 1.3.0 */ @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125; @SpringBootApplication标注了很多注解，可以看到其中跟SpringBoot自动配置有关的注解就只有@EnableAutoConfiguration，因此，可以肯定的是SpringBoot的自动配置肯定跟@EnableAutoConfiguration相关(其中@ComponentScan注解的excludeFilters属性也有一个类AutoConfigurationExcludeFilter,这个类跟自动配置也有点关系，但不是我们关注的重点)。 现在我们来打开@EnableAutoConfiguration注解的源码： 12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default &#123;&#125;;&#125; 看到@EnableAutoConfiguration注解又标有@AutoConfigurationPackage和@Import(AutoConfigurationImportSelector.class)两个注解。 @AutoConfigurationPackage注解肯定跟自动配置的包有关，而AutoConfigurationImportSelector则是跟SpringBoot的自动配置选择导入有关（Spring中的ImportSelector是用来导入配置类的，通常是基于某些条件注解@ConditionalOnXxxx来决定是否导入某个配置类）。 因此，需要重点分析AutoConfigurationImportSelector类，因为SpringBoot的自动配置肯定有一个配置类，而这个配置类的导入则需要靠AutoConfigurationImportSelector来实现。 2.SpringBoot自动配置实现逻辑的入口方法可以肯定的是SpringBoot的自动配置的逻辑肯定与AutoConfigurationImportSelector这个类有关，那么该如何找到SpringBoot自动配置实现逻辑的入口方法呢？ AutoConfigurationImportSelector的相关类图： 可以看到AutoConfigurationImportSelector重点是实现了DeferredImportSelector接口和各种Aware接口，然后DeferredImportSelector接口又继承了ImportSelector接口。 AutoConfigurationImportSelector复写DeferredImportSelector接口的实现方法selectImports方法，因为selectImports方法跟导入自动配置类有关，而这个方法往往是程序执行的入口方法。经过调试发现，selectImports方法跟自动配置相关的逻辑有点关系，但实质关系不大。 又该如何来找到自动配置逻辑有关的入口方法呢？ 最简单的方法就是在AutoConfigurationImportSelector类的每个方法都打上断点，然后调试看先执行到哪个方法，但是这样太复杂了。自定义一个Starter的时候，要在spring.factories配置文件中配置 1EnableAutoConfiguration=XxxAutoConfiguration 因此可以推断，SpringBoot的自动配置原理肯定跟从spring.factories配置文件中加载自动配置类有关，于是结合AutoConfigurationImportSelector的方法注释，我们找到了getAutoConfigurationEntry方法。于是在这个方法里面打上一个断点，此时通过调用栈帧来看下更上层的入口方法在哪里，然后再从跟自动配置相关的更上层的入口方法开始分析。 通过上图可以看到，跟自动配置逻辑相关的入口方法在DeferredImportSelectorGrouping类的getImports方法处，因此就从DeferredImportSelectorGrouping类的getImports方法来开始分析SpringBoot的自动配置源码。 3.分析SpringBoot自动配置原理既然找到ConfigurationClassParser.getImports()方法是自动配置相关的入口方法，那么下面就来真正分析SpringBoot自动配置的源码。 先看一下getImports方法代码： 12345678910public Iterable&lt;Group.Entry&gt; getImports() &#123; // 遍历DeferredImportSelectorHolder对象集合deferredImports，deferredImports集合装了各种ImportSelector，当然这里装的是AutoConfigurationImportSelector for (DeferredImportSelectorHolder deferredImport : this.deferredImports) &#123; // 【1】利用AutoConfigurationGroup的process方法来处理自动配置的相关逻辑，决定导入哪些配置类（这个是分析的重点，自动配置的逻辑全在这） this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()); &#125; // 【2】经过上面的处理后，然后再进行选择导入哪些配置类 return this.group.selectImports();&#125; 【1】处的的代码是分析的重点，自动配置相关的大部分逻辑全在这里，深入分析自动配置的主要逻辑。那么this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector())；主要做的事情就是在this.group即AutoConfigurationGroup对象的process方法中，传入的AutoConfigurationImportSelector对象来选择一些符合条件的自动配置类，过滤掉一些不符合条件的自动配置类。 AutoConfigurationGroup：是AutoConfigurationImportSelector的内部类，主要用来处理自动配置相关的逻辑，拥有process和selectImports方法，然后拥有entries和autoConfigurationEntries集合属性，这两个集合分别存储被处理后的符合条件的自动配置类； AutoConfigurationImportSelector：承担自动配置的大部分逻辑，负责选择一些符合条件的自动配置类； metadata:标注在SpringBoot启动类上的@SpringBootApplication注解元数据 【2】的this.group.selectImports的方法主要是针对前面的process方法处理后的自动配置类再进一步有选择的选择导入。 3.1 分析自动配置的主要逻辑这里继续深究前面【1】处的 this.group.process方法是如何处理自动配置相关逻辑的。 123456789101112131415161718192021// 这里用来处理自动配置类，比如过滤掉不符合匹配条件的自动配置类@Overridepublic void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123; Assert.state( deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; String.format(&quot;Only %s implementations are supported, got %s&quot;, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName())); // 【1】,调用getAutoConfigurationEntry方法得到自动配置类放入autoConfigurationEntry对象中 AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector) .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata); // 【2】，又将封装了自动配置类的autoConfigurationEntry对象装进autoConfigurationEntries集合 this.autoConfigurationEntries.add(autoConfigurationEntry); // 【3】，遍历刚获取的自动配置类 for (String importClassName : autoConfigurationEntry.getConfigurations()) &#123; // 这里符合条件的自动配置类作为key，annotationMetadata作为值放进entries集合 this.entries.putIfAbsent(importClassName, annotationMetadata); &#125;&#125; 上面代码中再来看标【1】的方法getAutoConfigurationEntry，这个方法主要是用来获取自动配置类有关，承担了自动配置的主要逻辑。直接上代码： 1234567891011121314151617181920212223242526272829303132333435// 获取符合条件的自动配置类，避免加载不必要的自动配置类从而造成内存浪费protected AutoConfigurationEntry getAutoConfigurationEntry( AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; // 获取是否有配置spring.boot.enableautoconfiguration属性，默认返回true if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; // 获得@Congiguration标注的Configuration类即被审视introspectedClass的注解数据， // 比如：@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class) // 将会获取到exclude = FreeMarkerAutoConfiguration.class和excludeName=&quot;&quot;的注解数据 AnnotationAttributes attributes = getAttributes(annotationMetadata); // 【1】得到spring.factories文件配置的所有自动配置类 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 利用LinkedHashSet移除重复的配置类 configurations = removeDuplicates(configurations); // 得到要排除的自动配置类，比如注解属性exclude的配置类 // 比如：@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class) // 将会获取到exclude = FreeMarkerAutoConfiguration.class的注解数据 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); // 检查要被排除的配置类，因为有些不是自动配置类，故要抛出异常 checkExcludedClasses(configurations, exclusions); // 【2】将要排除的配置类移除 configurations.removeAll(exclusions); // 【3】因为从spring.factories文件获取的自动配置类太多，如果有些不必要的自动配置类都加载进内存，会造成内存浪费，因此这里需要进行过滤 // 注意这里会调用AutoConfigurationImportFilter的match方法来判断是否符合@ConditionalOnBean,@ConditionalOnClass或@ConditionalOnWebApplication，后面会重点分析一下 configurations = filter(configurations, autoConfigurationMetadata); // 【4】获取了符合条件的自动配置类后，此时触发AutoConfigurationImportEvent事件， // 目的是告诉ConditionEvaluationReport条件评估报告器对象来记录符合条件的自动配置类 // 该事件什么时候会被触发？--&gt; 在刷新容器时调用invokeBeanFactoryPostProcessors后置处理器时触发 fireAutoConfigurationImportEvents(configurations, exclusions); // 【5】将符合条件和要排除的自动配置类封装进AutoConfigurationEntry对象，并返回 return new AutoConfigurationEntry(configurations, exclusions);&#125; AutoConfigurationEntry方法主要做的事情就是获取符合条件的自动配置类，避免加载不必要的自动配置类从而造成内存浪费。下面总结下AutoConfigurationEntry方法主要做的事情： 【1】从spring.factories配置文件中加载EnableAutoConfiguration自动配置类（注意此时是从缓存中拿到的）,获取的自动配置类如下图所示。 【2】若@EnableAutoConfiguration等注解标有要exclude的自动配置类，那么再将这个自动配置类排除掉； 【3】排除掉要exclude的自动配置类后，然后再调用filter方法进行进一步的过滤，再次排除一些不符合条件的自动配置类； 【4】经过重重过滤后，此时再触发AutoConfigurationImportEvent事件，告诉ConditionEvaluationReport条件评估报告器对象来记录符合条件的自动配置类； 【5】 最后再将符合条件的自动配置类返回。 总结了AutoConfigurationEntry方法主要的逻辑后，再来细看一下AutoConfigurationImportSelector的filter方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private List&lt;String&gt; filter(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata) &#123; long startTime = System.nanoTime(); // 将从spring.factories中获取的自动配置类转出字符串数组 String[] candidates = StringUtils.toStringArray(configurations); // 定义skip数组，是否需要跳过。注意skip数组与candidates数组顺序一一对应 boolean[] skip = new boolean[candidates.length]; boolean skipped = false; // getAutoConfigurationImportFilters方法：拿到OnBeanCondition，OnClassCondition和OnWebApplicationCondition // 然后遍历这三个条件类去过滤从spring.factories加载的大量配置类 for (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123; // 调用各种aware方法，将beanClassLoader,beanFactory等注入到filter对象中， // 这里的filter对象即OnBeanCondition，OnClassCondition或OnWebApplicationCondition invokeAwareMethods(filter); // 判断各种filter来判断每个candidate（这里实质要通过candidate(自动配置类)拿到其标注的 // @ConditionalOnClass,@ConditionalOnBean和@ConditionalOnWebApplication里面的注解值）是否匹配， // 注意candidates数组与match数组一一对应 /**********************【主线，重点关注】********************************/ boolean[] match = filter.match(candidates, autoConfigurationMetadata); // 遍历match数组，注意match顺序跟candidates的自动配置类一一对应 for (int i = 0; i &lt; match.length; i++) &#123; // 若有不匹配的话 if (!match[i]) &#123; // 不匹配的将记录在skip数组，标志skip[i]为true，也与candidates数组一一对应 skip[i] = true; // 因为不匹配，将相应的自动配置类置空 candidates[i] = null; // 标注skipped为true skipped = true; &#125; &#125; &#125; // 这里表示若所有自动配置类经过OnBeanCondition，OnClassCondition和OnWebApplicationCondition过滤后，全部都匹配的话，则全部原样返回 if (!skipped) &#123; return configurations; &#125; // 建立result集合来装匹配的自动配置类 List&lt;String&gt; result = new ArrayList&lt;&gt;(candidates.length); for (int i = 0; i &lt; candidates.length; i++) &#123; // 若skip[i]为false，则说明是符合条件的自动配置类，此时添加到result集合中 if (!skip[i]) &#123; result.add(candidates[i]); &#125; &#125; // 打印日志 if (logger.isTraceEnabled()) &#123; int numberFiltered = configurations.size() - result.size(); logger.trace(&quot;Filtered &quot; + numberFiltered + &quot; auto configuration class in &quot; + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + &quot; ms&quot;); &#125; // 最后返回符合条件的自动配置类 return new ArrayList&lt;&gt;(result);&#125; AutoConfigurationImportSelector的filter方法主要做的事情就是调用AutoConfigurationImportFilter接口的match方法来判断每一个自动配置类上的条件注解（若有的话）@ConditionalOnClass,@ConditionalOnBean或@ConditionalOnWebApplication是否满足条件，若满足，则返回true，说明匹配，若不满足，则返回false说明不匹配。 3.2 有选择的导入自动配置类继续深究前面分析SpringBoot自动配置原理这节标【2】处的 this.group.selectImports方法是如何进一步有选择的导入自动配置类的。直接看代码： 12345678910111213141516171819202122232425// AutoConfigurationImportSelector$AutoConfigurationGroup.java@Overridepublic Iterable&lt;Entry&gt; selectImports() &#123; if (this.autoConfigurationEntries.isEmpty()) &#123; return Collections.emptyList(); &#125; // 这里得到所有要排除的自动配置类的set集合 Set&lt;String&gt; allExclusions = this.autoConfigurationEntries.stream() .map(AutoConfigurationEntry::getExclusions) .flatMap(Collection::stream).collect(Collectors.toSet()); // 这里得到经过滤后所有符合条件的自动配置类的set集合 Set&lt;String&gt; processedConfigurations = this.autoConfigurationEntries.stream() .map(AutoConfigurationEntry::getConfigurations) .flatMap(Collection::stream) .collect(Collectors.toCollection(LinkedHashSet::new)); // 移除掉要排除的自动配置类 processedConfigurations.removeAll(allExclusions); // 对标注有@Order注解的自动配置类进行排序， return sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()) .stream() .map((importClassName) -&gt; new Entry( this.entries.get(importClassName), importClassName)) .collect(Collectors.toList());&#125; 可以看到，selectImports方法主要是针对经过排除掉exclude的和被AutoConfigurationImportFilter接口过滤后的满足条件的自动配置类再进一步排除exclude的自动配置类，然后再排序。 疑问: 前面已经exclude过一次了，为何这里还要再exclude一次？ 4.AutoConfigurationImportFilter继续分析前面的 AutoConfigurationImportSelector.filter方法的过滤自动配置类的boolean[] match = filter.match(candidates, autoConfigurationMetadata);这行代码。 因此继续分析AutoConfigurationImportFilter接口，分析其match方法，同时也是对前一篇@ConditionalOnXxx的源码分析文章中留下的问题进行补充。 AutoConfigurationImportFilter接口只有一个match方法用来过滤不符合条件的自动配置类。 12345@FunctionalInterfacepublic interface AutoConfigurationImportFilter &#123; boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata);&#125; 在分析AutoConfigurationImportFilter接口的match方法前，先看下类关系图： 可以看到AutoConfigurationImportFilter接口有一个具体的实现类FilteringSpringBootCondition，FilteringSpringBootCondition又有三个具体的子类：OnClassCondition,OnBeanCondtition和OnWebApplicationCondition。 那么这几个类之间的关系是怎样的呢？ FilteringSpringBootCondition实现了AutoConfigurationImportFilter接口的match方法，然后在FilteringSpringBootCondition的match方法调用getOutcomes这个抽象模板方法返回自动配置类的匹配与否的信息。同时，最重要的是FilteringSpringBootCondition的三个子类OnClassCondition,OnBeanCondtition和OnWebApplicationCondition将会复写这个模板方法实现自己的匹配判断逻辑。 好了，AutoConfigurationImportFilter接口的整体关系已经清楚了，现在再进入其具体实现类FilteringSpringBootCondition的match方法看看是其如何根据条件过滤自动配置类的。 12345678910111213141516171819202122232425// FilteringSpringBootCondition.java@Overridepublic boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123; // 创建评估报告 ConditionEvaluationReport report = ConditionEvaluationReport.find(this.beanFactory); // 注意getOutcomes是模板方法，将spring.factories文件种加载的所有自动配置类传入 // 子类（这里指的是OnClassCondition,OnBeanCondition和OnWebApplicationCondition类）去过滤 // 注意outcomes数组存储的是不匹配的结果，跟autoConfigurationClasses数组一一对应 /*****************************【主线，重点关注】*********************************************/ ConditionOutcome[] outcomes = getOutcomes(autoConfigurationClasses, autoConfigurationMetadata); boolean[] match = new boolean[outcomes.length]; // 遍历outcomes,这里outcomes为null则表示匹配，不为null则表示不匹配 for (int i = 0; i &lt; outcomes.length; i++) &#123; match[i] = (outcomes[i] == null || outcomes[i].isMatch()); if (!match[i] &amp;&amp; outcomes[i] != null) &#123; // 这里若有某个类不匹配的话，此时调用父类SpringBootCondition的logOutcome方法打印日志 logOutcome(autoConfigurationClasses[i], outcomes[i]); // 并将不匹配情况记录到report if (report != null) &#123; report.recordConditionEvaluation(autoConfigurationClasses[i], this, outcomes[i]); &#125; &#125; &#125; return match;&#125; FilteringSpringBootCondition的match方法主要做的事情还是调用抽象模板方法getOutcomes来根据条件来过滤自动配置类，而复写getOutcomes模板方法的有三个子类，这里不再一一分析，只挑选OnClassCondition复写的getOutcomes方法进行分析。 4.1 OnClassConditionOnClassCondition复写的getOutcomes方法的代码： 123456789101112131415161718192021222324252627// OnClassCondition.java@Overrideprotected final ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123; // Split the work and perform half in a background thread. Using a single // additional thread seems to offer the best performance. More threads make // things worse // 这里经过测试用两个线程去跑的话性能是最好的，大于两个线程性能反而变差 int split = autoConfigurationClasses.length / 2; // 【1】开启一个新线程去扫描判断已经加载的一半自动配置类 OutcomesResolver firstHalfResolver = createOutcomesResolver(autoConfigurationClasses, 0, split, autoConfigurationMetadata); // 【2】这里用主线程去扫描判断已经加载的一半自动配置类 OutcomesResolver secondHalfResolver = new StandardOutcomesResolver(autoConfigurationClasses, split, autoConfigurationClasses.length, autoConfigurationMetadata, getBeanClassLoader()); // 【3】先让主线程去执行解析一半自动配置类是否匹配条件 ConditionOutcome[] secondHalf = secondHalfResolver.resolveOutcomes(); // 【4】这里用新开启的线程取解析另一半自动配置类是否匹配 // 注意为了防止主线程执行过快结束，resolveOutcomes方法里面调用了thread.join()来 // 让主线程等待新线程执行结束，因为后面要合并两个线程的解析结果 ConditionOutcome[] firstHalf = firstHalfResolver.resolveOutcomes(); // 新建一个ConditionOutcome数组来存储自动配置类的筛选结果 ConditionOutcome[] outcomes = new ConditionOutcome[autoConfigurationClasses.length]; // 将前面两个线程的筛选结果分别拷贝进outcomes数组 System.arraycopy(firstHalf, 0, outcomes, 0, firstHalf.length); System.arraycopy(secondHalf, 0, outcomes, split, secondHalf.length); // 返回自动配置类的筛选结果 return outcomes;&#125; 可以看到，OnClassCondition的getOutcomes方法主要解析自动配置类是否符合匹配条件，当然这个匹配条件指自动配置类上的注解@ConditionalOnClass指定的类存不存在于classpath中，存在则返回匹配，不存在则返回不匹配。 由于解析自动配置类是否匹配比较耗时，因此从上面代码中我们可以看到分别创建了firstHalfResolver和secondHalfResolver两个解析对象，这两个解析对象个分别对应一个线程去解析加载的自动配置类是否符合条件，最终将两个线程的解析自动配置类的匹配结果合并后返回。 那么自动配置类是否符合条件的解析判断过程又是怎样的呢？现在我们分别来看一下上面代码注释标注的【1】，【2】，【3】和【4】处。 4.1.1 createOutcomesResolver12345678910111213141516// OnClassCondition.javaprivate OutcomesResolver createOutcomesResolver(String[] autoConfigurationClasses, int start, int end, AutoConfigurationMetadata autoConfigurationMetadata) &#123; // 新建一个StandardOutcomesResolver对象 OutcomesResolver outcomesResolver = new StandardOutcomesResolver( autoConfigurationClasses, start, end, autoConfigurationMetadata, getBeanClassLoader()); try &#123; // new一个ThreadedOutcomesResolver对象，并将StandardOutcomesResolver类型的outcomesResolver对象作为构造器参数传入 return new ThreadedOutcomesResolver(outcomesResolver); &#125; // 若上面开启的线程抛出AccessControlException异常，则返回StandardOutcomesResolver对象 catch (AccessControlException ex) &#123; return outcomesResolver; &#125;&#125; 可以看到createOutcomesResolver方法创建了一个封装了StandardOutcomesResolver类的ThreadedOutcomesResolver解析对象。再来看下ThreadedOutcomesResolver这个线程解析类封装StandardOutcomesResolver这个对象的目的是什么？继续跟进代码： 12345678private ThreadedOutcomesResolver(OutcomesResolver outcomesResolver) &#123; // 这里开启一个新的线程，这个线程其实还是利用StandardOutcomesResolver的resolveOutcomes方法 // 对自动配置类进行解析判断是否匹配 this.thread = new Thread( () -&gt; this.outcomes = outcomesResolver.resolveOutcomes()); // 开启线程 this.thread.start();&#125; 可以看到在构造ThreadedOutcomesResolver对象时候，原来是开启了一个线程，然后这个线程其实还是调用了刚传进来的StandardOutcomesResolver对象的resolveOutcomes方法去解析自动配置类。 4.1.2 new StandardOutcomesResolver()逻辑很简单，就是创建了一个StandardOutcomesResolver对象，用于后面解析自动配置类是否匹配，同时，新建的一个线程也是利用它来完成自动配置类的解析的。 4.1.3 StandardOutcomesResolver.resolveOutcomes()这个方法承担了解析自动配置类匹配与否的全部逻辑，是需要重点分析的方法，resolveOutcomes方法最终把解析的自动配置类的结果赋给secondHalf数组。那么它是如何解析自动配置类是否匹配条件的呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142// OnClassCondition$StandardOutcomesResolver.java@Overridepublic ConditionOutcome[] resolveOutcomes() &#123; // 再调用getOutcomes方法来解析 return getOutcomes(this.autoConfigurationClasses, this.start, this.end, this.autoConfigurationMetadata);&#125;private ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, int start, int end, AutoConfigurationMetadata autoConfigurationMetadata) &#123; // 只要autoConfigurationMetadata没有存储相关自动配置类，那么outcome默认为null，则说明匹配 ConditionOutcome[] outcomes = new ConditionOutcome[end - start]; // 遍历每一个自动配置类 for (int i = start; i &lt; end; i++) &#123; String autoConfigurationClass = autoConfigurationClasses[i]; /** * TODO 对于autoConfigurationMetadata有个疑问： * 为何有些自动配置类的条件注解能被加载到autoConfigurationMetadata，而有些又不能， * 比如自己定义的一个自动配置类HelloWorldEnableAutoConfiguration就没有被存到autoConfigurationMetadata中 */ if (autoConfigurationClass != null) &#123; // 这里取出注解在AutoConfiguration自动配置类类的@ConditionalOnClass注解的指定类的全限定名， // 举个栗子，看下面的KafkaStreamsAnnotationDrivenConfiguration这个自动配置类 /** * @ConditionalOnClass(StreamsBuilder.class) * class KafkaStreamsAnnotationDrivenConfiguration &#123; * // 省略无关代码 * &#125; */ // 那么取出的就是StreamsBuilder类的全限定名即candidates = org.apache.kafka.streams.StreamsBuilder String candidates = autoConfigurationMetadata.get(autoConfigurationClass, &quot;ConditionalOnClass&quot;); // 因为这里是处理某个类是否存在于classpath中，所以传入的key是ConditionalOnClass // 若自动配置类标有ConditionalOnClass注解且有值，此时调用getOutcome判断是否存在于类路径中 if (candidates != null) &#123; // 拿到自动配置类注解@ConditionalOnClass的值后，再调用getOutcome方法去判断匹配结果,若该类存在于类路径，则getOutcome返回null，否则非null /*******************【主线，重点关注】******************/ outcomes[i - start] = getOutcome(candidates); &#125; &#125; &#125; return outcomes;&#125; 可以看到StandardOutcomesResolver.resolveOutcomes的方法中再次调用getOutcomes方法，主要是从autoConfigurationMetadata对象中获取到自动配置类上的注解@ConditionalOnClass指定的类的全限定名，然后作为参数传入getOutcome方法用于去类路径加载该类，若能加载到则说明注解@ConditionalOnClass满足条件，此时说明自动配置类匹配成功。 但是别忘了，这里只是分析了@ConditionalOnClass注解，若自动配置类还有其他注解比如@ConditionalOnBean，若该@ConditionalOnBean注解不满足条件的话，同样最终结果是不匹配的。回到OnClassCondtion的判断逻辑，继续进入getOutcome方法看它是如何去判断@ConditionalOnClass注解满不满足条件的。 12345678910111213141516171819202122232425// OnClassCondition$StandardOutcomesResolver.java// 返回的outcome记录的是不匹配的情况，不为null，则说明不匹配；为null，则说明匹配private ConditionOutcome getOutcome(String candidates) &#123; // candidates的形式为“org.springframework.boot.autoconfigure.aop.AopAutoConfiguration.ConditionalOnClass=org.aspectj.lang.annotation.Aspect,org.aspectj.lang.reflect.Advice,org.aspectj.weaver.AnnotatedElement” try &#123; // 自动配置类上@ConditionalOnClass的值只有一个的话，直接调用getOutcome方法判断是否匹配 if (!candidates.contains(&quot;,&quot;)) &#123; // 看到因为传入的参数是 ClassNameFilter.MISSING，因此可以猜测这里应该是得到不匹配的结果 /******************【主线，重点关注】********************/ return getOutcome(candidates, ClassNameFilter.MISSING, this.beanClassLoader); &#125; // 自动配置类上@ConditionalOnClass的值有多个的话，则遍历每个值（其值以逗号，分隔） for (String candidate : StringUtils.commaDelimitedListToStringArray(candidates)) &#123; ConditionOutcome outcome = getOutcome(candidate, ClassNameFilter.MISSING, this.beanClassLoader); // 可以看到，这里只要有一个不匹配的话，则返回不匹配结果 if (outcome != null) &#123; return outcome; &#125; &#125; &#125; catch (Exception ex) &#123; // We&#x27;ll get another chance later &#125; return null;&#125; 可以看到，getOutcome方法再次调用重载方法getOutcome进一步去判断注解@ConditionalOnClass指定的类存不存在类路径中，跟着主线继续跟进去： 12345678910111213// OnClassCondition$StandardOutcomesResolver.javaprivate ConditionOutcome getOutcome(String className, ClassNameFilter classNameFilter, ClassLoader classLoader) &#123; // 调用classNameFilter的matches方法来判断`@ConditionalOnClass`指定的类存不存在类路径中 /******************【主线，重点关注】********************/ if (classNameFilter.matches(className, classLoader)) &#123; // 这里调用classNameFilter去判断className是否存在于类路径中， // 其中ClassNameFilter又分为PRESENT和MISSING两种; // 目前只看到ClassNameFilter为MISSING的调用情况，所以默认为true的话记录不匹配信息； // 若传入ClassNameFilter为PRESENT的话，估计还要再写一个else分支 return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class).didNotFind(&quot;required class&quot;).items(Style.QUOTE, className)); &#125; return null;&#125; 一层一层的剥，最终剥到了最底层了，这个真的需要足够耐心，没办法，源码只能一点一点的啃。可以看到最终是调用ClassNameFilter的matches方法来判断@ConditionalOnClass指定的类存不存在类路径中,若不存在的话，则返回不匹配。 继续跟进ClassNameFilter的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// FilteringSpringBootCondition.javaprotected enum ClassNameFilter &#123; // 这里表示指定的类存在于类路径中，则返回true PRESENT &#123; @Override public boolean matches(String className, ClassLoader classLoader) &#123; return isPresent(className, classLoader); &#125; &#125;, // 这里表示指定的类不存在于类路径中，则返回true MISSING &#123; @Override public boolean matches(String className, ClassLoader classLoader) &#123; // 若classpath不存在className这个类，则返回true return !isPresent(className, classLoader); &#125; &#125;; // 这又是一个抽象方法，分别被PRESENT和MISSING枚举类实现 public abstract boolean matches(String className, ClassLoader classLoader); // 检查指定的类是否存在于类路径中 public static boolean isPresent(String className, ClassLoader classLoader) &#123; if (classLoader == null) &#123; classLoader = ClassUtils.getDefaultClassLoader(); &#125; // 利用类加载器去加载相应类，若没有抛出异常则说明类路径中存在该类，此时返回true try &#123; forName(className, classLoader); return true; &#125; // 若不存在于类路径中，此时抛出的异常将catch住，返回false。 catch (Throwable ex) &#123; return false; &#125; &#125; // 利用类加载器去加载指定的类 private static Class&lt;?&gt; forName(String className, ClassLoader classLoader) throws ClassNotFoundException &#123; if (classLoader != null) &#123; return classLoader.loadClass(className); &#125; return Class.forName(className); &#125;&#125; 可以看到ClassNameFilter原来是FilteringSpringBootCondition的一个内部枚举类，实现了判断指定类是否存在于classpath中的逻辑。 4.1.4 ThreadedOutcomesResolver.resolveOutcomes()这里是用新开启的线程去调用StandardOutcomesResolver.resolveOutcomes方法解析另一半自动配置类是否匹配，因为是新线程，这里很可能会出现这么一种情况：主线程解析完属于自己解析的一半自动配置类后，那么就继续往下跑了，此时不会等待新开启的子线程的。 因此，为了让主线程解析完后，需要让主线程继续等待正在解析的子线程，直到子线程结束。那么继续跟进代码区看下ThreadedOutcomesResolver.resolveOutcomes方法是怎样实现让主线程等待子线程的： 12345678910111213// OnClassCondition$ThreadedOutcomesResolver.java@Overridepublic ConditionOutcome[] resolveOutcomes() &#123; try &#123; // 调用子线程的Join方法，让主线程等待 this.thread.join(); &#125; catch (InterruptedException ex) &#123; Thread.currentThread().interrupt(); &#125; // 若子线程结束后，此时返回子线程的解析结果 return this.outcomes;&#125; 可以看到用了Thread.join()方法来让主线程等待正在解析自动配置类的子线程，这里应该也可以用CountDownLatch来让主线程等待子线程结束。最终将子线程解析后的结果赋给firstHalf数组。 4.2 OnBeanCondition 和 OnWebApplicationCondition前面深入分析了OnClassCondition是如何过滤自动配置类的，那么自动配置类除了要经过OnClassCondition的过滤，还要经过OnBeanCondition和OnWebApplicationCondition这两个条件类的过滤，可自行分析。 5.AutoConfigurationImportListener继续分析前面AutoConfigurationImportSelector.getAutoConfigurationEntry方法的触发自动配置类过滤完毕的事件fireAutoConfigurationImportEvents(configurations, exclusions);这句代码。 直接点进fireAutoConfigurationImportEvents方法看看其是如何触发事件的： 12345678910111213141516// AutoConfigurationImportSelector.javaprivate void fireAutoConfigurationImportEvents(List&lt;String&gt; configurations, Set&lt;String&gt; exclusions) &#123; // 从spring.factories总获取到AutoConfigurationImportListener即ConditionEvaluationReportAutoConfigurationImportListener List&lt;AutoConfigurationImportListener&gt; listeners = getAutoConfigurationImportListeners(); if (!listeners.isEmpty()) &#123; // 新建一个AutoConfigurationImportEvent事件 AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, configurations, exclusions); // 遍历刚获取到的AutoConfigurationImportListener for (AutoConfigurationImportListener listener : listeners) &#123; // 这里调用各种Aware方法用于触发事件前赋值，比如设置factory,environment等 invokeAwareMethods(listener); // 真正触发AutoConfigurationImportEvent事件即回调listener的onXXXEveent方法。这里用于记录自动配置类的评估信息 listener.onAutoConfigurationImportEvent(event); &#125; &#125;&#125; 如上，fireAutoConfigurationImportEvents方法做了以下两件事情： 调用getAutoConfigurationImportListeners方法从spring.factories配置文件获取实现AutoConfigurationImportListener接口的事件监听器；如下图，可以看到获取的是ConditionEvaluationReportAutoConfigurationImportListener： 遍历获取的各个事件监听器，然后调用监听器各种Aware方法给监听器赋值，最后再依次回调事件监听器的onAutoConfigurationImportEvent方法，执行监听事件的逻辑。 此时再来看下ConditionEvaluationReportAutoConfigurationImportListener监听器监听到事件后，它的onAutoConfigurationImportEvent方法究竟做了哪些事情： 123456789101112// ConditionEvaluationReportAutoConfigurationImportListener.java@Overridepublic void onAutoConfigurationImportEvent(AutoConfigurationImportEvent event) &#123; if (this.beanFactory != null) &#123; // 获取到条件评估报告器对象 ConditionEvaluationReport report = ConditionEvaluationReport.get(this.beanFactory); // 将符合条件的自动配置类记录到unconditionalClasses集合中 report.recordEvaluationCandidates(event.getCandidateConfigurations()); // 将要exclude的自动配置类记录到exclusions集合中 report.recordExclusions(event.getExclusions()); &#125;&#125; 可以看到，ConditionEvaluationReportAutoConfigurationImportListener监听器监听到事件后，做的事情很简单，只是分别记录下符合条件和被exclude的自动配置类。 6.AutoConfigurationPackages前面已经详述了SpringBoot的自动配置原理了，最后，跟SpringBoot自动配置有关的注解@AutoConfigurationPackage还没分析，来看下这个注解的源码： 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;&#125; 可以看到@AutoConfigurationPackage注解是跟SpringBoot自动配置所在的包相关的，即将 添加该注解的类所在的package 作为 自动配置package 进行管理。 接下来我们再看看AutoConfigurationPackages.Registrar类是干嘛的，直接看源码： 123456789101112131415//AutoConfigurationPackages.Registrar.javastatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; register(registry, new PackageImport(metadata).getPackageName()); &#125; @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new PackageImport(metadata)); &#125;&#125; 可以看到Registrar类是AutoConfigurationPackages的静态内部类，实现了ImportBeanDefinitionRegistrar和DeterminableImports两个接口。现在主要来关注下Registrar实现的registerBeanDefinitions方法，这个方法是注册bean定义的方法。看到它又调用了AutoConfigurationPackages的register方法，继续跟进源码： 1234567891011121314151617public static void register(BeanDefinitionRegistry registry, String... packageNames) &#123; if (registry.containsBeanDefinition(BEAN)) &#123; BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN); ConstructorArgumentValues constructorArguments = beanDefinition .getConstructorArgumentValues(); constructorArguments.addIndexedArgumentValue(0, addBasePackages(constructorArguments, packageNames)); &#125; else &#123; GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(BasePackages.class); beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(BEAN, beanDefinition); &#125;&#125; 如上，可以看到register方法注册了一个packageNames即自动配置类注解@EnableAutoConfiguration所在的所在的包名相关的bean。那么注册这个bean的目的是为了什么呢？ 结合注释知道，注册这个自动配置包名相关的bean是为了被其他地方引用，比如JPA entity scanner。 7.总结最后，再总结下SpringBoot自动配置的原理，主要做了以下事情： 从spring.factories配置文件中加载自动配置类； 加载的自动配置类中排除掉@EnableAutoConfiguration注解的exclude属性指定的自动配置类； 然后再用AutoConfigurationImportFilter接口去过滤自动配置类是否符合其标注注解（若有标注的话）@ConditionalOnClass,@ConditionalOnBean和@ConditionalOnWebApplication的条件，若都符合的话则返回匹配结果； 然后触发AutoConfigurationImportEvent事件，告诉ConditionEvaluationReport条件评估报告器对象来分别记录符合条件和exclude的自动配置类。 最后spring再将最后筛选后的自动配置类导入IOC容器中 疑问： 为了避免加载不必要的自动配置类造成内存浪费，FilteringSpringBootCondition用于过滤spring.factories文件的自动配置类，而FilteringSpringBootCondition为啥只有OnOnBeanCondition,OnClassCondition和onWebApplicationCondition这三个条件类用于过滤，为啥没有onPropertyCondtion，onResourceCondition等条件类来过滤自动配置类呢？ 12345# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\org.springframework.boot.autoconfigure.condition.OnClassCondition,\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition 参考资料 https://blog.csdn.net/ttyy1112/article/details/101284541]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(3)-SpringBoot自动配置的条件注解原理]]></title>
    <url>%2Fposts%2F2020-11-17-SpringBoot-Source-03%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringBoot自动配置的条件注解原理 1.SpringBoot 内置条件注解SpringBoot自动配置是需要满足相应的条件才会自动配置,因此SpringBoot的自动配置大量应用了条件注解ConditionalOnXXX。 @ConditionalOnBean：当SpringIoc容器内存在指定Bean的条件 @ConditionalOnClass：当SpringIoc容器内存在指定Class的条件 @ConditionalOnExpression：基于SpEL表达式作为判断条件 @ConditionalOnJava：基于JVM版本作为判断条件 @ConditionalOnJndi：在JNDI存在时查找指定的位置 @ConditionalOnMissingBean：当SpringIoc容器内不存在指定Bean的条件 @ConditionalOnMissingClass：当SpringIoc容器内不存在指定Class的条件 @ConditionalOnNotWebApplication：当前项目不是Web项目的条件 @ConditionalOnProperty：指定的属性是否有指定的值 @ConditionalOnResource：类路径是否有指定的值 @ConditionalOnSingleCandidate：当指定Bean在SpringIoc容器内只有一个，或者虽然有多个但是指定首选的Bean @ConditionalOnWebApplication：当前项目是Web项目的条件 SpringBoot的@ConditionalOnXXX等条件注解都是派生注解，SpringBoot的自动配置原理是建立在大量的派生条件注解@ConditionalOnXXX之上，而这些条件注解的原理跟Spring的Condition接口有关。因此接下来先来看看Condition接口的相关源码。 2.Condition接口2.1 Condition接口demo比如自定义一个@ConditionalOnLinux注解，该注解只有在其属性environment是”linux”才会创建相关的bean。 LinuxCondition.java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 实现spring 的Condition接口，并且重写matches()方法， * 如果@ConditionalOnLinux的注解属性environment是linux就返回true */public class LinuxCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 获得注解@ConditionalOnLinux的所有属性 List&lt;AnnotationAttributes&gt; allAnnotationAttributes = annotationAttributesFromMultiValueMap( metadata.getAllAnnotationAttributes(ConditionalOnLinux.class.getName())); for (AnnotationAttributes annotationAttributes : allAnnotationAttributes) &#123; // 获得注解@ConditionalOnLinux的environment属性 String environment = annotationAttributes.getString(&quot;environment&quot;); // 若environment等于linux，则返回true if (&quot;linux&quot;.equals(environment)) &#123; return true; &#125; &#125; return false; &#125; private List&lt;AnnotationAttributes&gt; annotationAttributesFromMultiValueMap( MultiValueMap&lt;String, Object&gt; multiValueMap) &#123; List&lt;Map&lt;String, Object&gt;&gt; maps = new ArrayList&lt;&gt;(); multiValueMap.forEach((key, value) -&gt; &#123; for (int i = 0; i &lt; value.size(); i++) &#123; Map&lt;String, Object&gt; map; if (i &lt; maps.size()) &#123; map = maps.get(i); &#125; else &#123; map = new HashMap&lt;&gt;(); maps.add(map); &#125; map.put(key, value.get(i)); &#125; &#125;); List&lt;AnnotationAttributes&gt; annotationAttributes = new ArrayList&lt;&gt;(maps.size()); for (Map&lt;String, Object&gt; map : maps) &#123; annotationAttributes.add(AnnotationAttributes.fromMap(map)); &#125; return annotationAttributes; &#125;&#125; ConditionalOnLinux.java 123456789@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(LinuxCondition.class)public @interface ConditionalOnLinux &#123; // 标注是哪个环境 String environment() default &quot;&quot;;&#125; ConditionConfig.java 123456789@Configurationpublic class ConditionConfig &#123; // 只有`@ConditionalOnLinux`的注解属性`environment`是&quot;linux&quot;时才会创建bean @Bean @ConditionalOnLinux(environment = &quot;linux&quot;) public Environment linuxEnvironment() &#123; return new LinuxEnvironment(); &#125;&#125; LinuxCondition实现了Condition接口并实现了matches方法，而matches方法则判断@ConditionalOnLinux的注解属性environment是否”linux”，是则返回true，否则false。 然后再定义一个注解@ConditionalOnLinux，这个注解是@Conditional的派生注解，与@Conditional(LinuxCondition.class)等价，注意@ConditionalOnLinux注解定义了一个属性environment。而最终可以利用LinuxCondition的matches方法中的参数AnnotatedTypeMetadata来获取@ConditionalOnLinux的注解属性environment的值，从而用来判断值是否为linux”。 最后定义一个配置类ConditionConfig，在linuxEnvironment方法上标注了@ConditionalOnLinux(environment = “linux”)。因此，这里只有 LinuxCondition的matches方法返回true才会创建bean。 2.2 Condition接口源码分析Condition接口的源码： 1234567891011121314@FunctionalInterfacepublic interface Condition &#123; /** * Determine if the condition matches. * @param context the condition context * @param metadata metadata of the &#123;@link org.springframework.core.type.AnnotationMetadata class&#125; * or &#123;@link org.springframework.core.type.MethodMetadata method&#125; being checked * @return &#123;@code true&#125; if the condition matches and the component can be registered, * or &#123;@code false&#125; to veto the annotated component&#x27;s registration */ boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);&#125; Condition接口主要有一个matches方法，该方法决定了是否要注册相应的bean对象。其中matches方法中有两个参数，参数类型分别是ConditionContext和AnnotatedTypeMetadata，这两个参数非常重要。它们分别用来获取一些环境信息和注解元数据，从而用在matches方法中判断是否符合条件。 ConditionContext 主要是跟Condition的上下文有关，主要用来获取Registry,BeanFactory,Environment,ResourceLoader和ClassLoader等。比如OnResourceCondition需要靠ConditionContext来获取ResourceLoader来加载指定资源，OnClassCondition需要靠ConditionContext来获取ClassLoader来加载指定类等，下面看下其源码： 12345678910111213141516171819202122232425262728293031323334353637public interface ConditionContext &#123; /** * Return the &#123;@link BeanDefinitionRegistry&#125; that will hold the bean definition * should the condition match. * @throws IllegalStateException if no registry is available (which is unusual: * only the case with a plain &#123;@link ClassPathScanningCandidateComponentProvider&#125;) */ BeanDefinitionRegistry getRegistry(); /** * Return the &#123;@link ConfigurableListableBeanFactory&#125; that will hold the bean * definition should the condition match, or &#123;@code null&#125; if the bean factory is * not available (or not downcastable to &#123;@code ConfigurableListableBeanFactory&#125;). */ @Nullable ConfigurableListableBeanFactory getBeanFactory(); /** * Return the &#123;@link Environment&#125; for which the current application is running. */ Environment getEnvironment(); /** * Return the &#123;@link ResourceLoader&#125; currently being used. */ ResourceLoader getResourceLoader(); /** * Return the &#123;@link ClassLoader&#125; that should be used to load additional classes * (only &#123;@code null&#125; if even the system ClassLoader isn&#x27;t accessible). * @see org.springframework.util.ClassUtils#forName(String, ClassLoader) */ @Nullable ClassLoader getClassLoader();&#125; AnnotatedTypeMetadata，这个跟注解元数据有关，利用AnnotatedTypeMetadata可以拿到某个注解的一些元数据，而这些元数据就包含了某个注解里面的属性，比如上面的demo，利用AnnotatedTypeMetadata可以拿到@ConditionalOnLinux的注解属性environment的值。下面看下其源码： 123456789101112131415public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String var1); @Nullable Map&lt;String, Object&gt; getAnnotationAttributes(String var1); @Nullable Map&lt;String, Object&gt; getAnnotationAttributes(String var1, boolean var2); @Nullable MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1); @Nullable MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1, boolean var2);&#125; @ConditionalOnLinux注解真正起作用的是Condition接口的具体实现类LinuxCondition的matches方法。 这个matches方法是在何时被调用的呢？通过idea调试看调用的栈帧，如下图： 从图片上可以看到，在ConditionEvaluator的shouldSkip方法中调用了LinuxCondition的matches方法，分析下ConditionEvaluator的shouldSkip方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 这个方法主要是如果是解析阶段则跳过，如果是注册阶段则不跳过public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) &#123; // 若没有被@Conditional或其派生注解所标注，则不会跳过 if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) &#123; return false; &#125; // 没有指定phase，注意phase可以分为PARSE_CONFIGURATION或REGISTER_BEAN类型 if (phase == null) &#123; // 若标有@Component，@Import，@Bean或@Configuration等注解的话，则说明是PARSE_CONFIGURATION类型 if (metadata instanceof AnnotationMetadata &amp;&amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123; return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION); &#125; // 否则是REGISTER_BEAN类型 return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN); &#125; List&lt;Condition&gt; conditions = new ArrayList&lt;&gt;(); // TODO 获得所有标有@Conditional注解或其派生注解里面的Condition接口实现类并实例化成对象。 // 比如@Conditional(OnBeanCondition.class)则获得OnBeanCondition.class，OnBeanCondition.class往往实现了Condition接口 for (String[] conditionClasses : getConditionClasses(metadata)) &#123; // 将类实例化成对象 for (String conditionClass : conditionClasses) &#123; Condition condition = getCondition(conditionClass, this.context.getClassLoader()); conditions.add(condition); &#125; &#125; // 排序，即按照Condition的优先级进行排序 AnnotationAwareOrderComparator.sort(conditions); for (Condition condition : conditions) &#123; ConfigurationPhase requiredPhase = null; if (condition instanceof ConfigurationCondition) &#123; // 从condition中获得对bean是解析还是注册 requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase(); &#125; // 若requiredPhase为null或获取的阶段类型正是当前阶段类型且不符合condition的matches条件，则跳过 if ((requiredPhase == null || requiredPhase == phase) &amp;&amp; !condition.matches(this.context, metadata)) &#123; return true; &#125; &#125; return false;&#125; shouldSkip这个方法执行的逻辑主要是如果是解析阶段(PARSE_CONFIGURATION)则跳过，如果是注册阶段(REGISTER_BEAN)则不跳过；如果是在注册阶段的话，此时会得到所有的Condition接口的具体实现类并实例化这些实现类，然后再执行下面关键的代码进行判断是否需要跳过。 123if ((requiredPhase == null || requiredPhase == phase) &amp;&amp; !condition.matches(this.context, metadata)) &#123; return true;&#125; 上面代码最重要的逻辑是调用了Condition接口的具体实现类的matches方法，若matches返回false，则跳过，不进行注册bean的操作；若matches返回true，则不跳过，进行注册bean的操作； 2.3 Spring的内置Condition接口实现类Spring的Condition接口的具体实现类的关系图: 发现Spring内置的Condition接口的具体实现类虽然有多个，但只有ProfileCondition不是测试相关的，因此真正内置的Condition接口的具体实现类只有ProfileCondition一个。 ProfileCondition 是跟环境有关， 一般有dev,test和prod环境，而ProfileCondition就是判断 项目配置了哪个环境的。下面是ProfileCondition的源码： 1234567891011121314151617class ProfileCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) &#123; for (Object value : attrs.get(&quot;value&quot;)) &#123; if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123; return true; &#125; &#125; return false; &#125; return true; &#125;&#125; 3.SpringBootCondition源码解析前面Spring对Condition的内置注解只有ProfileCondition一个，但是，SpringBoot内置了大量的条件注解ConditionalOnXXX。 SpringBootCondition的整体类图： 可以看到SpringBootCondition作为SpringBoot条件注解的基类，它实现了Condition接口，然后又有很多具体的子类OnXXXCondition,这些OnXXXCondition其实就是@ConditionalOnXXX的条件类。 先来看下SpringBootCondition这个父类是主要做了哪些事情，抽象了哪些共有的逻辑？ SpringBootConditon实现了Condition接口，作为SpringBoot众多条件注解OnXXXCondtion的父类，它的作用主要就是打印一些条件注解评估报告的日志，比如打印哪些配置类是符合条件注解的，哪些是不符合的。 因为SpringBootConditon实现了Condition接口，也实现了matches方法，因此该方法同样也是被ConditionEvaluator的shouldSkip方法中调用，因此我们就以SpringBootConditon的matches方法为入口去进行分析。直接上代码： 12345678910111213141516171819202122232425@Overridepublic final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; String classOrMethodName = getClassOrMethodName(metadata); try &#123; ConditionOutcome outcome = getMatchOutcome(context, metadata); logOutcome(classOrMethodName, outcome); recordEvaluation(context, classOrMethodName, outcome); return outcome.isMatch(); &#125; catch (NoClassDefFoundError ex) &#123; throw new IllegalStateException( &quot;Could not evaluate condition on &quot; + classOrMethodName + &quot; due to &quot; + ex.getMessage() + &quot; not &quot; + &quot;found. Make sure your own configuration does not rely on &quot; + &quot;that class. This can also happen if you are &quot; + &quot;@ComponentScanning a springframework package (e.g. if you &quot; + &quot;put a @ComponentScan in the default package by mistake)&quot;, ex); &#125; catch (RuntimeException ex) &#123; throw new IllegalStateException( &quot;Error processing condition on &quot; + getName(metadata), ex); &#125;&#125; 上面代码的注释已经非常详细，知道了SpringBootCondition抽象了所有其具体实现类OnXXXCondition的共有逻辑–condition评估信息打印，最重要的是封装了一个模板方法getMatchOutcome(context, metadata)，留给各个OnXXXCondition具体子类去覆盖实现属于自己的判断逻辑，然后再返回相应的匹配结果给SpringBootCondition用于日志打印。 SpringBootCondition其实就是用来打印condition评估信息的，对于其他枝节方法暂时先不追究过深，免得丢了主线。现在的重点是放在交给OnXXXCondition子类实现的模板方法上getMatchOutcome(context, metadata)，因为这个方法将会由很多OnXXXCondition覆盖重写判断逻辑，这里是接下来分析的重点。 因为SpringBootCondition有众多具体实现类，下面只挑OnResourceCondition，OnBeanCondition和OnWebApplicationCondition进行讲解，而AutoConfigurationImportFilter跟自动配置有关，则留到自动配置源码解析的时候再进行分析。 3.1 OnResourceCondition源码分析先来看一下逻辑及其简单的注解条件类OnResourceCondition，OnResourceCondition继承了SpringBootCondition父类，覆盖了其getMatchOutcome方法，用于@ConditionalOnResource注解指定的资源存在与否。OnResourceCondition的判断逻辑非常简单，主要拿到@ConditionalOnResource注解指定的资源路径后，然后用ResourceLoader根据指定路径去加载看资源存不存在。源码如下: @ConditionalOnResource 代码： 12345678910111213@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(OnResourceCondition.class)public @interface ConditionalOnResource &#123; /** * The resources that must be present. * @return the resource paths that must be present. */ String[] resources() default &#123;&#125;;&#125; OnResourceCondition 代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Order(Ordered.HIGHEST_PRECEDENCE + 20)class OnResourceCondition extends SpringBootCondition &#123; private final ResourceLoader defaultResourceLoader = new DefaultResourceLoader(); @Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 获得@ConditionalOnResource注解的属性元数据 MultiValueMap&lt;String, Object&gt; attributes = metadata .getAllAnnotationAttributes(ConditionalOnResource.class.getName(), true); // 获得资源加载器，若ConditionContext中有ResourceLoader则用ConditionContext中的，没有则用默认的 ResourceLoader loader = (context.getResourceLoader() != null) ? context.getResourceLoader() : this.defaultResourceLoader; List&lt;String&gt; locations = new ArrayList&lt;&gt;(); // 将@ConditionalOnResource中定义的resources属性值取出来装进locations集合 collectValues(locations, attributes.get(&quot;resources&quot;)); Assert.isTrue(!locations.isEmpty(), &quot;@ConditionalOnResource annotations must specify at &quot; + &quot;least one resource location&quot;); // missing集合是装不存在指定资源的资源路径的 List&lt;String&gt; missing = new ArrayList&lt;&gt;(); // 遍历所有的资源路径，若指定的路径的资源不存在则将其资源路径存进missing集合中 for (String location : locations) &#123; // 这里针对有些资源路径是Placeholders的情况，即处理$&#123;&#125; String resource = context.getEnvironment().resolvePlaceholders(location); if (!loader.getResource(resource).exists()) &#123; missing.add(location); &#125; &#125; // 如果存在某个资源不存在，那么则报错 if (!missing.isEmpty()) &#123; return ConditionOutcome.noMatch(ConditionMessage .forCondition(ConditionalOnResource.class) .didNotFind(&quot;resource&quot;, &quot;resources&quot;).items(Style.QUOTE, missing)); &#125; // 所有资源都存在，那么则返回能找到就提的资源 return ConditionOutcome .match(ConditionMessage.forCondition(ConditionalOnResource.class) .found(&quot;location&quot;, &quot;locations&quot;).items(locations)); &#125; // 将@ConditionalOnResource中定义的resources属性值取出来装进locations集合 private void collectValues(List&lt;String&gt; names, List&lt;Object&gt; values) &#123; for (Object value : values) &#123; for (Object item : (Object[]) value) &#123; names.add((String) item); &#125; &#125; &#125;&#125; 3.2 OnBeanCondition源码分析OnBeanCondition继承了FilteringSpringBootCondition父类，覆盖了父类FilteringSpringBootCondition的getOutcomes方法。而FilteringSpringBootCondition又是SpringBootCondition的子类，FilteringSpringBootCondition跟自动配置类过滤有关。值得注意的是OnBeanCondition同样重写了SpringBootCondition的getMatchOutcome方法，用来判断Spring容器中是否存在指定条件的bean。同时OnBeanCondition是@ConditionalOnBean,@ConditionalOnSingleCandidate和ConditionalOnMissingBean的条件类。 OnBeanCondition复写父类SpringBootCondition的getMatchOutcome方法的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overridepublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; ConditionMessage matchMessage = ConditionMessage.empty(); // (1) 配置类（metadata）标注@ConditionalOnBean注解的情况 if (metadata.isAnnotated(ConditionalOnBean.class.getName())) &#123; // 将@ConditionalOnBean注解属性封装进BeanSearchSpec对象中 // 注意BeanSearchSpec是一个静态内部类，用来存储@ConditionalOnBean和@ConditionalOnMissingBean注解的属性值 BeanSearchSpec spec = new BeanSearchSpec(context, metadata, ConditionalOnBean.class); // 调用getMatchingBeans得到符合条件的bean MatchResult matchResult = getMatchingBeans(context, spec); // 如果不匹配 if (!matchResult.isAllMatched()) &#123; String reason = createOnBeanNoMatchReason(matchResult); return ConditionOutcome.noMatch(ConditionMessage .forCondition(ConditionalOnBean.class, spec).because(reason)); &#125; // 如果匹配 matchMessage = matchMessage.andCondition(ConditionalOnBean.class, spec) .found(&quot;bean&quot;, &quot;beans&quot;) .items(Style.QUOTE, matchResult.getNamesOfAllMatches()); &#125; // (2) 配置类（metadata）标注@ConditionalOnSingleCandidate注解的情况 if (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) &#123; BeanSearchSpec spec = new SingleCandidateBeanSearchSpec(context, metadata, ConditionalOnSingleCandidate.class); MatchResult matchResult = getMatchingBeans(context, spec); if (!matchResult.isAllMatched()) &#123; return ConditionOutcome.noMatch(ConditionMessage .forCondition(ConditionalOnSingleCandidate.class, spec) .didNotFind(&quot;any beans&quot;).atAll()); &#125; else if (!hasSingleAutowireCandidate(context.getBeanFactory(), matchResult.getNamesOfAllMatches(), spec.getStrategy() == SearchStrategy.ALL)) &#123; return ConditionOutcome.noMatch(ConditionMessage .forCondition(ConditionalOnSingleCandidate.class, spec) .didNotFind(&quot;a primary bean from beans&quot;) .items(Style.QUOTE, matchResult.getNamesOfAllMatches())); &#125; matchMessage = matchMessage .andCondition(ConditionalOnSingleCandidate.class, spec) .found(&quot;a primary bean from beans&quot;) .items(Style.QUOTE, matchResult.getNamesOfAllMatches()); &#125; // (3) 配置类（metadata）标注@ConditionalOnMissingBean注解的情况 if (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) &#123; BeanSearchSpec spec = new BeanSearchSpec(context, metadata, ConditionalOnMissingBean.class); MatchResult matchResult = getMatchingBeans(context, spec); if (matchResult.isAnyMatched()) &#123; String reason = createOnMissingBeanNoMatchReason(matchResult); return ConditionOutcome.noMatch(ConditionMessage .forCondition(ConditionalOnMissingBean.class, spec) .because(reason)); &#125; matchMessage = matchMessage.andCondition(ConditionalOnMissingBean.class, spec) .didNotFind(&quot;any beans&quot;).atAll(); &#125; // 最终返回matchMessage return ConditionOutcome.match(matchMessage);&#125; 可以看到OnBeanCondition类覆盖的getMatchOutcome方法分别处理了标注@ConditionalOnBean,@ConditionalOnSingleCandidate和@ConditionalOnMissingBean注解的情况，分别对应上面代码注释的(1),(2)和(3)处。 只看针对@ConditionalOnBean注解的处理逻辑，从上面代码中可以看到若配置类（metadata）标注@ConditionalOnBean注解的话，主要做了以下事情： 将该注解属性提取出来封装进BeanSearchSpec对象中; 然后调用getMatchingBeans(context, spec)方法来获取是否有匹配的bean； 最后返回bean的匹配情况； 可以看到最重要的逻辑是第2步，那么再来看下getMatchingBeans方法，直接看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566protected final MatchResult getMatchingBeans(ConditionContext context, BeanSearchSpec beans) &#123; // 获得Spring容器的beanFactory ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); // 判断bean的搜索策略是否是SearchStrategy.ANCESTORS策略 if (beans.getStrategy() == SearchStrategy.ANCESTORS) &#123; BeanFactory parent = beanFactory.getParentBeanFactory(); Assert.isInstanceOf(ConfigurableListableBeanFactory.class, parent, &quot;Unable to use SearchStrategy.PARENTS&quot;); beanFactory = (ConfigurableListableBeanFactory) parent; &#125; // MatchResult用来存储bean的匹配结果 MatchResult matchResult = new MatchResult(); // 如果bean的搜索策略不是SearchStrategy.CURRENT的话，则置considerHierarchy为true boolean considerHierarchy = beans.getStrategy() != SearchStrategy.CURRENT; // 获取TypeExtractor，TypeExtractor是用来判断bean的类型的 TypeExtractor typeExtractor = beans.getTypeExtractor(context.getClassLoader()); // 获取是否有被忽略bean类型，若有的话将该bean类型的名称装进beansIgnoredByType集合 // 这里主要是针对@ConditionalOnMissingBean的ignored属性 List&lt;String&gt; beansIgnoredByType = getNamesOfBeansIgnoredByType( beans.getIgnoredTypes(), typeExtractor, beanFactory, context, considerHierarchy); // 遍历bean的所有类型 for (String type : beans.getTypes()) &#123; // 调用getBeanNamesForType方法根据bean类型得到所有符合条件的bean类型，并放到typeMatches集合 Collection&lt;String&gt; typeMatches = getBeanNamesForType(beanFactory, type, typeExtractor, context.getClassLoader(), considerHierarchy); // 移除掉Ignored的类型 typeMatches.removeAll(beansIgnoredByType); // 若typeMatches为空，那么则说明正在遍历的这个type类型不符合匹配条件，此时用matchResult记录一下这个不符合条件的类型 if (typeMatches.isEmpty()) &#123; matchResult.recordUnmatchedType(type); &#125; // 若typeMatches不为空，那么则说明正在遍历的这个type类型符合匹配条件，此时用matchResult记录一下这个符合条件的类型 else &#123; matchResult.recordMatchedType(type, typeMatches); &#125; &#125; // 这里针对@ConditionalOnBean等注解的annotation属性的处理 for (String annotation : beans.getAnnotations()) &#123; List&lt;String&gt; annotationMatches = Arrays .asList(getBeanNamesForAnnotation(beanFactory, annotation, context.getClassLoader(), considerHierarchy)); annotationMatches.removeAll(beansIgnoredByType); if (annotationMatches.isEmpty()) &#123; matchResult.recordUnmatchedAnnotation(annotation); &#125; else &#123; matchResult.recordMatchedAnnotation(annotation, annotationMatches); &#125; &#125; // 这里针对@ConditionalOnBean等注解的name属性的处理 for (String beanName : beans.getNames()) &#123; // beansIgnoredByType集合不包含beanName且beanFactory包含这个bean，则匹配 if (!beansIgnoredByType.contains(beanName) &amp;&amp; containsBean(beanFactory, beanName, considerHierarchy)) &#123; matchResult.recordMatchedName(beanName); &#125; // 否则，不匹配 else &#123; matchResult.recordUnmatchedName(beanName); &#125; &#125; // 最后返回匹配结果 return matchResult;&#125; 上面的逻辑主要是从spring容器中搜索有无指定条件的bean，Spring容器搜索bean的话有三种搜索策略，分别是： CURRENT：表示只从当前的context中搜索bean ANCESTORS：表示只从父context中搜索bean ALL：表示从整个context中搜索bean 定义了搜索策略后，然后再根据BeanSearchSpec对象封装的注解属性分别取指定的容器中查找有无符合条件的bean，然后再进行一些过滤。比如@ConditionalOnMissingBean注解有定义ignored属性值，那么从容器中搜索到有符合条件的bean时，此时还要移除掉ignored指定的bean。 3.3 OnWebApplicationCondition源码分析OnWebApplicationCondition继承了FilteringSpringBootCondition父类，覆盖了父类FilteringSpringBootCondition的getOutcomes方法。而FilteringSpringBootCondition又是SpringBootCondition的子类，FilteringSpringBootCondition跟自动配置类过滤有关。值得注意的是OnWebApplicationCondition同样重写了SpringBootCondition的getMatchOutcome方法，用来判断当前应用是否web应用。同时是OnWebApplicationCondition是@ConditionalOnWebApplication的条件类。 OnWebApplicationCondition重写SpringBootCondition的getMatchOutcome方法： 1234567891011121314151617181920@Overridepublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 配置类是否标注有@ConditionalOnWebApplication注解 boolean required = metadata .isAnnotated(ConditionalOnWebApplication.class.getName()); // 调用isWebApplication方法返回匹配结果 ConditionOutcome outcome = isWebApplication(context, metadata, required); // 若有标注@ConditionalOnWebApplication但不符合条件，则返回不匹配 if (required &amp;&amp; !outcome.isMatch()) &#123; return ConditionOutcome.noMatch(outcome.getConditionMessage()); &#125; // 若没有标注@ConditionalOnWebApplication但符合条件，则返回不匹配 if (!required &amp;&amp; outcome.isMatch()) &#123; return ConditionOutcome.noMatch(outcome.getConditionMessage()); &#125; // 这里返回匹配的情况 // TODO 疑问：如果没有标注@ConditionalOnWebApplication注解，又不符合条件的话，也会执行到这里，返回匹配？ return ConditionOutcome.match(outcome.getConditionMessage());&#125; 主要是调用isWebApplication方法来判断当前应用是否是web应用。因此，再来看下isWebApplication方法: 123456789101112131415private ConditionOutcome isWebApplication(ConditionContext context, AnnotatedTypeMetadata metadata, boolean required) &#123; // 调用deduceType方法判断是哪种类型，其中有SERVLET，REACTIVE和ANY类型，其中ANY表示了SERVLET或REACTIVE类型 switch (deduceType(metadata)) &#123; // SERVLET类型 case SERVLET: return isServletWebApplication(context); // REACTIVE类型 case REACTIVE: return isReactiveWebApplication(context); // ANY类型 default: return isAnyWebApplication(context, required); &#125;&#125; 在isWebApplication方法中，首先从@ConditionalOnWebApplication注解中获取其定义了什么类型，然后根据不同的类型进入不同的判断逻辑。这里看下SERVLET的情况判断处理，看isServletWebApplication代码： 12345678910111213141516171819202122232425262728private ConditionOutcome isServletWebApplication(ConditionContext context) &#123; ConditionMessage.Builder message = ConditionMessage.forCondition(&quot;&quot;); // 若classpath中不存在org.springframework.web.context.support.GenericWebApplicationContext.class，则返回不匹配 if (!ClassNameFilter.isPresent(SERVLET_WEB_APPLICATION_CLASS, context.getClassLoader())) &#123; return ConditionOutcome.noMatch( message.didNotFind(&quot;servlet web application classes&quot;).atAll()); &#125; // 若classpath中存在org.springframework.web.context.support.GenericWebApplicationContext.class，那么又分为以下几种匹配的情况 // session if (context.getBeanFactory() != null) &#123; String[] scopes = context.getBeanFactory().getRegisteredScopeNames(); if (ObjectUtils.containsElement(scopes, &quot;session&quot;)) &#123; return ConditionOutcome.match(message.foundExactly(&quot;&#x27;session&#x27; scope&quot;)); &#125; &#125; // ConfigurableWebEnvironment if (context.getEnvironment() instanceof ConfigurableWebEnvironment) &#123; return ConditionOutcome .match(message.foundExactly(&quot;ConfigurableWebEnvironment&quot;)); &#125; // WebApplicationContext if (context.getResourceLoader() instanceof WebApplicationContext) &#123; return ConditionOutcome.match(message.foundExactly(&quot;WebApplicationContext&quot;)); &#125; // 若以上三种都不匹配的话，则说明不是一个servlet web application return ConditionOutcome.noMatch(message.because(&quot;not a servlet web application&quot;));&#125; 对于是SERVLET的情况，首先根据classpath中是否存在org.springframework.web.context.support.GenericWebApplicationContext.class，如果不存在该类，则直接返回不匹配；若存在的话那么又分为以下几种匹配的情况： session ConfigurableWebEnvironment WebApplicationContext 若上面三种情况都不匹配，则说明不是一个servlet web application。 3.4 其他由于springboot的OnXXXCondition类实现太多，不可能每个条件类都分析一遍，因此上面只分析了OnResourceCondition,OnBeanCondition和onWebApplicationCondition的源码。分析源码不可能把所有代码都通读一遍的，阅读源码的话，只要理解了某个模块的类之间的关系及挑几个有代表性的类分析下就行，不可能一网打尽。 若有时间的话，推荐看下几个我们常用的条件类的源码：OnPropertyCondition,OnClassCondition和OnExpressionCondition等。 参考资料 https://blog.csdn.net/zhanglu1236789/article/details/78999496 https://www.cnblogs.com/sam-uncle/p/9111281.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(2)-SpringBoot源码的模块和结构]]></title>
    <url>%2Fposts%2F2020-11-16-SpringBoot-Source-02%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-SpringBoot源码的模块和结构 1.源码模块 源码项目主要有以下四个模块： 1. spring-boot-project：整个SpringBoot框架全部功能在这个模块实现，SpringBoot项目95%的代码都在这里实现，源码总共有26万行左右。 2. Spring-boot-samples：包含了各种各样使用SpringBoot的简单demo，调试阅读源码的时候可以充分利用该模块。 3. Spring-boot-sample-invoker：这个模块是跟samples模块有关，根pom.xml中有这么一句话：Samples are built via the invoker plugin，该模块无代码。 4. Spring-boot-tests：SpringBoot的测试模块，跟部署测试和集成测试有关。 SpringBoot的全部功能在spring-boot-project模块实现，因此下面重点来介绍下 spring-boot-project 模块。 2.spring-boot-project 模块 1) spring-boot-parent这个模块没有代码，是spring-boot模块的父项目，被其他子模块继承。 2) spring-boot这个模块是SpringBoot项目的核心，一些基础核心的功能都在这里实现，为SpringBoot的其他模块组件功能提供了支持，主要包括以下核心功能： 1. SpringApplication类，这个是SpringBoot的启动类，提供了一个静态的run方法来启动程序，该类主要用来创建并且刷新Spring容器ApplicationContext. 2. 支持选择不同的容器比如Tomcat,Jetty等来作为应用的嵌入容器。 3. 外部配置支持，执行java -jar xxx.jar命令时可以带一些参数，比如执行java -jar demo.jar --server.port=9999来将应用端口修改为9999. 4. 内置了一些SpringBoot启动时的生命周期事件和一些容器初始化器(ApplicationContext initializers)，来执行一些SpringBoot启动时的初始化逻辑。 3) spring-boot-autoconfigure这个模块跟SpringBoot的自动配置有关。比如SpringBoot能基于类路径来自动配置某个项目模块，自动配置最为关键的注解是@EnableAutoConfiguration,这个注解能触发Spring上下文的自动配置。另外一个重要的注解是@Conditional。 除了根据类路径来进行自动配置外，还有根据容器中是否存在某个bean等方式来进行自动配置。 4) spring-boot-starters这个模块是跟SpringBoot的起步依赖有关。SpringBoot通过提供各种各样的起步依赖降低项目依赖的复杂度。起步依赖其实就是利用maven项目模型将其他相关的依赖给聚合起来，里面各种依赖的版本号都给定义好，避免用户在引入依赖时出现各种版本冲突，方便了我们的使用。 比如说：要用到activemq时，可以直接引入spring-boot-starter-activemq起步依赖即可，若SpringBoot官网或第三方组织没有提供相应的SpringBoot起步依赖时，可以进行定制自己的起步依赖。 注意，该模块没有代码，主要是通过maven的pom.xml来组织各种依赖。 5) spring-boot-cliSpring Boot CLI是一个命令行工具，如果想使用Spring快速开发，可以使用它。允许运行Groovy脚本，这意味着有一个熟悉的类似Java的语法，而没有那么多样板代码。还可以引导一个新项目或编写自己的命令。 6) spring-boot-actuatorSpringBoot的监控模块。可以通过HTTP端点或JMX等来管理和监控应用。审计、运行状况和度量收集可以自动应用到应用程序。这个监控模块是开箱即用的，提供了一系列端点包括HealthEndpoint, EnvironmentEndpoint和BeansEndpoint等端点。 7) spring-boot-actuator-autoconfigure这个模块为spring-boot-actuator监控模块提供自动配置的功能，通常也是根据类路径来进行配置。比如Micrometer存在于类路径中，那么将会自动配置MetricsEndpoint。 8) spring-boot-test这个模块是spring-boot 测试有关的模块，包含了一些帮助测试的核心类和注解（比如@SpringBootTest）。 9) spring-boot-dependencies这个模块没有代码，主要是定义了一些SpringBoot的maven相关的一些依赖及其版本。 10) spring-boot-devtools这个模块跟SpringBoot的热部署有关，即修改代码后无需重启应用即生效。 11) spring-boot-docs这个是跟文档相关的模块。 12) spring-boot-properties-migratorSpringBoot 对外部化配置原生支持迁移功能，所谓迁移，具体是指对应配置的属性名变动，仍可以使用原来的属性名配置。 在 spring-configuration-metadata.json 的信息可以辅助 IDE 进行配置的提示，也可以用来完成配置的迁移。 13) spring-boot-test-autoconfigure这个模块是跟spring-boot-test的测试的自动配置有关。 14) spring-boot-tools这个模块是SpringBoot的工具相关的模块，提供了加载，maven插件，Gradle插件，metadata和后置处理相关的支持。 上面介绍了这么多spring-boot-project模块下的子模块，真正要重点分析的模块有spring-boot，spring-boot-autoconfigure，spring-boot-starters和spring-boot-actuator模块。 3. SpringBoot模块间的POM关系根据上面SpringBoot的各个模块的具体功能，来看下SpringBoot模块的pom之间的关系。 根据上图可以看到： 1. spring-boot-build(pom.xml)是项目的根pom，其子pom有spring-boot-project(pom.xml)和spring-boot-dependencies(pom.xml)； 2. spring-boot-dependencies(pom.xml)主要定义了SpringBoot项目的各种依赖及其版本，其子pom有spring-boot-parent(pom.xml)和spring-boot-starter-parent(pom.xml)； 3. spring-boot-project(pom.xml)有聚合module的作用，其子模块并不继承于它，而是继承于spring-boot-parent(pom.xml)； 4. spring-boot-parent(pom.xml)是spring-boot-project(pom.xml)的子module，但继承的父pom为spring-boot-dependencies(pom.xml)，其定义了一些properties等相关的东西。其子pom为spring-boot-project(pom.xml)的子module（注意除去spring-boot-dependencies(pom.xml)），比如有spring-boot(pom.xml),spring-boot-starters(pom.xml)和spring-boot-actuator(pom.xml)等； 5. spring-boot-starters(pom.xml)是所有具体起步依赖的父pom，其子pom有spring-boot-starter-data-jdbc(pom.xml)和spring-boot-starter-data-redis(pom.xml)等。 6. spring-boot-starter-parent(pom.xml)，是所有具体SpringBoot项目的父pom，比如SpringBoot自带的样例的spring-boot-samples(pom.xml)是继承于它的。 SpringBoot的各模块之间的pom关系有点复杂，可以打开idea的项目，逐个去捋一下。SpringBoot的父pom就是做一些版本管理，聚合模块之间的事情。 参考资料 https://github.com/spring-projects/spring-boot/tree/v2.1.0.RELEASE https://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#cli]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码分析(1)-搭建SpringBoot源码调试环境]]></title>
    <url>%2Fposts%2F2020-11-15-SpringBoot-Source-01%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录SpringBoot的源码分析过程-搭建SpringBoot源码调试环境 1.下载源码SpringBoot v2.1.0.RELEASE 的github地址： https://github.com/spring-projects/spring-boot/tree/v2.1.0.RELEASE 2.IDEA导入源码Springboot 2.1.0的版本是maven构建的，因此使用maven的方式导入IDEA。 这里建议maven配置下仓库的源。 3.编译构建源码这里Kotlin的版本过低，需要调整下Kotlin的版本，我们找到 1spring-boot-2.1.0.RELEASE\spring-boot-project\spring-boot-parent\pom.xml 将 1.1的版本改为 1.2，如下所示： 直接项目根目录下，执行以下maven命令来编译构建源码： 1mvn clean install -DskipTests -Pfast 之后就是漫长的等待，我这里等待了8分钟左右（电脑配置比较渣，手动狗头） 4.运行源码自带的sample源码中spring-boot-samples 模块中提供了很多demo，我们可以随便选一个来进行调试。 首先，把spring-boot-samples 模块加入项目pom.xml中： 然后，选择spring-boot-sample-tomcat项目进行测试： 运行 SampleTomcatApplication main方法，结果如下： 在浏览器访问 http://127.0.0.1:8080 结果如下： 总结编译过程中，还是出现了些问题，包括上面的修改Kotlin的版本，耐心点，都能解决的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-day03]]></title>
    <url>%2Fposts%2F2020-11-04-JVM-day03%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录JVM的学习过程-类加载与字节码技术 1.类文件结构一个简单的HelloWorld.java: 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello world&quot;); &#125;&#125; 执行 javac 命令： 1javac -parameters -d . HelloWorld.java 得到HelloWorld.class文件 这里使用的是Windows环境，使用UltraEdit或者WinHex工具打开class文件。如果是Linux环境，可以使用如下命令打开class文件： 1od -t xC HelloWorld.class 打开class文件结果如下： 根据JVM规范，类文件结果如下: 123456789101112131415161718ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];&#125; 参考资料：Oracle官方文档 1.1 魔数1u4 magic; The magic item supplies the magic number identifying the class file format; it has the value 0xCAFEBABE. 100000000h: CA FE BA BE 00 00 00 34 00 23 0A 00 06 00 15 09 0-3字节，CA FE BA BE 表示是否是class类型的文件 1.2 版本12u2 minor_version;u2 major_version; 100000000h: CA FE BA BE 00 00 00 34 00 23 0A 00 06 00 15 09 4-7字节，00 00 00 34 表示类的版本 0x34（十进制52）表明是java8 1.3 常量池12u2 constant_pool_count;cp_info constant_pool[constant_pool_count-1]; Constant Type Value CONSTANT_Class 7 CONSTANT_Fieldref 9 CONSTANT_Methodref 10 CONSTANT_InterfaceMethodref 11 CONSTANT_String 8 CONSTANT_Integer 3 CONSTANT_Float 4 CONSTANT_Long 5 CONSTANT_Double 6 CONSTANT_NameAndType 12 CONSTANT_Utf8 1 CONSTANT_MethodHandle 15 CONSTANT_MethodType 16 CONSTANT_InvokeDynamic 18 1234567891011121314151617181920212223242526272800000000h: CA FE BA BE 00 00 00 34 00 23 0A 00 06 00 15 0900000010h: 00 16 00 17 08 00 18 0A 00 19 00 1A 07 00 1B 0700000020h: 00 1C 01 00 06 3C 69 6E 69 74 3E 01 00 03 28 2900000030h: 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E00000040h: 75 6D 62 65 72 54 61 62 6C 65 01 00 12 4C 6F 6300000050h: 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65 0100000060h: 00 04 74 68 69 73 01 00 24 4C 70 75 62 2F 69 7900000070h: 75 2F 73 65 2F 6A 76 6D 64 61 79 2F 64 61 79 3000000080h: 33 2F 48 65 6C 6C 6F 57 6F 72 6C 64 3B 01 00 0400000090h: 6D 61 69 6E 01 00 16 28 5B 4C 6A 61 76 61 2F 6C000000a0h: 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 01 00 04000000b0h: 61 72 67 73 01 00 13 5B 4C 6A 61 76 61 2F 6C 61000000c0h: 6E 67 2F 53 74 72 69 6E 67 3B 01 00 10 4D 65 74000000d0h: 68 6F 64 50 61 72 61 6D 65 74 65 72 73 01 00 0A000000e0h: 53 6F 75 72 63 65 46 69 6C 65 01 00 0F 48 65 6C000000f0h: 6C 6F 57 6F 72 6C 64 2E 6A 61 76 61 0C 00 07 0000000100h: 08 07 00 1D 0C 00 1E 00 1F 01 00 0B 48 65 6C 6C00000110h: 6F 20 77 6F 72 6C 64 07 00 20 0C 00 21 00 22 0100000120h: 00 22 70 75 62 2F 69 79 75 2F 73 65 2F 6A 76 6D00000130h: 64 61 79 2F 64 61 79 30 33 2F 48 65 6C 6C 6F 5700000140h: 6F 72 6C 64 01 00 10 6A 61 76 61 2F 6C 61 6E 6700000150h: 2F 4F 62 6A 65 63 74 01 00 10 6A 61 76 61 2F 6C00000160h: 61 6E 67 2F 53 79 73 74 65 6D 01 00 03 6F 75 7400000170h: 01 00 15 4C 6A 61 76 61 2F 69 6F 2F 50 72 69 6E00000180h: 74 53 74 72 65 61 6D 3B 01 00 13 6A 61 76 61 2F00000190h: 69 6F 2F 50 72 69 6E 74 53 74 72 65 61 6D 01 00000001a0h: 07 70 72 69 6E 74 6C 6E 01 00 15 28 4C 6A 61 76000001b0h: 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 8-9字节，表示常量池长度，00 23（十进制35）表示常量池有#1-#34项，注意#0项不计入，也没有值 cp_info: #1-#34 第#1项 0A 00 06 00 15 0A表示一个Method信息CONSTANT_Methodref，00 06（十进制6） 和 00 15（十进制21）表示它引用了常量池中#6和#21项来获得这个方法的[所属类]和[方法名] 第#2项 09 00 16 00 17 09表示一个Field信息CONSTANT_Fieldref，00 16（十进制22） 和 00 17（十进制23）表示它引用了常量池中#22和#23项来获得这个方法的[所属类]和[成员变量名] 第#3项 08 00 18 08表示一个字符串常量名称CONSTANT_String，00 18（十进制24）表示它引用了常量池中#24项 第#4项 0A 00 19 00 1A 0A表示一个Method信息CONSTANT_Methodref，00 19（十进制25） 和 00 1A（十进制26）表示它引用了常量池中#25和#26项来获得这个方法的[所属类]和[方法名] 第#5项 07 00 1B 07表示一个Class信息CONSTANT_Class，00 1B（十进制27）表示它引用了常量池中#27项 第#6项 07 00 1C 07表示一个Class信息CONSTANT_Class，00 1C（十进制28）表示它引用了常量池中#28项 第#7项 01 00 06 3C 69 6E 69 74 3E 01表示一个Utf8串CONSTANT_Utf8，00 06（十进制6） 表示长度，3C 69 6E 69 74 3E 是【】(构造方法) 第#8项 01 00 03 28 29 56 01表示一个Utf8串CONSTANT_Utf8，00 03（十进制3）表示长度，28 29 56是【()V】其实就是表示无参，无返回值 第#9项 01 00 04 43 6F 64 65 01表示一个Utf8串CONSTANT_Utf8，00 04（十进制4）表示长度， 43 6F 64 65是【Code】 第#10项 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 01表示一个Utf8串CONSTANT_Utf8，00 0F（十进制15）表示长度， 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 是【LineNumberTable】 第#11项 01 00 12 4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65 01表示一个Utf8串CONSTANT_Utf8，00 12（十进制18） 表示长度， 4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65是【LocalVariableTable】 第#12项 01 00 04 74 68 69 73 01表示一个Utf8串CONSTANT_Utf8，00 04（十进制4）表示长度，74 68 69 73 是【this】 第#13项 01 00 24 4C 70 75 62 2F 69 79 75 2F 73 65 2F 6A 76 6D 64 61 79 2F 64 61 79 30 33 2F 48 65 6C 6C 6F 57 6F 72 6C 64 3B 01表示一个Utf8串CONSTANT_Utf8，00 24（十进制36）表示长度，4C 70 75 62 2F 69 79 75 2F 73 65 2F 6A 76 6D 64 61 79 2F 64 61 79 30 33 2F 48 65 6C 6C 6F 57 6F 72 6C 64 3B是【Lpub/iyu/se/jvmday/day03/HelloWorld;】 第#14项 01 00 04 6D 61 69 6E 01表示一个Utf8串CONSTANT_Utf8，00 04（十进制4）表示长度，6D 61 69 6E是【main】 第#15项 01 00 16 28 5B 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 01表示一个Utf8串CONSTANT_Utf8，00 16（十进制22）表示长度，5B 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值 第#16项 01 00 04 61 72 67 73 01表示一个Utf8串CONSTANT_Utf8，00 04（十进制4）表示长度，61 72 67 73是【args】 第#17项 01 00 13 5B 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 01表示一个Utf8串CONSTANT_Utf8，00 13（十进制19）表示长度，5B 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B是【Ljava/lang/String;】 第#18项 01 00 10 4D 65 74 68 6F 64 50 61 72 61 6D 65 74 65 72 73 01表示一个Utf8串CONSTANT_Utf8，00 10（十进制16）表示长度，4D 65 74 68 6F 64 50 61 72 61 6D 65 74 65 72 73是【MethodParameters】 第#19项 01 00 0A 53 6F 75 72 63 65 46 69 6C 65 01表示一个Utf8串CONSTANT_Utf8，00 0A（十进制10）表示长度，53 6F 75 72 63 65 46 69 6C 65是【SourceFile】 第#20项 01 00 0F 48 65 6C 6C 6F 57 6F 72 6C 64 2E 6A 61 76 61 01表示一个Utf8串CONSTANT_Utf8，00 0F（十进制15）表示长度，48 65 6C 6C 6F 57 6F 72 6C 64 2E 6A 61 76 61是【HelloWorld.java】 第#21项 0C 00 07 00 08 0C表示一个【名+类型】CONSTANT_NameAndType，00 07 00 08 引用了常量池中#7和#8两项 第#22项 07 00 1D 07表示一个Class信息CONSTANT_Class，00 1D（十进制29）表示它引用了常量池中#29项 第#23项 0C 00 1E 00 1F 0C表示一个【名+类型】CONSTANT_NameAndType，00 1E （十进制30）和 00 1F（十进制31）表示它引用了常量池中#30和#31两项 第#24项 01 00 0B 48 65 6C 6C 6F 20 77 6F 72 6C 64 01表示一个Utf8串CONSTANT_Utf8，00 0B（十进制11）表示长度，48 65 6C 6C 6F 20 77 6F 72 6C 64是【Hello world】 第#25项 07 00 20 07表示一个Class信息CONSTANT_Class，00 20（十进制32） 表示它引用了常量池中#32项 第#26项 0C 00 21 00 22 0C表示一个【名+类型】CONSTANT_NameAndType，00 21（十进制33） 和 00 22（十进制34）表示它引用了常量池中#33和#34两项 第#27项 01 00 22 70 75 62 2F 69 79 75 2F 73 65 2F 6A 76 6D 64 61 79 2F 64 61 79 30 33 2F 48 65 6C 6C 6F 57 6F 72 6C 64 01表示一个Utf8串CONSTANT_Utf8，00 22（十进制34）表示长度，70 75 62 2F 69 79 75 2F 73 65 2F 6A 76 6D 64 61 79 2F 64 61 79 30 33 2F 48 65 6C 6C 6F 57 6F 72 6C 64是【pub/iyu/se/jvmday/day03/HelloWorld】 第#28项 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 01表示一个Utf8串CONSTANT_Utf8，00 10（十进制16）表示长度，6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74是【java/lang/Object】 第#29项 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 53 79 73 74 65 6D 01表示一个Utf8串CONSTANT_Utf8，00 10（十进制16）表示长度，6A 61 76 61 2F 6C 61 6E 67 2F 53 79 73 74 65 6D是【java/lang/System】 第#30项 01 00 03 6F 75 74 01表示一个Utf8串CONSTANT_Utf8，00 03（十进制3）表示长度，6F 75 74是【out】 第#31项 01 00 15 4C 6A 61 76 61 2F 69 6F 2F 50 72 69 6E 74 53 74 72 65 61 6D 3B 01表示一个Utf8串CONSTANT_Utf8，00 15（十进制21）表示长度，4C 6A 61 76 61 2F 69 6F 2F 50 72 69 6E 74 53 74 72 65 61 6D 3B是【Ljava/io/PrintStream;】 第#32项 01 00 13 6A 61 76 61 2F 69 6F 2F 50 72 69 6E 74 53 74 72 65 61 6D 01表示一个Utf8串CONSTANT_Utf8，00 13（十进制19）表示长度，6A 61 76 61 2F 69 6F 2F 50 72 69 6E 74 53 74 72 65 61 6D是【java/io/PrintStream】 第#33项 01 00 07 70 72 69 6E 74 6C 6E 01表示一个Utf8串CONSTANT_Utf8，00 07（十进制7）表示长度，70 72 69 6E 74 6C 6E是【println】 第#34项 01 00 15 28 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 01表示一个Utf8串CONSTANT_Utf8，00 15（十进制21）表示长度，28 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 是【(Ljava/lang/String;)V】 1.4 访问标识与继承信息12345u2 access_flags;u2 this_class;u2 super_class;u2 interfaces_count;u2 interfaces[interfaces_count]; Field access and property flags： Flag Name Value Interpretation ACC_PUBLIC 0x0001 Declared public; may be accessed from outside its package. ACC_PRIVATE 0x0002 Declared private; usable only within the defining class. ACC_PROTECTED 0x0004 Declared protected; may be accessed within subclasses. ACC_STATIC 0x0008 Declared static. ACC_FINAL 0x0010 Declared final; never directly assigned to after object construction (JLS §17.5). ACC_VOLATILE 0x0040 Declared volatile; cannot be cached. ACC_TRANSIENT 0x0080 Declared transient; not written or read by a persistent object manager. ACC_SYNTHETIC 0x1000 Declared synthetic; not present in the source code. ACC_ENUM 0x4000 Declared as an element of an enum. 1000001c0h: 00 21 00 05 00 06 00 00 00 00 00 02 00 01 00 07 00 21 表示该class是一个类，公共的 00 05 表示根据常量池中#5找到本类全限定名 00 06 表示根据常量池中#6找到父类全限定名 00 00 表示接口的数量，本类为0 1.5 Field信息12u2 fields_count;field_info fields[fields_count]; 1000001c0h: 00 21 00 05 00 06 00 00 00 00 00 02 00 01 00 07 00 00 表示成员变量数量，本类为0 FieldType term Type Interpretation B byte signed byte C char Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 D double double-precision floating-point value F float single-precision floating-point value I int integer J long long integer L ClassName ; reference an instance of class ClassName S short signed short Z boolean true or false [ reference one array dimension 1.6 Method信息12u2 methods_count;method_info methods[methods_count]; Method access and property flags： Flag Name Value Interpretation ACC_PUBLIC 0x0001 Declared public; may be accessed from outside its package. ACC_PRIVATE 0x0002 Declared private; accessible only within the defining class. ACC_PROTECTED 0x0004 Declared protected; may be accessed within subclasses. ACC_STATIC 0x0008 Declared static. ACC_FINAL 0x0010 Declared final; must not be overridden (§5.4.5). ACC_SYNCHRONIZED 0x0020 Declared synchronized; invocation is wrapped by a monitor use. ACC_BRIDGE 0x0040 A bridge method, generated by the compiler. ACC_VARARGS 0x0080 Declared with variable number of arguments. ACC_NATIVE 0x0100 Declared native; implemented in a language other than Java. ACC_ABSTRACT 0x0400 Declared abstract; no implementation is provided. ACC_STRICT 0x0800 Declared strictfp; floating-point mode is FP-strict. ACC_SYNTHETIC 0x1000 Declared synthetic; not present in the source code. 12345000001c0h: 00 21 00 05 00 06 00 00 00 00 00 02 00 01 00 07000001d0h: 00 08 00 01 00 09 00 00 00 2F 00 01 00 01 00 00000001e0h: 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00000001f0h: 06 00 01 00 00 00 09 00 0B 00 00 00 0C 00 01 0000000200h: 00 00 05 00 0C 00 0D 00 00 00 09 00 0E 00 0F 00 00 02 表示方法数量，本类为2 一个方法由 访问修饰符 + 名称 + 参数描述 + 方法属性数量 + 方法属性 组成 00 01 代表访问修饰符（本类中是public） 00 07 代表引用了常量池#07项作为方法名称 00 08 代表引用了常量池#08项作为方法参数描述 00 01 代表方法属性数量，本方法是1 方法属性：12345678910111213141516171819201. 00 09 表示引用了常量池#09项，是【Code】属性2. 00 00 00 2F 表示此属性的长度是473. 00 01 表示【操作数栈】最大深度4. 00 01 表示【局部变量表】最大槽数（slot）5. 00 00 00 05 表示字节码长度，本例是56. 2A B7 00 01 B1 是字节码指令7. 00 00 00 02 表示方法细节属性数量，本例是28. 00 0A 表示引用了常量池#10项，是【LineNumberTable】属性 00 00 00 06 表示此属性的总长度，本例是6 00 01 表示【LineNumberTable】长度 00 00 表示【字节码】行号 00 09 表示【java源码】行号9. 00 0B 表示引用了常量池#11项，是【LocalVariableTable】属性 00 00 00 0C 表示此属性的总长度，本例是12 00 01 表示【LocalVariableTable】长度 00 00 表示局部变量生命周期开始，相当于字节码的偏移量 00 05 表示局部变量覆盖的范围长度 00 0C 表示局部变量名称，本例引用了常量池#12项，是【this】 00 0D 表示局部变量的类型，本例引用了常量池#13项，是【Lpub/iyu/se/jvmday/day03/HelloWorld;】 00 00 表示局部变量占有的槽位(slot)编号，本例是0 12345600000200h: 00 00 05 00 0C 00 0D 00 00 00 09 00 0E 00 0F 0000000210h: 02 00 09 00 00 00 37 00 02 00 01 00 00 00 09 B200000220h: 00 02 12 03 B6 00 04 B1 00 00 00 02 00 0A 00 0000000230h: 00 0A 00 02 00 00 00 0B 00 08 00 0C 00 0B 00 0000000240h: 00 0C 00 01 00 00 00 09 00 10 00 11 00 00 00 1200000250h: 00 00 00 05 01 00 10 00 00 00 01 00 13 00 00 00 00 09 代表访问修饰符（本类中是public static） 00 0E 代表引用了常量池#14项作为方法名称 00 0F 代表引用了常量池#15项作为方法参数描述 00 02 代表方法属性数量，本方法是2 方法属性1：1234567891011121314151617181920212200 09 表示引用了常量池#09项，是【Code】属性00 00 00 37 表示此属性的长度是5500 02 表示【操作数栈】最大深度00 01 表示【局部变量表】最大槽数（slot）00 00 00 09 表示字节码长度，本例是9B2 00 02 12 03 B6 00 04 B1 是字节码指令00 00 00 02 表示方法细节属性数量，本例是200 0A 表示引用了常量池#10项，是【LineNumberTable】属性 00 00 00 0A 表示此属性的总长度，本例是10 00 02 表示【LineNumberTable】长度 00 00 表示【字节码】行号 00 0B 表示【java源码】行号 00 08 表示【字节码】行号 00 0C 表示【java源码】行号00 0B 表示引用了常量池#11项，是【LocalVariableTable】属性 00 00 00 0C 表示此属性的总长度，本例是12 00 01 表示【LocalVariableTable】长度 00 00 表示局部变量生命周期开始，相当于字节码的偏移量 00 09 表示局部变量覆盖的范围长度 00 10 表示局部变量名称，本例引用了常量池#16项，是【args】 00 11 表示局部变量的类型，本例引用了常量池#17项，是【Ljava/lang/String;】 00 00 表示局部变量占有的槽位(slot)编号，本例是0 方法属性2：1234500 12 表示引用了常量池#18项，发现是【MethodParameters】属性00 00 00 05 表示此属性的总长度，本例是501 参数数量00 10 表示引用了常量池#16项，是【args】00 00 表示访问修饰符 1.7 附加属性12u2 attributes_count;attribute_info attributes[attributes_count]; 1200000250h: 00 00 00 05 01 00 10 00 00 00 01 00 13 00 00 0000000260h: 02 00 14 123400 01 表示附加属性数量00 13 表示引用了常量池#19项，即【SourceFile】00 00 00 02 表示此属性的长度00 14 表示引用了常量池#20项，即【HelloWorld.java】 参考资料：点击打开 2.字节码指令2.1 分析根据上面的分析，有两组字节码指令： (1)public pub.iyu.se.jvmday.day03.HelloWorld(); 构造方法的字节码指令 2A B7 00 01 B1 1.2A =&gt; aload_0加载slot()的局部变量，即this，作为下面的invokespecial构造方法调用的参数 2.B7 =&gt; invokespecial预备调用构造方法，哪个方法呢？ 3.00 01 =&gt; 引用常量池中#1项，即【Method java/lang/Object.&quot;&lt;init&gt;&quot;:()v】 4.B1 =&gt; 表示返回 (2)public static void main(java.lang.String[]) 主方法的字节码指令 B2 00 02 12 03 B6 00 04 B1 1.B2 =&gt; getstatic用来加载静态变量，哪个静态变量呢？ 2.00 02 =&gt; 引用常量池中#2项，即【Field java/lang/System.out:Ljava/io/PrintStream;】 3.12 =&gt; ldc加载参数，哪个参数呢？ 4.03 =&gt; 引用常量池中#3项，即【String Hello world】 5.B6 =&gt; invokevirtual预备调用成员方法，哪个方法呢？ 6.00 04 =&gt; 引用常量池中#4项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】 7.B1 =&gt; 表示返回 参考资料：点击打开 2.2 javap工具Oracle 提供javap工具来反编译class文件 1javap -v HelloWorld.class 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778Classfile /E:/HelloWorld.class Last modified 2020-11-20; size 611 bytes MD5 checksum 93d2a7c13284af1a96716e531e2f45e4 Compiled from &quot;HelloWorld.java&quot;public class pub.iyu.se.jvmday.day03.HelloWorld minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #22.#23 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #24 // Hello world #4 = Methodref #25.#26 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #27 // pub/iyu/se/jvmday/day03/HelloWorld #6 = Class #28 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lpub/iyu/se/jvmday/day03/HelloWorld; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 MethodParameters #19 = Utf8 SourceFile #20 = Utf8 HelloWorld.java #21 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #22 = Class #29 // java/lang/System #23 = NameAndType #30:#31 // out:Ljava/io/PrintStream; #24 = Utf8 Hello world #25 = Class #32 // java/io/PrintStream #26 = NameAndType #33:#34 // println:(Ljava/lang/String;)V #27 = Utf8 pub/iyu/se/jvmday/day03/HelloWorld #28 = Utf8 java/lang/Object #29 = Utf8 java/lang/System #30 = Utf8 out #31 = Utf8 Ljava/io/PrintStream; #32 = Utf8 java/io/PrintStream #33 = Utf8 println #34 = Utf8 (Ljava/lang/String;)V&#123; public pub.iyu.se.jvmday.day03.HelloWorld(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 9: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lpub/iyu/se/jvmday/day03/HelloWorld; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello world 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 11: 0 line 12: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; MethodParameters: Name Flags args&#125;SourceFile: &quot;HelloWorld.java&quot; 2.3 方法执行流程(1) Demo代码如下： 12345678public class TestDemo0301 &#123; public static void main(String[] args) &#123; int a = 10; int b = Short.MAX_VALUE + 1; int c = a + b; System.out.println(c); &#125;&#125; (2)编译后的字节码文件 javap -v TestDemo0301.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697Classfile /E:/TestDemo0301.class Last modified 2020-11-23; size 676 bytes MD5 checksum 0292b59b6c598154c1fa633b3ccb3c74 Compiled from &quot;TestDemo0301.java&quot;public class pub.iyu.se.jvmday.day03.TestDemo0301 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #7.#26 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #27 // java/lang/Short #3 = Integer 32768 #4 = Fieldref #28.#29 // java/lang/System.out:Ljava/io/PrintStream; #5 = Methodref #30.#31 // java/io/PrintStream.println:(I)V #6 = Class #32 // pub/iyu/se/jvmday/day03/TestDemo0301 #7 = Class #33 // java/lang/Object #8 = Utf8 &lt;init&gt; #9 = Utf8 ()V #10 = Utf8 Code #11 = Utf8 LineNumberTable #12 = Utf8 LocalVariableTable #13 = Utf8 this #14 = Utf8 Lpub/iyu/se/jvmday/day03/TestDemo0301; #15 = Utf8 main #16 = Utf8 ([Ljava/lang/String;)V #17 = Utf8 args #18 = Utf8 [Ljava/lang/String; #19 = Utf8 a #20 = Utf8 I #21 = Utf8 b #22 = Utf8 c #23 = Utf8 MethodParameters #24 = Utf8 SourceFile #25 = Utf8 TestDemo0301.java #26 = NameAndType #8:#9 // &quot;&lt;init&gt;&quot;:()V #27 = Utf8 java/lang/Short #28 = Class #34 // java/lang/System #29 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #30 = Class #37 // java/io/PrintStream #31 = NameAndType #38:#39 // println:(I)V #32 = Utf8 pub/iyu/se/jvmday/day03/TestDemo0301 #33 = Utf8 java/lang/Object #34 = Utf8 java/lang/System #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Utf8 java/io/PrintStream #38 = Utf8 println #39 = Utf8 (I)V&#123; public pub.iyu.se.jvmday.day03.TestDemo0301(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 9: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lpub/iyu/se/jvmday/day03/TestDemo0301; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: bipush 10 2: istore_1 3: ldc #3 // int 32768 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 13: iload_3 14: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 11: 0 line 12: 3 line 13: 6 line 14: 10 line 15: 17 LocalVariableTable: Start Length Slot Name Signature 0 18 0 args [Ljava/lang/String; 3 15 1 a I 6 12 2 b I 10 8 3 c I MethodParameters: Name Flags args&#125;SourceFile: &quot;TestDemo0301.java&quot; (3)常量池 载入 运行时常量池 (4)方法字节码载入方法区 (5)main线程开始运行，分配栈帧内存 stack=2(操作数栈), locals=4(局部变量表) (6)执行引擎开始执行字节码 bipush 10 将一个byte压入操作数栈（其长度会补齐4个字节） 类似的指令还有： 1. sipush 将一个short压入操作数栈（其长度会补齐4个字节） 2. ldc将一个int压入操作数栈 3. ldc2_w将一个long压入操作数栈（分两次压入，因为long是8个字节） 这里小的数字都是和字节码指令存在一起，超过short范围的数字存入了常量池 istore 1 将操作数栈顶数据弹出，存入局部变量表的slot 1 ldc #3 从常量池加载#3数据到操作数栈 注意：Short.MAX_VALUE是32767，所以32768=Short.MAX_VALUE + 1 实际是在编译期间计算好的 istore 2 iload 1 iload 2 iadd istore 3 getstatic #4 iload 3 invokevirtual #5 找到常量池#5项 定位到方法区 java/io/PrintStream.println:(I)V方法 生成新的栈帧（分配locals、stack等） 传递参数，执行新栈帧中的字节码 执行完毕，弹出栈帧 清除main操作数栈内容 return 完成main方法调用，弹出main栈帧，程序结束 2.4 分析 i++从字节码的角度分析 i++ 相关问题 源码如下： 12345678public class TestDemo0302 &#123; public static void main(String[] args) &#123; int a = 10; int b = a++ + ++a + a--; System.out.println(a); System.out.println(b); &#125;&#125; 字节码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Classfile /E:/TestDemo0302.class Last modified 2020-11-24; size 651 bytes MD5 checksum 46b35f856d1e5581c28225b908080dc0 Compiled from &quot;TestDemo0302.java&quot;public class pub.iyu.se.jvmday.day03.TestDemo0302 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #5.#23 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #24.#25 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #26.#27 // java/io/PrintStream.println:(I)V #4 = Class #28 // pub/iyu/se/jvmday/day03/TestDemo0302 #5 = Class #29 // java/lang/Object #6 = Utf8 &lt;init&gt; #7 = Utf8 ()V #8 = Utf8 Code #9 = Utf8 LineNumberTable #10 = Utf8 LocalVariableTable #11 = Utf8 this #12 = Utf8 Lpub/iyu/se/jvmday/day03/TestDemo0302; #13 = Utf8 main #14 = Utf8 ([Ljava/lang/String;)V #15 = Utf8 args #16 = Utf8 [Ljava/lang/String; #17 = Utf8 a #18 = Utf8 I #19 = Utf8 b #20 = Utf8 MethodParameters #21 = Utf8 SourceFile #22 = Utf8 TestDemo0302.java #23 = NameAndType #6:#7 // &quot;&lt;init&gt;&quot;:()V #24 = Class #30 // java/lang/System #25 = NameAndType #31:#32 // out:Ljava/io/PrintStream; #26 = Class #33 // java/io/PrintStream #27 = NameAndType #34:#35 // println:(I)V #28 = Utf8 pub/iyu/se/jvmday/day03/TestDemo0302 #29 = Utf8 java/lang/Object #30 = Utf8 java/lang/System #31 = Utf8 out #32 = Utf8 Ljava/io/PrintStream; #33 = Utf8 java/io/PrintStream #34 = Utf8 println #35 = Utf8 (I)V&#123; public pub.iyu.se.jvmday.day03.TestDemo0302(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 9: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lpub/iyu/se/jvmday/day03/TestDemo0302; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: bipush 10 2: istore_1 3: iload_1 4: iinc 1, 1 7: iinc 1, 1 10: iload_1 11: iadd 12: iload_1 13: iinc 1, -1 16: iadd 17: istore_2 18: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 21: iload_1 22: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 25: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 28: iload_2 29: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 32: return LineNumberTable: line 11: 0 line 12: 3 line 13: 18 line 14: 25 line 15: 32 LocalVariableTable: Start Length Slot Name Signature 0 33 0 args [Ljava/lang/String; 3 30 1 a I 18 15 2 b I MethodParameters: Name Flags args&#125;SourceFile: &quot;TestDemo0302.java&quot; 分析: 注意iinc指令是直接在局部变量slot上进行运算 a++ 和++a的区别是先执行iload还是先执行iinc (1)a++ 先执行iload，再执行iinc (2)++a 先执行iinc，再执行iload 2.5 条件判断指令 说明： 1. byte，short，char 都会按int比较，因为操作数栈都是4字节 2. goto 用来进行跳转到指定行号的字节码 源码： 12345678public static void main(String[] args) &#123; int a = 0; if(a == 0)&#123; a = 10; &#125;else &#123; a = 20; &#125;&#125; 字节码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Classfile /E:/TestDemo0303.class Last modified 2020-12-10; size 535 bytes MD5 checksum 0a17c88bcb86b283e848b2a38d73bce6 Compiled from &quot;TestDemo0303.java&quot;public class pub.iyu.se.jvmday.day03.TestDemo0303 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #3.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #22 // pub/iyu/se/jvmday/day03/TestDemo0303 #3 = Class #23 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 LocalVariableTable #9 = Utf8 this #10 = Utf8 Lpub/iyu/se/jvmday/day03/TestDemo0303; #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 args #14 = Utf8 [Ljava/lang/String; #15 = Utf8 a #16 = Utf8 I #17 = Utf8 StackMapTable #18 = Utf8 MethodParameters #19 = Utf8 SourceFile #20 = Utf8 TestDemo0303.java #21 = NameAndType #4:#5 // &quot;&lt;init&gt;&quot;:()V #22 = Utf8 pub/iyu/se/jvmday/day03/TestDemo0303 #23 = Utf8 java/lang/Object&#123; public pub.iyu.se.jvmday.day03.TestDemo0303(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 9: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lpub/iyu/se/jvmday/day03/TestDemo0303; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=2, args_size=1 0: iconst_0 1: istore_1 2: iload_1 3: ifne 12 6: bipush 10 8: istore_1 9: goto 15 12: bipush 20 14: istore_1 15: return LineNumberTable: line 11: 0 line 12: 2 line 13: 6 line 15: 12 line 17: 15 LocalVariableTable: Start Length Slot Name Signature 0 16 0 args [Ljava/lang/String; 2 14 1 a I StackMapTable: number_of_entries = 2 frame_type = 252 /* append */ offset_delta = 12 locals = [ int ] frame_type = 2 /* same */ MethodParameters: Name Flags args&#125;SourceFile: &quot;TestDemo0303.java&quot; 关于比较指令中 long float double 的比较，可以参考资料 2.6 循环控制指令while循环： 123456public static void main(String[] args) &#123; int a = 0; while(a &lt; 0)&#123; a++; &#125;&#125; 字节码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Classfile /E:/TestDemo0304.class Last modified 2020-12-10; size 530 bytes MD5 checksum 016d8b924c6a38e2d2f72ab9734593a3 Compiled from &quot;TestDemo0304.java&quot;public class pub.iyu.se.jvmday.day03.TestDemo0304 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #3.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #22 // pub/iyu/se/jvmday/day03/TestDemo0304 #3 = Class #23 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 LocalVariableTable #9 = Utf8 this #10 = Utf8 Lpub/iyu/se/jvmday/day03/TestDemo0304; #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 args #14 = Utf8 [Ljava/lang/String; #15 = Utf8 a #16 = Utf8 I #17 = Utf8 StackMapTable #18 = Utf8 MethodParameters #19 = Utf8 SourceFile #20 = Utf8 TestDemo0304.java #21 = NameAndType #4:#5 // &quot;&lt;init&gt;&quot;:()V #22 = Utf8 pub/iyu/se/jvmday/day03/TestDemo0304 #23 = Utf8 java/lang/Object&#123; public pub.iyu.se.jvmday.day03.TestDemo0304(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 9: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lpub/iyu/se/jvmday/day03/TestDemo0304; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: iconst_0 1: istore_1 2: iload_1 3: bipush 10 5: if_icmpge 14 8: iinc 1, 1 11: goto 2 14: return LineNumberTable: line 11: 0 line 12: 2 line 13: 8 line 15: 14 LocalVariableTable: Start Length Slot Name Signature 0 15 0 args [Ljava/lang/String; 2 13 1 a I StackMapTable: number_of_entries = 2 frame_type = 252 /* append */ offset_delta = 2 locals = [ int ] frame_type = 11 /* same */ MethodParameters: Name Flags args&#125;SourceFile: &quot;TestDemo0304.java&quot; do while循环： 123456public static void main(String[] args) &#123; int a = 0; do &#123; a++; &#125; while(a &lt; 10);&#125; 字节码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Classfile /E:/TestDemo0305.class Last modified 2020-12-10; size 526 bytes MD5 checksum 100b9f049f784b67731ee8c992011082 Compiled from &quot;TestDemo0305.java&quot;public class pub.iyu.se.jvmday.day03.TestDemo0305 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #3.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #22 // pub/iyu/se/jvmday/day03/TestDemo0305 #3 = Class #23 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 LocalVariableTable #9 = Utf8 this #10 = Utf8 Lpub/iyu/se/jvmday/day03/TestDemo0305; #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 args #14 = Utf8 [Ljava/lang/String; #15 = Utf8 a #16 = Utf8 I #17 = Utf8 StackMapTable #18 = Utf8 MethodParameters #19 = Utf8 SourceFile #20 = Utf8 TestDemo0305.java #21 = NameAndType #4:#5 // &quot;&lt;init&gt;&quot;:()V #22 = Utf8 pub/iyu/se/jvmday/day03/TestDemo0305 #23 = Utf8 java/lang/Object&#123; public pub.iyu.se.jvmday.day03.TestDemo0305(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 9: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lpub/iyu/se/jvmday/day03/TestDemo0305; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: bipush 10 8: if_icmplt 2 11: return LineNumberTable: line 11: 0 line 13: 2 line 14: 5 line 15: 11 LocalVariableTable: Start Length Slot Name Signature 0 12 0 args [Ljava/lang/String; 2 10 1 a I StackMapTable: number_of_entries = 1 frame_type = 252 /* append */ offset_delta = 2 locals = [ int ] MethodParameters: Name Flags args&#125;SourceFile: &quot;TestDemo0305.java&quot; 2.7 判断结果2.8 构造方法2.9 方法调用2.10 多态的原理2.11 异常处理2.12 finally2.13 synchronized3.编译期处理4.类加载阶段5.类加载器6.运行期优化未完待续。。。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-day02]]></title>
    <url>%2Fposts%2F2020-11-03-JVM-day02%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录JVM的学习过程-垃圾回收 1.如何判断对象可以回收1.1 引用计数法 弊端：循环引用 1.2 可达性分析算法 Java虚拟机中的垃圾回收器采用 可达性分析 来探索所有存活的对象 扫描堆中的对象，看是否能够沿着GC Root对象 为起点的引用链找到该对象，找不到则表示可以回收 哪些对象可以作为GC Root? Java堆分析器 : MAT(Eclipse Memory Analyzer) 是一个快速且功能丰富的Java堆分析器，可帮助您查找内存泄漏并减少内存消耗。使用Memory Analyzer分析具有数亿个对象的高效堆转储，快速计算对象的保留大小，查看谁阻止垃圾收集器收集对象，运行报告以自动提取泄漏嫌疑者。 下载地址：https://www.eclipse.org/mat/downloads.php 功能： 找出内存泄漏的原因 找出重复引用的类和jar 分析集合的使用 分析类加载器 演示如下： 12345678910List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();list1.add(&quot;a&quot;);list1.add(&quot;b&quot;);System.out.println(1);System.in.read();list1 = null;System.out.println(2);System.in.read();System.out.println(&quot;end...&quot;); 运行以上代码，使用 jps 指令找到当前的进程ID 123451513613604 Jps1577215948 Launcher3612 TestDemo01 出现 1 时，使用如下的jmap指令 1jmap -dump:format=b,live,file=1.bin 3612 简单解释下format（转储文件的格式）的参数： b: 二进制文件 live: 只抓取存活的类型，live前会进行一次垃圾回收FullGC file: 存储文件路径 出现 2 时，使用如下的jmap指令 1jmap -dump:format=b,live,file=2.bin 3612 这样可以看到在当前目录下有两个文件，1.bin和2.bin 在MAT工具中分别打开这两个bin文件，如下图： 打开GC Roots 如下： 1.3 四种引用 + 终结器引用 强引用： 只有所有GC Roots对象都不通过 强引用 引用该对象，该对象才能被垃圾回收 软引用（SoftReference） (1)仅有 软引用 引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象 (2)可以配合引用队列来释放软引用自身 软引用的案例： 1234567891011121314151617181920212223242526272829303132//打印参数： -Xmx20m -XX:+PrintGCDetails -verbose:gcpublic class TestDemo02 &#123; private static final int _4MB = 4 * 1024 * 1024; public static void main(String[] args) throws IOException &#123; //强引用 /*List&lt;byte[]&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; list1.add(new byte[_4MB]); &#125; System.in.read();*/ //软引用 soft(); &#125; private static void soft()&#123; // list --&gt; SoftReference --&gt; byte[] List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; SoftReference&lt;byte[]&gt; reference = new SoftReference&lt;&gt;(new byte[_4MB]); System.out.println(reference.get()); list.add(reference); System.out.println(list.size()); &#125; System.out.println(&quot;循环结束：&quot; + list.size()); for (SoftReference&lt;byte[]&gt; ref : list)&#123; System.out.println(ref.get()); &#125; &#125;&#125; 打印结果如下： 12345678910111213141516171819202122232425262728293031[B@7ba4f24f1[B@3b9a45b32[B@7699a5893[GC (Allocation Failure) [PSYoungGen: 2913K-&gt;504K(6144K)] 15201K-&gt;13317K(19968K), 0.0237151 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] [Full GC (Ergonomics) [PSYoungGen: 504K-&gt;0K(6144K)] [ParOldGen: 12813K-&gt;13268K(13824K)] 13317K-&gt;13268K(19968K), [Metaspace: 3272K-&gt;3272K(1056768K)], 0.0235688 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] [B@58372a004[Full GC (Ergonomics) [PSYoungGen: 4208K-&gt;4096K(6144K)] [ParOldGen: 13268K-&gt;13117K(13824K)] 17477K-&gt;17213K(19968K), [Metaspace: 3274K-&gt;3274K(1056768K)], 0.0060131 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) [PSYoungGen: 4096K-&gt;0K(6144K)] [ParOldGen: 13117K-&gt;811K(7680K)] 17213K-&gt;811K(13824K), [Metaspace: 3274K-&gt;3274K(1056768K)], 0.0081056 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [B@4dd8dc35循环结束：5nullnullnullnull[B@4dd8dc3Heap PSYoungGen total 6144K, used 4377K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 77% used [0x00000000ff980000,0x00000000ffdc6400,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 7680K, used 811K [0x00000000fec00000, 0x00000000ff380000, 0x00000000ff980000) object space 7680K, 10% used [0x00000000fec00000,0x00000000feccac50,0x00000000ff380000) Metaspace used 3280K, capacity 4500K, committed 4864K, reserved 1056768K class space used 355K, capacity 388K, committed 512K, reserved 1048576KProcess finished with exit code 0 加入引用队列ReferenceQueue：移除无用的软引用对象 以上的代码修改如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestDemo02 &#123; //打印参数： -Xmx20m -XX:+PrintGCDetails -verbose:gc private static final int _4MB = 4 * 1024 * 1024; public static void main(String[] args) throws IOException &#123; //强引用 /*List&lt;byte[]&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; list1.add(new byte[_4MB]); &#125; System.in.read();*/ //软引用 soft(); &#125; private static void soft()&#123; // list --&gt; SoftReference --&gt; byte[] List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); //引用队列 ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; //关联引用队列: 当软引用所关联的byte[]被回收时，软引用自己会加入到queue中去 SoftReference&lt;byte[]&gt; reference = new SoftReference&lt;&gt;(new byte[_4MB],queue); System.out.println(reference.get()); list.add(reference); System.out.println(list.size()); &#125; //从引用队列中获取无用的软引用对象 并移除 Reference&lt;? extends byte[]&gt; poll = queue.poll(); while (poll != null)&#123; list.remove(poll); poll = queue.poll(); &#125; System.out.println(&quot;===================================&quot;); for (SoftReference&lt;byte[]&gt; ref : list)&#123; System.out.println(ref.get()); &#125; &#125;&#125; 打印结果： 123456789101112131415161718192021222324252627[B@7ba4f24f1[B@3b9a45b32[B@7699a5893[GC (Allocation Failure) [PSYoungGen: 2913K-&gt;504K(6144K)] 15201K-&gt;13329K(19968K), 0.0018256 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 504K-&gt;0K(6144K)] [ParOldGen: 12825K-&gt;13268K(13824K)] 13329K-&gt;13268K(19968K), [Metaspace: 3274K-&gt;3274K(1056768K)], 0.0057513 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] [B@58372a004[Full GC (Ergonomics) [PSYoungGen: 4208K-&gt;4096K(6144K)] [ParOldGen: 13268K-&gt;13117K(13824K)] 17477K-&gt;17213K(19968K), [Metaspace: 3274K-&gt;3274K(1056768K)], 0.0078122 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) [PSYoungGen: 4096K-&gt;0K(6144K)] [ParOldGen: 13117K-&gt;811K(7680K)] 17213K-&gt;811K(13824K), [Metaspace: 3274K-&gt;3274K(1056768K)], 0.0058282 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [B@4dd8dc35===================================[B@4dd8dc3Heap PSYoungGen total 6144K, used 4377K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 77% used [0x00000000ff980000,0x00000000ffdc6400,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 7680K, used 811K [0x00000000fec00000, 0x00000000ff380000, 0x00000000ff980000) object space 7680K, 10% used [0x00000000fec00000,0x00000000feccad40,0x00000000ff380000) Metaspace used 3281K, capacity 4500K, committed 4864K, reserved 1056768K class space used 355K, capacity 388K, committed 512K, reserved 1048576KProcess finished with exit code 0 弱引用（WeakReference） (1)仅有 弱引用 引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 (2)可以配合引用队列来释放弱引用自身 弱引用案例： 123456789101112131415161718//打印参数： -Xmx20m -XX:+PrintGCDetails -verbose:gcpublic class TestDemo03 &#123; private static final int _4MB = 4 * 1024 * 1024; public static void main(String[] args) throws IOException &#123; // list --&gt; WeakReference --&gt; byte[] List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; WeakReference&lt;byte[]&gt; reference = new WeakReference&lt;&gt;(new byte[_4MB]); list.add(reference); for (WeakReference&lt;byte[]&gt; w : list)&#123; System.out.println(w.get()+&quot; &quot;); &#125; System.out.println(); &#125; System.out.println(&quot;循环结束：&quot;+list.size()); &#125;&#125; 打印结果如下： 1234567891011121314151617181920212223242526272829303132[B@7ba4f24f [B@7ba4f24f [B@3b9a45b3 [B@7ba4f24f [B@3b9a45b3 [B@7699a589 [GC (Allocation Failure) [PSYoungGen: 2913K-&gt;488K(6144K)] 15201K-&gt;13301K(19968K), 0.0018384 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 488K-&gt;0K(6144K)] [ParOldGen: 12813K-&gt;980K(11776K)] 13301K-&gt;980K(17920K), [Metaspace: 3274K-&gt;3274K(1056768K)], 0.0049699 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] null null null [B@58372a00 null null null [B@58372a00 [B@4dd8dc3 循环结束：5Heap PSYoungGen total 6144K, used 4265K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffdaa5b8,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 11776K, used 5076K [0x00000000fec00000, 0x00000000ff780000, 0x00000000ff980000) object space 11776K, 43% used [0x00000000fec00000,0x00000000ff0f53b0,0x00000000ff780000) Metaspace used 3281K, capacity 4500K, committed 4864K, reserved 1056768K class space used 355K, capacity 388K, committed 512K, reserved 1048576K 虚引用（PhantomReference） 必须配合引用队列来使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队列，由ReferenceHandler线程调用虚引用相关方法释放直接内存 终结器引用（FinalReference） 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队列（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象 2.垃圾回收算法2.1 标记清除 定义： Mark Sweep 优点： 速度较快 缺点： 容易产生内存碎片 2.2 标记整理 定义： Mark Compact 优点： 没有内存碎片 缺点： 速度慢 2.3 复制 定义： Copy 优点： 没有内存碎片 缺点： 需要占用双倍的内存空间 3.分代垃圾回收 MinorGC：新生代垃圾回收，包括Eden和SurvivorFrom以及SurvivorTo MajorGC：老年代垃圾回收 FullGC：整个堆空间的垃圾回收，包括新生代和老年代 对象首先分配在Eden区域 新生代空间不足时，触发MinorGC，Eden和From存活的对象使用copy复制到To中，存活的对象年龄加1并且交换From和To MinorGC会引发stop the world，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit） 当老年代空间不足，会先尝试触发MinorGC，如果之后空间仍不足，那么触发FullGC，STW的时间更长 3.1 相关JVM参数 含义 参数 堆初始大小 -Xms 堆最大大小 -Xmx或者-XX:MaxHeapSize=size 新生代大小 -Xmn或者-XX:NewSize=size和-XX:MaxNewSize=size 幸存区Survivor比例(动态) -XX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy 幸存区Survivor比例 -XX:SurvivorRatio=ratio 晋升阈值 -XX:MaxTenuringThreshold=threshold 晋升详情 -XX:+PrintTenuringDistribution GC详情 -XX:+PrintGCDetails -verbose:gc FullGC前MinorGC -XX:+ScavengeBeforeFullGC 3.2 GC分析分析代码如下： 123456789101112//参数： -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gcpublic class TestDemo04 &#123; private static final int _512KB = 512 * 1024; private static final int _1MB = 1 * 1024 * 1024; private static final int _6MB = 6 * 1024 * 1024; private static final int _7MB = 7 * 1024 * 1024; private static final int _8MB = 8 * 1024 * 1024; public static void main(String[] args) &#123; &#125;&#125; 打印结果如下： 123456789Heap def new generation total 9216K, used 2982K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 36% used [0x00000000fec00000, 0x00000000feee9818, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000) Metaspace used 3273K, capacity 4496K, committed 4864K, reserved 1056768K class space used 354K, capacity 388K, committed 512K, reserved 1048576K 由以上的结果分析，并未发生GC 这里继续分析： 12345678910111213//参数： -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gcpublic class TestDemo04 &#123; private static final int _512KB = 512 * 1024; private static final int _1MB = 1 * 1024 * 1024; private static final int _6MB = 6 * 1024 * 1024; private static final int _7MB = 7 * 1024 * 1024; private static final int _8MB = 8 * 1024 * 1024; public static void main(String[] args) &#123; ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); list.add(new byte[_7MB]); &#125;&#125; 打印结果如下： 12345678910[GC (Allocation Failure) [DefNew: 2981K-&gt;980K(9216K), 0.0017746 secs] 2981K-&gt;980K(19456K), 0.0018187 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 8394K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 90% used [0x00000000fec00000, 0x00000000ff33d8c0, 0x00000000ff400000) from space 1024K, 95% used [0x00000000ff500000, 0x00000000ff5f5228, 0x00000000ff600000) to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000) Metaspace used 3274K, capacity 4496K, committed 4864K, reserved 1056768K class space used 354K, capacity 388K, committed 512K, reserved 1048576K 从结果第一行来看，JVM发生了一次MinorGC，跟第一次的结果有明显的变化。 依次放入不同大小的byte[]，逐步分析… 3.3 大对象直接晋升老年代12345678910111213//参数： -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gcpublic class TestDemo04 &#123; private static final int _512KB = 512 * 1024; private static final int _1MB = 1 * 1024 * 1024; private static final int _6MB = 6 * 1024 * 1024; private static final int _7MB = 7 * 1024 * 1024; private static final int _8MB = 8 * 1024 * 1024; public static void main(String[] args) &#123; ArrayList&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); list.add(new byte[_8MB]); &#125;&#125; 打印结果： 123456789Heap def new generation total 9216K, used 3145K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 38% used [0x00000000fec00000, 0x00000000fef127b8, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 8192K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 80% used [0x00000000ff600000, 0x00000000ffe00010, 0x00000000ffe00200, 0x0000000100000000) Metaspace used 3274K, capacity 4496K, committed 4864K, reserved 1056768K class space used 354K, capacity 388K, committed 512K, reserved 1048576K 4.垃圾回收器4.1 串行 单线程 堆内存较小，适合个人电脑 -XX:+UseSerialGC=Serial(新生代 复制算法) + SerialOld(老年代 标记整理算法) 4.2 吞吐量优先 多线程 堆内存较大，多核CPU 让单位时间内，STW的时间最短 0.2 0.2 = 0.4 垃圾回收时间占比最低，这样就称为吞吐量高 -XX:+UseParallelGC ~ -XX:+UseParallelOlgGC -XX:+UseAdaptiveSizePolicy (动态调整Eden和survivor的比例) -XX:GCTimeRatio=ratio -XX:MaxGCPauseMillis=ms -XX:ParallelGCThreads=n 4.3 响应时间优先 多线程 堆内存较大，多核CPU 尽可能让单次STW的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5 -XX:+UseConcMarkSweepGC(CMS concurrent 并发) ~ -XX:+UseParNewGC(新生代) ~ SerialOld -XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads(CPU核数的1/4) -XX:CMSInitiatingOccupancyFraction=percent(默认65%) -XX:+CMSScavengeBeforeRemark 4.4 G1定义：Garbage First 2004 论文发布 2009 JDK 6u14体验 2012 JDK 7u4官方支持 2017 JDK 9 默认 适用场景： 同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是200ms 超大堆内存，会将堆划分为多个大小相等的Region 整体上是 标记+整理 算法，两个区域之间是 复制 算法 相关JVM参数： -XX:+UseG1GC -XX:G1HeapRegionSize=size -XX:MaxGCPauseMillis=time 4.4.1 G1垃圾回收阶段 4.4.2 Young Collection会发生STW 4.4.3 Young Collection + CM 在Young GC时会进行GC Root 的初始标记 老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由下面的JVM参数决定 -XX:InitiatingHeapOccupancyPercent=percent(默认45%) 4.4.4 Mixed Collection 混合回收会对Eden,Survivor,Old进行全面垃圾回收 最终标记（Remark）会STW 拷贝存活（Evacuation）会STW -XX:MaxGCPauseMillis=ms 4.4.5 Full GC SerialGC (1)新生代内存不足发生的垃圾回收 - MinorGC (2)老年代内存不足发生的垃圾回收 - FullGC ParallelGC (1)新生代内存不足发生的垃圾回收 - MinorGC (2)老年代内存不足发生的垃圾回收 - FullGC CMS (1)新生代内存不足发生的垃圾回收 - MinorGC (2)老年代内存不足 G1 (1)新生代内存不足发生的垃圾回收 - MinorGC (2)老年代内存不足(根据阈值判断) 4.4.6 Young Collection 跨代引用新生代回收的跨代引用（老年代引用新生代）问题 卡表与Remembered Set 在引用变更时通过post-write barrier + dirty card queue concurrent refinement threads 更新 Remembered Set 4.4.7 Remarkpre-write barrier(写屏障) + satb_mark_queue 4.4.8 JDK 8u20 字符串去重优点：节省大量内存 缺点：略微多占用了CPU时间，新生代回收时间略微增加 -XX:+UseStringDeduplication 如下： String s1 = new String(&quot;hello&quot;);//char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;0&#39;&#125; String s2 = new String(&quot;hello&quot;);//char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;0&#39;&#125; 将所有新分配的字符串放入一个队列 当新生代回收时，G1并发检查是否有字符串重复 如果他们值一样，让他们引用同一个char[] 注意：与String.intern()不一样 (1)String.intern()关注的是字符串对象 (2)而字符串去重关注的是char[] (3)在JVM内部，使用了不同的字符串表 4.4.9 JDK 8u40 并发标记类卸载所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用 4.4.10 JDK 8u60 回收巨型对象 一个对象大于region的一半时，称之为巨型对象 G1不会对巨型对象进行拷贝 回收时被优先考虑 G1会跟踪老年代所有incoming引用，这样老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时被处理掉 4.4.11 JDK 9 并发标记起始时间的调整（动态调整阈值） 并发标记必须在堆空间占满前完成，否则退化为FullGC JDK9 之前需要使用 -XX:InitiatingHeapOccupancyPercent JDK9 可以动态调整 (1)-XX:InitiatingHeapOccupancyPercent 用来设置初始值 (2)进行数据采样并动态调整 (3)总会添加一个安全的空档空间 4.4.12 JDK 9 更高效的回收 250+增强 180+bug修复 参考资料： JDK12 JDK15 5.垃圾回收调优 掌握GC相关的JVM参数参考Oracle官网介绍，会基本的空间调整 掌握相关工具 调优跟应用、环境有关，没有放之四海而皆准的法则 5.1 调优领域 内存 锁竞争 CPU占用 IO 5.2 确定目标【低延迟】还是【高吞吐量】，选择合适的回收器 CMS, G1, ZGC ParallelGC Zing 5.3 最快的GC 是不发生GC查看FullGC前后的内存占用，考虑下面几个问题： 数据是不是太多？ resultSet = statement.executeQuery(“select * from 大表 limit n”); 数据表示是否太臃肿？ (1)对象图 (2)对象大小 Object(16Byte) Integer(24Byte 包装类型) int(4Byte) 是否存在内存泄露？ (1)static Map map (2)软 (3)弱 (4)第三方缓存实现 5.4 新生代调优新生代特点 所有的new操作的内存分配非常廉价 TLAB thread-local allocation buffer 死亡对象的回收代价是零 大部分对象用过即销毁 MinorGC的时间远远低于FullGC 问题：越大越好吗？ -Xmn的官方解释：参考链接 Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, or g or G to indicate gigabytes. The young generation region of the heap is used for new objects. GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size. 新生代能容纳所有【并发量*（请求-响应）】的数据 幸存区大到能保留【当前活跃对象+需要晋升对象】 晋升阈值配置得当，让长时间存活对象尽快晋升 -XX:MaxTenuringThreshold=threshold -XX:+PrintTenuringDistribution 5.5 老年代调优以CMS为例： CMS的老年代内存越大越好 先尝试不做调优，如果没有FullGC则无需调优，否则先尝试调优新生代 观察发生FullGC时老年代内存占用，将老年代内存预设调大1/4~1/3 -XX:CMSInitiatingOccupancyFraction=percent Twitter工程师建议设置为0，表示老年代一旦有垃圾就回收，但是这种极端做法对CPU的要求特别高。 一般设置75%到80%之间。 5.6 案例 案例1：FullGC和MinorGC频繁 增大新生代的内存，gc频次相应降低 案例2：请求高峰期发生FullGC，单次暂停时间特别长（CMS） 案例3：老年代充裕情况下，发生FullGC（CMS jdk7） jdk7 堆中的永久代空间不足 导致FullGC]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-day01]]></title>
    <url>%2Fposts%2F2020-11-02-JVM-day01%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录JVM的学习过程-内存结构 内存结构1.程序计数器： 1.1 定义Program Counter Register 程序计数器（寄存器） 作用是记住下一条jvm指令的执行地址 特点: 1 线程私有 2 不会存在内存溢出 1.2 作用 2.虚拟机栈： 2.1 定义Java Virtual Machine Stacks (Java虚拟机栈) 每个线程运行时所需要的内存，称为虚拟机栈 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 问题思考： 垃圾回收是否涉及栈内存？ 不需要，每次方法调用产生栈帧内存，方法执行完成后，都会被弹出栈，被自动回收掉。 栈内存分配越大越好吗？ -Xss size: 默认1024KB。栈内存越大，线程数越少。 方法内的局部变量是否线程安全？ 3.1 如果方法内局部变量没有逃离方法的作用访问，它是线程安全的 3.2 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全 2.2 栈内存溢出 StackOverflowError 栈帧过多导致栈内存溢出 栈帧过大导致栈内存溢出 2.3 线程运行诊断 CPU占用过多 程序运行很长时间没有结果 定位： 用top定位哪个进程对CPU的占用过高 ps H -eo pid,tid,%cpu | grep 进程id (用ps命令进一步定位是哪个线程引起的CPU占用过高) jstack 进程id (可以根据线程id找到有问题的线程，10进制的进程id转成16进制，进一步定位到问题代码的源码行号) 3.本地方法栈 4.堆 4.1 定义Heap 堆 ： 通过new关键字，创建对象都会使用堆内存 特点： 线程共享，堆中对象都需要考虑线程安全的问题 有垃圾回收机制 4.2 堆内存溢出 OutofMemoryError123456789101112131415public static void main(String[] args) &#123; int i = 0; try &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); String a = &quot;hello&quot;; while (true)&#123; list.add(a); a = a + a; i++; &#125; &#125;catch (Throwable throwable)&#123; throwable.printStackTrace(); System.out.println(i); &#125;&#125; 运行结果： 1234567java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at pub.iyu.se.jvmday.day01.TestDemo01.main(TestDemo01.java:20)26 4.3 堆内存诊断 jps工具：查看当前系统中有哪些java进程 jmap工具：查看堆内存占用情况 jmap -heap 进程id jconsole工具：图形界面，多功能的监测工具，可以连续监测 jvisualvm工具：更强大的图形界面 1234567891011public static void main(String[] args) throws InterruptedException &#123; System.out.println(&quot;1...&quot;); Thread.sleep(30000); byte[] array = new byte[1024*1024*10]; System.out.println(&quot;2...&quot;); Thread.sleep(30000); array = null; System.gc(); System.out.println(&quot;3...&quot;); Thread.sleep(1000000L); &#125; 运行方法后，在控制台输入 1jps 显示如下结果： 12312140 Jps14380 Launcher7644 TestDemo02 之后当输出如下内容时： 11... 在控制台输入 1jmap -heap 7644 这时候可以看到显示的结果： 12345678910111213141516171819202122Heap Usage:PS Young GenerationEden Space: capacity = 67108864 (64.0MB) used = 6718152 (6.406929016113281MB) free = 60390712 (57.59307098388672MB) 10.010826587677002% usedFrom Space: capacity = 11010048 (10.5MB) used = 0 (0.0MB) free = 11010048 (10.5MB) 0.0% usedTo Space: capacity = 11010048 (10.5MB) used = 0 (0.0MB) free = 11010048 (10.5MB) 0.0% usedPS Old Generation capacity = 179306496 (171.0MB) used = 0 (0.0MB) free = 179306496 (171.0MB) 0.0% used 当输出如下内容时： 12... 在控制台输入 1jmap -heap 7644 这时候可以看到显示的结果： 12345678910111213141516171819202122Heap Usage:PS Young GenerationEden Space: capacity = 67108864 (64.0MB) used = 17203928 (16.406944274902344MB) free = 49904936 (47.593055725097656MB) 25.635850429534912% usedFrom Space: capacity = 11010048 (10.5MB) used = 0 (0.0MB) free = 11010048 (10.5MB) 0.0% usedTo Space: capacity = 11010048 (10.5MB) used = 0 (0.0MB) free = 11010048 (10.5MB) 0.0% usedPS Old Generation capacity = 179306496 (171.0MB) used = 0 (0.0MB) free = 179306496 (171.0MB) 0.0% used 当输出如下内容时： 13... 在控制台输入 1jmap -heap 7644 这时候可以看到显示的结果： 12345678910111213141516171819202122Heap Usage:PS Young GenerationEden Space: capacity = 67108864 (64.0MB) used = 1342200 (1.2800216674804688MB) free = 65766664 (62.71997833251953MB) 2.0000338554382324% usedFrom Space: capacity = 11010048 (10.5MB) used = 0 (0.0MB) free = 11010048 (10.5MB) 0.0% usedTo Space: capacity = 11010048 (10.5MB) used = 0 (0.0MB) free = 11010048 (10.5MB) 0.0% usedPS Old Generation capacity = 179306496 (171.0MB) used = 1345272 (1.2829513549804688MB) free = 177961224 (169.71704864501953MB) 0.7502639502809759% used 对照上面的代码，可以看到堆中内存的占用和回收情况。 重新运行代码，并在终端上输入 1jconsole 这时候，会打开jconsole的图形界面，观察一段时间，可以看到如下的结果： 问题：垃圾回收后，内存占用仍然很高 5.方法区 5.1 定义 参考资料：JVM规范-方法区定义 5.2 组成 5.3 方法区内存溢出代码如下： 123456789101112131415161718192021//继承ClassLoader 可以用来加载类的二进制字节码public class TestDemo03 extends ClassLoader&#123; public static void main(String[] args) &#123; int j = 0; try &#123; TestDemo03 testDemo03 = new TestDemo03(); for (int i = 0; i &lt; 10000; i++,j++) &#123; //ClassWriter 作用是生成类的二进制字节码 ClassWriter classWriter = new ClassWriter(0); // visit方法 （版本号，方法修饰符public，类名，包名，类的父类，实现的接口名称） classWriter.visit(Opcodes.V1_8,Opcodes.ACC_PUBLIC,&quot;Class&quot;+i,null,&quot;java/lang/Object&quot;,null); byte[] code = classWriter.toByteArray(); testDemo03.defineClass(&quot;Class&quot;+i,code,0,code.length); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; System.out.println(j); &#125; &#125;&#125; java8以前会导致永久代内存溢出 演示永久代内存溢出java.lang.OutofMemoryError: PermGen space 1-XX:MaxPermSize=10m java8以后会导致元空间内存溢出 由于java8后元空间在物理内存中，这里演示元空间内存溢出java.lang.OutofMemoryError: Metaspace 1-XX:MaxMetaspaceSize=10m 结果如下： 1234563331Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Compressed class space at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:756) at java.lang.ClassLoader.defineClass(ClassLoader.java:635) at pub.iyu.se.jvmday.day01.TestDemo03.main(TestDemo03.java:25) 实际场景动态产生class并加载的场景很多：spring，mybatis… cglib 5.4 运行时常量池 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等信息 运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 123456//二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）public class TestDemo04 &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello niko&quot;); &#125;&#125; 使用javap指令（javap能对给定的class文件提供的字节代码进行反编译） 1javap -v TestDemo04.class 输出结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Classfile /E:/TestJava/target/classes/pub/iyu/se/jvmday/day01/TestDemo04.class Last modified 2020-11-02; size 610 bytes MD5 checksum 98f958bafd4c5329e4a8734cac14cf8a Compiled from &quot;TestDemo04.java&quot;public class pub.iyu.se.jvmday.day01.TestDemo04 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #22.#23 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #24 // hello niko #4 = Methodref #25.#26 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #27 // pub/iyu/se/jvmday/day01/TestDemo04 #6 = Class #28 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lpub/iyu/se/jvmday/day01/TestDemo04; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 MethodParameters #19 = Utf8 SourceFile #20 = Utf8 TestDemo04.java #21 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #22 = Class #29 // java/lang/System #23 = NameAndType #30:#31 // out:Ljava/io/PrintStream; #24 = Utf8 hello niko #25 = Class #32 // java/io/PrintStream #26 = NameAndType #33:#34 // println:(Ljava/lang/String;)V #27 = Utf8 pub/iyu/se/jvmday/day01/TestDemo04 #28 = Utf8 java/lang/Object #29 = Utf8 java/lang/System #30 = Utf8 out #31 = Utf8 Ljava/io/PrintStream; #32 = Utf8 java/io/PrintStream #33 = Utf8 println #34 = Utf8 (Ljava/lang/String;)V&#123; public pub.iyu.se.jvmday.day01.TestDemo04(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 11: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lpub/iyu/se/jvmday/day01/TestDemo04; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String hello niko 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 13: 0 line 14: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; MethodParameters: Name Flags args&#125;SourceFile: &quot;TestDemo04.java&quot; 5.5 String Table思考如下代码的打印结果： 12345678910111213141516String s1 = &quot;a&quot;;String s2 = &quot;b&quot;;String s3 = &quot;a&quot; + &quot;b&quot;;String s4 = s1 + s2;String s5 = &quot;ab&quot;;String s6 = s4.intern();System.out.println(s3 == s4);System.out.println(s3 == s5);System.out.println(s3 == s6);String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;);String x1 = &quot;cd&quot;;x2.intern();System.out.println(x1 == x2); 运行结果如下： 1234falsetruetruefalse 1 String Table 特性 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是StringBuilder(1.8) 字符串常量拼接的原理是编译期优化 可以使用intern方法，主动将串池中还没有的字符串对象放入串池 java8将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回 java6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份放入串池，会把串池中的对象返回 2 String Table 位置 java6 String Table在永久代PermGen中 java8 String Table在堆Heap中 3 String Table 垃圾回收4 String Table 性能调优 调整 -XX:StringTableSize=桶个数 考虑将字符串对象是否入池（串池） 6.直接内存6.1 定义Direct Memory 属于操作系统内存 常见于NIO操作时，用于数据缓冲区 分配回收成本较高，但读写性能高 不受JVM内存回收管理 6.2 分配和回收原理 使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法 ByteBuffer的实现类内部，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-day00]]></title>
    <url>%2Fposts%2F2020-11-01-JVM-day00%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 记录JVM的学习过程-开始 什么是JVM？定义：JVM（Java Virtual Machine）即Java程序的运行环境（Java二进制字节码的运行环境） 优点： 一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态 比较 JVM/JRE/JDK 学习JVM有什么用？ 面试 理解底层的实现原理 中高级程序员的必备技能 常见的JVM 维基百科 Version information 学习路线 参考资料]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卸载Android微信的X5内核，如丝般顺滑]]></title>
    <url>%2Fposts%2F2019-11-15-cleanx5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;微信Android版本，每次点击链接，都要卡半天，难顶啊，怎么办呢？安排！ 微信用的是腾讯自研的X5内核，也被称为TBS的腾讯浏览服务。 腾讯说X5内核相比于系统自带的Webview： 打开网页的速度更快，更省流量而且更安全…….等等一系列的优点。 X5内核取代的就是这个安卓手机都自带的WebView组件。这个组件是基于谷歌的Chromium内核开发。 步骤只需要几个步骤，就可以用自带的Webview，抛弃腾讯的X5内核。 第一步，从微信里面进入TBS的调试模式随便打开个聊天窗口，输入以下代码： debugtbs.qq.com 文字发出去后，再点击打开，就会进入TBS调试界面 接下来先点击【内核未被禁用】，微信会自动重启一次。 重启后，显示【内核已被禁用】。 第二步，清除TBS内核点击【清除TBS内核】，页面就会提示X5内核删除成功！ 现在，就能使用系统自带的Android Webview组件来浏览网页了，而且打开网页的速度真不是X5能比的。 注意：重新使用TBS内核如果想要恢复自带的X5内核，只要回到TBS的调试界面，点击【安装线上内核】就行。 经过对比，微信打开网页慢的锅，X5内核是背定了。]]></content>
      <categories>
        <category>Wechat</category>
      </categories>
      <tags>
        <tag>Wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始-Redis入门]]></title>
    <url>%2Fposts%2F2019-10-01-Redis%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库。 1.Redis 简介Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库。 Redis 与 其他 key - value 缓存产品有以下三个特点： 1. Redis 支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 2. Redis 不仅仅支持简单的 key - value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。 3. Redis 支持数据的备份，即 master - slave 模式的数据备份。 2.Redis 优势 性能极高 – Redis 读的速度是 110000 次 /s, 写的速度是 81000 次 /s 。 丰富的数据类型 - Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子性 - Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。 其他特性 - Redis 还支持 publish/subscribe 通知，key 过期等特性。 3.Redis 数据类型Redis 支持 5 中数据类型：string（字符串），hash（哈希），list（列表），set（集合），zset（sorted set：有序集合）。 3.1 stringstring 是 redis 最基本的数据类型。一个 key 对应一个 value。 string 是二进制安全的。也就是说 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。 string 类型是 redis 最基本的数据类型，string 类型的值最大能存储 512 MB。 理解：string 就像是 java 中的 map 一样，一个 key 对应一个 value localhost:0&gt; set tfx helloredis2019 &quot;OK&quot; localhost:0&gt; get tfx &quot;helloredis2019&quot; 3.2 hashRedis hash 是一个键值对（key - value）集合。 Redis hash 是一个 string 类型的 key 和 value 的映射表，hash 特别适合用于存储对象。 理解：可以将 hash 看成一个 key - value 的集合。也可以将其想成一个 hash 对应着多个 string。 与 string 区别：string 是 一个 key - value 键值对，而 hash 是多个 key - value 键值对。 hash-key 可以看成是一个键值对集合的名字,在这里分别为其添加了 sub-key1 : value1、sub-key2 : value2、sub-key3 : value3 这三个键值对 localhost:0&gt;hset hash-key sub-key1 value1 &quot;1&quot; localhost:0&gt;hset hash-key sub-key2 value2 &quot;1&quot; localhost:0&gt;hset hash-key sub-key3 value3 &quot;1&quot; 获取 hash-key 这个 hash 里面的所有键值对 localhost:0&gt;hgetall hash-key 1) &quot;sub-key1&quot; 2) &quot;value1&quot; 3) &quot;sub-key2&quot; 4) &quot;value2&quot; 5) &quot;sub-key3&quot; 6) &quot;value3&quot; 删除 hash-key 这个 hash 里面的 sub-key2 键值对 localhost:0&gt;hdel hash-key sub-key2 &quot;1&quot; localhost:0&gt;hget hash-key sub-key2 null localhost:0&gt;hget hash-key sub-key1 &quot;value1&quot; localhost:0&gt;hgetall hash-key 1) &quot;sub-key1&quot; 2) &quot;value1&quot; 3) &quot;sub-key3&quot; 4) &quot;value3&quot; 3.3 listRedis 列表是简单的字符串列表，按照插入顺序排序，可以往列表的左边或者右边添加元素。 localhost:0&gt;rpush list-key value1 &quot;1&quot; localhost:0&gt;rpush list-key value2 &quot;2&quot; localhost:0&gt;rpush list-key value1 &quot;3&quot; localhost:0&gt;lrange list-key 0 -1 1) &quot;value1&quot; 2) &quot;value2&quot; 3) &quot;value1&quot; localhost:0&gt;lindex list-key 1 &quot;value2&quot; localhost:0&gt;lpop list-key &quot;value1&quot; localhost:0&gt;lrange list-key 0 -1 1) &quot;value2&quot; 2) &quot;value1&quot; list 是一个简单的字符串集合，和 Java 中的 list 相差不大，区别就是这里的 list 存放的是字符串。list 内的元素是可重复的。 3.4 setRedis 的 set 是字符串类型的无序集合。集合是通过哈希表实现的，因此添加、删除、查找的复杂度都是 O（1）。 localhost:0&gt;sadd key1 value1 &quot;1&quot; localhost:0&gt;sadd key1 value2 &quot;1&quot; localhost:0&gt;sadd key1 value3 &quot;1&quot; localhost:0&gt;sadd key1 value1 &quot;0&quot; localhost:0&gt;smembers key1 1) &quot;value2&quot; 2) &quot;value1&quot; 3) &quot;value3&quot; localhost:0&gt;sismember key1 value4 &quot;0&quot; localhost:0&gt;sismember key1 value1 &quot;1&quot; localhost:0&gt;srem key1 value2 &quot;1&quot; localhost:0&gt;srem key1 value2 &quot;0&quot; localhost:0&gt;smembers key1 1) &quot;value1&quot; 2) &quot;value3&quot; redis 的 set 与 java 中的 set 还是有点区别的。redis 的 set 是一个 key 对应着 多个字符串类型的 value，也是一个字符串类型的集合，但是和 redis 的 list 不同的是 set 中的字符串集合元素不能重复，但是 list 可以。 3.5 zsetredis zset 和 set 一样都是 字符串类型元素的集合，并且集合内的元素不能重复。 不同的是 zset 每个元素都会关联一个 double 类型的分数。redis 通过分数来为集合中的成员进行从小到大的排序。 zset 的元素是唯一的，但是分数（score）却可以重复。 localhost:0&gt;zadd zset-key 700 member1 &quot;1&quot; localhost:0&gt;zadd zset-key 800 member2 &quot;1&quot; localhost:0&gt;zadd zset-key 600 member2 &quot;0&quot; localhost:0&gt;zrange zset-key 0 -1 withscores 1) &quot;member2&quot; 2) &quot;600&quot; 3) &quot;member1&quot; 4) &quot;700&quot; localhost:0&gt;zrangebyscore zset-key 0 650 withscores 1) &quot;member2&quot; 2) &quot;600&quot; localhost:0&gt;zrem zset-key member1 &quot;1&quot; localhost:0&gt;zrem zset-key member1 &quot;0&quot; localhost:0&gt;zrange zset-key 0 -1 withscores 1) &quot;member2&quot; 2) &quot;600&quot; zset 是按照 分输的大小来排序的。 3.6 总结 类型简介 特性场景 string（字符串） 二进制安全可以包含任何数据，比如 jpg 图片或者序列化的对象，一个键最大能存储 521M Hash（哈希） 键值对集合，即编程语言中的 Map 类型适合存储对象，并且可以像数据库中 update 一样只修改某一项属性值存储、读取、修改用户属性 List（列表） 双向链表增删快，提供了操作某一段元素的 API 1、最新消息排行等功能（朋友圈的时间线）2、消息队列 Set（集合） 哈希表实现，元素不能重复添加删除查找的复杂度都是 O(1);为集合提供了求交集、并集、差集等操作共同好友；利用唯一性，统计访问网站的所有独立 ip；好友推荐时，根据 tag 求交集，大于某个阈值就可以推荐 Zset（有序集合） 将 Set 中的元素增加一个权重参数 score，元素按 score 有序排列数据插入集合时，已经进行天然排序排行榜；带权重的消息队列 4 发布订阅一般不用 Redis 做消息发布订阅。 Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat: localhost:0&gt;subscribe redisChat 切换到推送/订阅模式，关闭标签页来停止接收信息。 1) &quot;subscribe&quot; 2) &quot;redisChat&quot; 3) &quot;1&quot; 接下来先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。 localhost:0&gt;publish redisChat &quot;blog.iyu.pub&quot; &quot;1&quot; localhost:0&gt;publish redisChat &quot;hello redis&quot; &quot;1&quot; 在订阅者的客户端显示如下： localhost:0&gt;subscribe redisChat 切换到推送/订阅模式，关闭标签页来停止接收信息。 1) &quot;subscribe&quot; 2) &quot;redisChat&quot; 3) &quot;1&quot; 1) &quot;message&quot; 2) &quot;redisChat&quot; 3) &quot;blog.iyu.pub&quot; 1) &quot;message&quot; 2) &quot;redisChat&quot; 3) &quot;hello redis&quot; 5 事务redis 事务一次可以执行多条命令，服务器在执行命令期间，不会去执行其他客户端的命令请求。 事务中的多条命令被一次性发送给服务器，而不是一条一条地发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余命令依然被执行。也就是说 Redis 事务不保证原子性。 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中。 一个事务从开始到执行会经历以下三个阶段： 开始事务。 命令入队。 执行事务。 以下是一个事务的例子， 它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令： localhost:0&gt;multi &quot;OK&quot; localhost:0&gt;set redismulti test1 &quot;QUEUED&quot; localhost:0&gt;get redismulti &quot;QUEUED&quot; localhost:0&gt;sadd redistag value1 value2 value3 &quot;QUEUED&quot; localhost:0&gt;smembers redistag &quot;QUEUED&quot; localhost:0&gt;exec 1) &quot;OK&quot; 2) &quot;test1&quot; 3) &quot;3&quot; 4) 1) &quot;value2&quot; 2) &quot;value1&quot; 3) &quot;value3&quot; 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。 这是官网上的说明 From redis docs on transactions: It&#39;s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands. 例如： localhost:0&gt;multi &quot;OK&quot; localhost:0&gt;set a a &quot;QUEUED&quot; localhost:0&gt;set b b &quot;QUEUED&quot; localhost:0&gt;set c c &quot;QUEUED&quot; localhost:0&gt;exec 1) &quot;OK&quot; 2) &quot;OK&quot; 3) &quot;OK&quot; 如果在 set b b 处失败，set a 已成功不会回滚，set c 还会继续执行。 命令 描述 DISCARD 取消事务，放弃执行事务块内的所有命令 EXEC 执行所有事务块内的命令 MULTI 标记一个事务块的开始 UNWATCH 取消 WATCH 命令对所有 key 的监视 WATCH key [key …] 监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断 6 持久化Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 6.1 RDB 持久化将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量大，保存快照的时间会很长。 6.2 AOF 持久化将写命令添加到 AOF 文件（append only file）末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。 选项同步频率always每个写命令都同步eyerysec每秒同步一次no让操作系统来决定何时同步 always 选项会严重减低服务器的性能 everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器几乎没有任何影响。 no 选项并不能给服务器性能带来多大的提升，而且会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 7 复制通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。 一个从服务器只能有一个主服务器，并且不支持主主复制。 7.1 连接过程（1）主服务器创建快照文件，即 RDB 文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始像从服务器发送存储在缓冲区的写命令。 （2）从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。 （3）主服务器每执行一次写命令，就向从服务器发送相同的写命令。 7.2 主从链随着负载不断上升，主服务器无法很快的更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。 8 哨兵Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举处新的主服务器。 9 分片分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Redis 实例 R0, R1, R2, R3, 还有很多表示用户的键 user:1, user:2, … , 有不同的方式来选择一个指定的键存储在哪个实例中。 最简单的是范围分片，例如用户 id 从 0 ~ 1000 的存储到实例 R0 中，用户 id 从 1001 ~ 2000 的存储到实例 R1中，等等。但是这样需要维护一张映射范围表，维护操作代价高。 还有一种是哈希分片。使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道存储的实例。 根据执行分片的位置，可以分为三种分片方式： 客户端分片：客户端使用一致性哈希等算法决定应当分布到哪个节点。 代理分片：将客户端的请求发送到代理上，由代理转发到正确的节点上。 服务器分片：Redis Cluster。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Go从B站学起》第一讲:Go环境搭建]]></title>
    <url>%2Fposts%2F2019-05-01-go_learn%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;B站为了Go语言在中国的推广做出了不可磨灭的贡献。 &emsp;&emsp;但是，作为一名Go小白，怎样从零开始呢？ &emsp;&emsp;首先就是搭建Go语言环境。 &emsp;&emsp;Go官网：https://golang.google.cn &emsp;&emsp;这里教程以在Ubuntu上搭建Go环境为例： 下载Go压缩包&emsp;&emsp;点击https://golang.google.cn/dl/下载 go$VERSION.$OS-$ARCH.tar.gz &emsp;&emsp;当前最新版本为go1.12.4.linux-amd64 解压Go压缩包：tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz 配置环境变量：nano /etc/profile &emsp;&emsp;在/etc/profile的最后面加上 export PATH=$PATH:/usr/local/go/bin &emsp;&emsp;让配置文件生效： source /etc/profile 验证Go环境go version &emsp;&emsp;OK，安装完成。下一讲，你懂的，Hello World!!!(手动滑稽)]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>B站</tag>
        <tag>Bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM参数]]></title>
    <url>%2Fposts%2F2019-03-10-JVM-JVM%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JVM 参数使用手册 内存分配相关Xms 英文释义：Initial heap size(in bytes) 中文释义：堆区初始值 使用方法：-Xms2g 或 -XX:InitialHeapSize=2048m Xmx 英文释义：Maximum heap size(in bytes) 中文释义：堆区最大值 使用方法：-Xmx2g 或 -XX:MaxHeapSize=2048m Xmn 英文释义：Maximum new generation size(in bytes) 中文释义：新生代最大值 使用方法：-Xmn512m 或 -XX:MaxNewSize=512m PermSize、MetaspaceSize 英文释义：Initial size of permanent generation(in bytes) 中文释义：永久代（元空间）初始值 使用方法：-XX:PermSize=128m（1.7 之前版本）、-XX:MetaspaceSize=128m（1.7 之后版本） MaxPermSize、MetaspaceSize 英文释义：Maximum size of permanent generation(in bytes) 中文释义：永久代（元空间）最大值 使用方法：-XX:MaxPermSize=256m（1.7之前版本）、-XX：MaxMetaspaceSize=256m（1.7之后版本） Xss 英文释义：Thread Stack Size(in Kbytes) 中文释义：线程栈最大值 使用方法：-Xss256k 或 -XX:ThreadStackSize=256k GC 策略相关SurvivorRatio 英文释义：Rato of eden/survivor space size 中文释义：Eden 区和 Survivor 的比值 使用方法：-XX:SurvivorRatio=6 使用经验：默认值为 8，假如设为 6，则表示每个 Survivor 区跟 Eden 区的比值为1:6，每个 Survivor 区占新生代的八分之一 PretenureSizeThreshold 英文释义：Maximum size in bytes of objects allocated in DefNew generation;zero means no maximum 中文释义：可以在新生代直接分配的对象最大值，0表示没有最大值 使用方法：-XX:PretenureSizeThreshold=1000000 使用经验：设置该参数，可以使大于这个值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区发生大量的内存复制，该参数只对 Serial 和 ParNew 收集器有效，Parallel Scavenge并不认识该参数 MaxTenuringThreshold 英文释义：Maximum value fo tenuring threshold 中文释义：新生代最大年龄 使用方法：-XX:MaxTenuringThreshold=10 使用经验：每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代，最大支持15 ParallelGCThreads 英文释义：Number of parallel threads parallel gc will use 中文释义：并行执行gc的线程数 使用方法：-XX:ParallelGCThreads=16 UseSerialGC 英文释义：Use the Serial garbage collector 中文释义：新生代使用 Serial 垃圾收集器 使用方法：开启 -XX:+UseSerialGC、关闭 -XX:-UseSerialGC 使用经验：虚拟机在运行在 Client 模式下的默认值，老年代将会使用 SerialOld 垃圾收集器 UseParNewGC 英文释义：Use parallel threads in the new generation 中文释义：新生代使用 ParNew 垃圾收集器 使用方法：开启 -XX:+UseParNewGC、关闭 -XX:-UseParNewGC 使用经验：老年代将使用 Serial Old 收集器 CMSParallelRemarkEnabled 英文释义：Whether parallel remark enabled (only if ParNewGC) 中文释义：是否启用并行标记（仅限于ParNewGC） 使用方法：开启 -XX:+CMSParallelRemarkEnabled、关闭 -XX:-CMSParallelRemarkEnabled UseParallelGC 英文释义：Use the Parallel Scavenge garbage collector 中文释义：新生代使用 Parallel Scavenge 垃圾收集器 使用方法：开启 -XX:+UseParallelGC、关闭 -XX:-UseParallelGC 使用经验：Linux下1.6,1.7,1.8 默认开启（1.9 后默认启用 G1 收集器），老年代将会使用 Serial Old 垃圾收集器 UseAdaptiveSizePolicy 英文释义：Use adaptive generation sizing policies 中文释义：自适应调节策略，动态调整 Java 堆中各个区域的大小以及进入老年代的年龄 使用方法：开启 -XX:+UseAdaptiveSizePolicy、关闭 -XX:-UseAdaptiveSizePolicy MaxTimeRatio 英文释义： 中文释义：GC 时间占总时间的比率，默认值为 99，即允许 1% 的 GC 时间。仅在 Parallel Scavenge 收集器时生效。 使用方法：-XX:MaxTimeRatio=99 MaxGCPauseMillis 英文释义：Adaptive size policy maximum GC pause time goal in millisecond, or (G1 Only) the maximum GC time per MMU time slice 中文释义：自适应策略的最大GC暂停时间目标（以毫秒为单位），或（仅G1）每个MMU时间片的最大GC时间 使用方法：-XX:MaxGCPauseMillis=200 UseParallelOldGC 英文释义：Use the Parallel Old garbage collector 中文释义：老年代使用 Parallel Old 收集器 使用方法：开启 -XX:+UseParallelOldGC、关闭 -XX:-UseParallelOldGC 使用经验：新生代将使用 Parallel Scavenge 收集器 UseConcMarkSweepGC 英文释义：Use Concurrent Mark-Sweep GC in the old generation 中文释义：老年代使用 CMS 收集器 使用方法：开启 -XX:+UseConcMarkSweepGC、关闭 -XX:-UseConcMarkSweepGC 使用经验：年轻代将会使用 ParNew 收集器，如果出现&quot;Concurrent Mode Failure&quot;，会使用 Serial Old 收集器 CMSInitiatingOccupancyFraction 英文释义：Percentage CMS generation occupancy to start a CMS collection cycle. A negative value means that CMSTriggerRatio is used 中文释义：触发执行 CMS 回收的老年代内存空间占用的百分比，负值表示使用 CMSTriggerRatio 设置的值 使用方法：-XX:+CMSInitiatingOccupancyFraction=75 UseCMSInitiatingOccupancyOnly 英文释义：Only use occupancy as a criterion for staring a CMS collection 中文释义：只根据占用情况作为开始执行CMS收集的标准 使用方法：开启 -XX:+UseCMSInitiatingOccupancyOnly、关闭 -XX:-UseCMSInitiatingOccupancyOnly UseCMSCompactAtFullCollection 英文释义：Use Mark-Sweep-Compact algorithm at full collections 中文释义：设置 CMS 收集器在完成垃圾收集后是否要进行一次碎片整理 使用方法：开启 -XX:+UseCMSCompactAtFullCollection、关闭 -XX:-UseCMSCompactAtFullCollection CMSFullGCsBeforeCompaction 英文释义：Number of CMS full collection done before compaction if &gt; 0 中文释义：设置 CMS 收集器在进行若干次垃圾收集后再启动一次内存碎片整理。 使用方法：-XX:CMSFullGCsBeforeCompaction=1 CMSClassUnloadingEnabled 英文释义：Whether class unloading enabled when using CMS GC 中文释义：当使用CMS GC时是否启用类卸载功能 使用方法：开启 -XX:+CMSClassUnloadingEnabled、关闭 -XX:-CMSClassUnloadingEnabled UseG1GC 英文释义：Use the Garbage-First garbage collector 中文释义：使用G1垃圾收集器 使用方法：开启 -XX:+UseG1GC、关闭 -XX:-UseG1GC 使用经验：JDK 1.9 后默认选择的垃圾收集器 DisableExplicitGC 英文释义：Ignore calls to System.gc() 中文释义：禁用 System.gc() 触发FullGC 使用方法：开启 -XX:+DisableExplicitGC、关闭 -XX:-DisableExplicitGC 使用经验：不建议开启，如果开启了这个参数可能会导致对外内存无法及时回收造成对外内存溢出 GC日志相关Xloggc 英文释义：GC log file 中文释义：GC日志文件路径 使用方法：-Xloggc:/data/gclog/gc.log UseGCLogFileRotation 英文释义：Rotate gclog files(for long running applications). It requires -Xloggc: 中文释义：滚动GC日志文件，须配置Xloggc 使用方法：开启 -XX:+UseGCLogFileRotation、关闭 -XX:-UseGCLogFileRotation NumberOfGCLogFiles 英文释义：Number of gclog files in rotation(default:0,no rotation) 中文释义：滚动 GC日志文件数，默认0，不滚动 使用方法：-XX:NumberOfGCLogFiles=4 GCLogFileSize 英文释义：GC log file size,requires UseGCLogFileRotation. Set to 0 to only trigger rotation via jcmd 中文释义：GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发 使用方法：-XX:GCLogFileSize=100k PrintGCDetails 英文释义：Print more details at garbage collection 中文释义：GC时打印更多详细信息 使用方法：开启 -XX:+PrintGCDetails、关闭 -XX:-PrintGCDetails 使用经验：可以通过jinfo -flag [+|-]PrintGCDetails 或 jinfo -flag PrintGCDetails= 来动态开启或设置值 PrintGCDateStamps 英文释义：Print date stamps at garbage collection 中文释义：GC时打印时间戳信息 使用方法：开启 -XX:+PrintGCDateStamps、关闭 -XX:-PrintGCDateStamps 使用经验：可以通过jinfo -flag [+|-] PrintGCDateStamps 或 jinfo -flag PrintGCDateStamps=来动态开启或设置值 PrintTenuringDistribution 英文释义：Print tenuring age information 中文释义：打印存活实例年龄信息 使用方法：开启 -XX:+PrintTenuringDistribution、关闭 -XX:-PrintTenuringDistribution PrintGCApplicationStoppedTime 英文释义：Print the time of application has been stopped 中文释义：打印应用暂停时间 使用方法：开启 -XX:+PrintGCApplicationStoppedTime、关闭 -XX:-PrintGCApplicationStoppedTime PrintHeapAtGC 英文释义：Print heap layout before and after each GC 中文释义：GC前后打印堆区使用信息 使用方法：开启 -XX:+PrintHeapAtGC、关闭 -XX:-PrintHeapAtGC 异常相关HeapDumpOnOutOfMemoryError 英文释义：Dump heap to file when java.lang.OutOfMemoryError is thrown 中文释义：抛出内存溢出错误时导出堆信息到指定文件 使用方法：开启 -XX:+HeapDumpOnOutOfMemoryError、关闭 -XX:-HeapDumpOnOutOfMemoryError 使用经验：可以通过 jinfo -flag [+|-]HeapDumpOnOutOfMemoryError 或 jinfo -flag HeapDumpOnOutOfMemoryError= 来动态开启或设置值 HeapDumpPath 英文释义：When HeapDumpOnOutOfMemoryError is on, the path(filename or directory) of the dump file(defaults to java_pid.hprof in the working directory) 中文释义：当 HeapDumpOnOutOfMemoryError 开启的时候，dump 文件的保存路径，默认为工作目录下的 java_pid.hprof 文件 使用方法：-XX:HeapDumpPath=/data/dump/jvm.dump 其他server 英文释义：server mode 中文释义：服务端模式 使用方法：-server TieredCompilation 英文释义：Enable tiered compilation 中文释义：启用多层编译 使用方法：开启 -XX:+TieredCompilation、关闭 -XX:-TieredCompilation]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-锁优化策略]]></title>
    <url>%2Fposts%2F2019-03-09-JVM-%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 1 自旋锁背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。 原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。 优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效； 缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。 自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。 2 锁清除编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。 3 锁粗化若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。 4 轻量级锁本质：使用CAS取代互斥同步。 背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁。 轻量级锁与重量级锁的比较： 重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全； 而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。 实现原理： 对象头称为『Mark Word』，虚拟机为了节约对象的存储空间，对象处于不同的状态下，Mark Word中存储的信息也所有不同。 Mark Word中有个标志位用来表示当前对象所处的状态。 当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录； 若CAS操作成功，则轻量级锁的上锁过程成功； 若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。 前提：轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，不存在其他线程的竞争。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！ 5 偏向锁作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。 与轻量级锁的区别：轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。 与轻量级锁的相同点：它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。 原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。 优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。 偏向锁可以通过虚拟机的参数来控制它是否开启。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类加载]]></title>
    <url>%2Fposts%2F2019-03-08-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 1 类加载的时机1.1 类的生命周期 一个类从加载进内存到卸载出内存为止，一共经历7个阶段： 加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化——&gt;使用——&gt;卸载 其中，类加载包括5个阶段： 加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化 在类加载的过程中，以下3个过程称为连接： 验证——&gt;准备——&gt;解析 因此，JVM的类加载过程也可以概括为3个过程： 加载——&gt;连接——&gt;初始化 加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（注意是“开始”，而不是“进行”或“完成”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定。 C/C++在运行前需要完成预处理、编译、汇编、链接；而在Java中，类加载(加载、连接、初始化)是在程序运行期间完成的。 在程序运行期间进行类加载会稍微增加程序的开销，但随之会带来更大的好处——提高程序的灵活性。Java语言的灵活性体现在它可以在运行期间 动态扩展 ，所谓动态扩展就是在运行期间 动态加载 和 动态连接 。 1.2 类加载的时机1.2.1 类加载过程中每个步骤的顺序我们已经知道，类加载的过程包括：加载、连接、初始化，连接又分为：验证、准备、解析，所以说类加载一共分为5步：加载、验证、准备、解析、初始化。 其中加载、验证、准备、初始化的 开始 顺序是依次进行的，这些步骤开始之后的过程可能会有重叠。 而解析过程会发生在初始化过程中。 1.2.2 类加载过程中“初始化”开始的时机JVM规范中只定义了类加载过程中初始化过程开始的时机，加载、连接过程都应该在初始化之前开始(解析除外)，这些过程具体在何时开始，JVM规范并没有定义，不同的虚拟机可以根据具体的需求自定义。 初始化开始的时机： 在运行过程中遇到如下字节码指令时，如果类尚未初始化，那就要进行初始化：new、getstatic、putstatic、invokestatic。 这四个指令对应的Java代码场景是： 通过new创建对象； 读取、设置一个类的静态成员变量（不包括final修饰的静态变量）； 调用一个类的静态成员函数。 使用java.lang.reflect进行反射调用的时候，如果类没有初始化，那就需要初始化； 当初始化一个类的时候，若其父类尚未初始化，那就先要让其父类初始化，然后再初始化本类； 当虚拟机启动时，虚拟机会首先初始化带有main方法的类，即主类； Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但对于“初始化”阶段，有着严格的规定。有且仅有 5 种情况必须立即对类进行“初始化”： (1)在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。 (2)对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。 (3)初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。 (4)虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。 (5)当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。 这 5 种场景中的行为称为对一个类进行主动引用，除此之外，其它所有引用类的方式都不会触发初始化，称为被动引用。 1.2.3 主动引用 与 被动引用JVM规范中要求在程序运行过程中，“当且仅当”出现上述4个条件之一的情况才会初始化一个类。如果间接满足上述初始化条件是不会初始化类的。 其中，直接满足上述初始化条件的情况叫做 主动引用 ；间接满足上述初始化过程的情况叫做 被动引用 。 那么，只有当程序在运行过程中满足主动引用的时候才会初始化一个类，若满足被动引用就不会初始化一个类。 1.2.4 被动引用的场景示例Demo1 public class Fu&#123; public static String name = &quot;听风行&quot;; static&#123; System.out.println(&quot;父类被初始化！&quot;); &#125; &#125; public class Zi&#123; static&#123; System.out.println(&quot;子类被初始化！&quot;); &#125; &#125; public static void main(String[] args)&#123; System.out.println(Zi.name); &#125; &#125; 输出结果： 父类被初始化！ 听风行 原因分析： 本示例看似满足初始化时机的第一条：当要获取某一个类的静态成员变量的时候如果该类尚未初始化，则对该类进行初始化。 但由于这个静态成员变量属于Fu类，Zi类只是间接调用Fu类中的静态成员变量，因此Zi类调用name属性属于间接引用，而Fu类调用name属性属于直接引用，由于JVM只初始化直接引用的类，因此只有Fu类被初始化。 Demo2 public class A&#123; public static void main(String[] args)&#123; Fu[] arr = new Fu[10]; &#125; &#125; 输出结果： 并没有输出“父类被初始化！” 原因分析： 这个过程看似满足初始化时机的第一条：遇到new创建对象时若类没被初始化，则初始化该类。 但现在通过new要创建的是一个数组对象，而非Fu类对象，因此也属于间接引用，不会初始化Fu类。 Demo3 public class Fu&#123; public static final String name = &quot;听风行&quot;; static&#123; System.out.println(&quot;父类被初始化！&quot;); &#125; &#125; public class A&#123; public static void main(String[] args)&#123; System.out.println(Fu.name); &#125; &#125; &#125; 输出结果： 听风行 原因分析： 本示例看似满足类初始化时机的第一个条件：获取一个类静态成员变量的时候若类尚未初始化则初始化类。 但是，Fu类的静态成员变量被final修饰，它已经是一个常量。被final修饰的常量在Java代码编译的过程中就会被放入它被引用的class文件的常量池中（这里是A的常量池）。所以程序在运行期间如果需要调用这个常量，直接去当前类的常量池中取，而不需要初始化这个类。 Demo4 /** * 被动引用 Demo1: * 通过子类引用父类的静态字段，不会导致子类初始化。 */ class SuperClass &#123; static &#123; System.out.println(&quot;SuperClass init!&quot;); &#125; public static int value = 123; &#125; class SubClass extends SuperClass &#123; static &#123; System.out.println(&quot;SubClass init!&quot;); &#125; &#125; public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); // SuperClass init! &#125; &#125; 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。 Demo5 /** * 被动引用 Demo2: * 通过数组定义来引用类，不会触发此类的初始化。 */ public class NotInitialization &#123; public static void main(String[] args) &#123; SuperClass[] superClasses = new SuperClass[10]; &#125; &#125; 这段代码不会触发父类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。 Demo6 /** * 被动引用 Demo3: * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 */ class ConstClass &#123; static &#123; System.out.println(&quot;ConstClass init!&quot;); &#125; public static final String HELLO_BINGO = &quot;Hello Bingo&quot;; &#125; public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLO_BINGO); &#125; &#125; 编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。 1.2.5 接口的初始化(接口的加载过程)接口和类都需要初始化，接口和类的初始化过程基本一样，不同点在于：类初始化时，如果发现父类尚未被初始化，则先要初始化父类，然后再初始化自己；但接口初始化时，并不要求父接口已经全部初始化，只有程序在运行过程中用到当父接口中的东西时才初始化父接口。 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。 2 类加载的过程通过之前的介绍可知，类加载过程共有5个步骤，分别是：加载、验证、准备、解析、初始化。其中，验证、准备、解析称为连接。下面详细介绍这5个过程JVM所做的工作。 2.1 加载注意：“加载”是“类加载”过程的第一步，不能混淆这两个名词。 在加载过程中，JVM主要做3件事情： (1)通过一个类的全限定名来获取这个类的二进制字节流，即class文件： 在程序运行过程中，当要访问一个类时，若发现这个类尚未被加载，并满足类初始化时机的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程。 (2)将二进制字节流的存储结构转化为特定的数据结构，存储在方法区中；[将二进制字节流所代表的静态结构转化为方法区的运行时数据结构] (3)在内存中创建一个代表该类的java.lang.Class类型的对象，作为方法区这个类的各种数据的访问入口。 接下来程序在运行过程中所有对该类的访问都通过这个类对象，也就是这个Class类型的类对象是提供给外界访问该类的接口。 (1)获取二进制字节流 JVM规范对于加载过程给予了较大的宽松度。一般二进制字节流都从已经编译好的本地class文件中读取，此外还可以从以下地方读取： a.从压缩包zip中读取，如：Jar、War、Ear等。 b.从网络中获取，从网络中获取二进制字节流。如：Applet。 c.通过动态代理计数生成代理类的二进制字节流 d.从其它文件中动态生成，如：从JSP文件中生成Class类。 e.从数据库中读取，将二进制字节流存储至数据库中，然后在加载时从数据库中读取。有些中间件会这么做，用来实现代码在集群间分发。如：有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 (2)类 和 数组加载过程的区别？ 数组也有类型，称为“数组类型”。如： String[] str = new String[10]; 这个数组的数组类型是Ljava.lang.String，而String只是这个数组中元素的类型。 当程序在运行过程中遇到new关键字创建一个数组时，由JVM直接创建数组类，再由类加载器创建数组中的元素类。 而普通类的加载由类加载器完成。既可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器。 a.非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器控制字节流的获取方式（如重写一个类加载器的 loadClass() 方法） b.数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类。 (3)加载过程的注意点 a.JVM规范并未给出类在方法区中存放的数据结构 类完成加载后，二进制字节流就以特定的数据结构存储在方法区中，但存储的数据结构是由虚拟机自己定义的，JVM规范并没有指定。 b.JVM规范并没有指定Class对象存放的位置 在二进制字节流以特定格式存储在方法区后，JVM会创建一个java.lang.Class类型的对象，作为本类的外部接口。既然是对象就应该存放在堆内存中，不过JVM规范并没有给出限制，不同的虚拟机根据自己的需求存放这个对象。HotSpot将Class对象存放在方法区。 c.加载阶段和连接阶段是交叉的 通过之前的介绍可知，类加载过程中每个步骤的开始顺序都有严格限制，但每个步骤的结束顺序没有限制。也就是说，类加载过程中，必须按照如下顺序开始： 加载、连接、初始化，但结束顺序无所谓，因此由于每个步骤处理时间的长短不一就会导致有些步骤会出现交叉。 虚拟机规范未规定 Class 对象的存储位置，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中。 加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始实践仍然保持着固定的先后顺序。 2.2 验证验证阶段比较耗时，它非常重要但不一定必要，如果所运行的代码已经被反复使用和验证过，那么可以使用-Xverify:none参数关闭，以缩短类加载时间。 2.2.1 验证的目的验证是为了保证二进制字节流中的信息符合虚拟机规范，并没有安全问题。验证阶段确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 为什么需要验证？ 虽然Java语言是一门安全的语言，它能确保程序猿无法访问数组边界以外的内存、避免让一个对象转换成任意类型、避免跳转到不存在的代码行，如果出现这些情况，编译无法通过。也就是说，Java语言的安全性是通过编译器来保证的。 但是我们知道，编译器和虚拟机是两个独立的东西，虚拟机只认二进制字节流，它不会管所获得的二进制字节流是哪来的，当然，如果是编译器给它的，那么就相对安全，但如果是从其它途径获得的，那么无法确保该二进制字节流是安全的。通过上文可知，虚拟机规范中没有限制二进制字节流的来源，那么任意来源的二进制字节流虚拟机都能接受，为了防止字节流中有安全问题，因此需要验证！ 2.2.2 验证的过程（1）文件格式验证 这个阶段主要验证输入的二进制字节流是否符合class文件结构的规范。二进制字节流只有通过了本阶段的验证，才会被允许存入到方法区中。 本验证阶段是基于二进制字节流的，而后面的三个验证阶段都是在方法区中进行，并基于类特定的数据结构的。 通过上文可知，加载开始前，二进制字节流还没进方法区，而加载完成后，二进制字节流已经存入方法区。而在文件格式验证前，二进制字节流尚未进入方法区，文件格式验证通过之后才进入方法区。也就是说，加载开始后，立即启动了文件格式验证，本阶段验证通过后，二进制字节流被转换成特定数据结构存储至方法区中，继而开始下阶段的验证和创建Class对象等操作。这个过程印证了：加载和验证是交叉进行的。 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下： a.是否以魔数 0XCAFEBABE 开头 b.主次版本号是否在当前虚拟机处理范围内 c.常量池是否有不被支持的常量类型 d.指向常量的索引值是否指向了不存在的常量 e.CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据 f....... （2）元数据验证 本阶段对方法区中的字节码描述信息进行语义分析，确保其符合Java语法规范。 （3）字节码验证 本阶段是验证过程的最复杂的一个阶段。对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。 （4）符号引用验证，本阶段验证发生在解析阶段，确保解析能正常执行。 2.3 准备准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。 准备阶段完成两件事情： (1)为已经在方法区中的类中的静态成员变量分配内存 类的静态成员变量也存储在方法区中。 (2)为静态成员变量设置初始值 初始值为0、false、null等。 示例1： public static String name = “听风行”; 在准备阶段，JVM会在方法区中为name分配内存空间，并赋上初始值null。 给name赋上”柴毛毛”是在初始化阶段完成的。 示例2: public static final String name = “听风行”; 被final修饰的常量如果有初始值，那么在编译阶段就会将初始值存入constantValue属性中，在准备阶段就将constantValue的值赋给该字段。 2.4 解析解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。 2.5 初始化类初始化阶段是类加载过程的最后一步，是执行类构造器() 的过程。 () 方法由编译器自动产生，收集类中static{}代码块中的类变量赋值语句和类中静态成员变量的赋值语句。在准备阶段，类中静态成员变量已经完成了默认初始化，而在初始化阶段，clinit()方法对静态成员变量进行显示初始化。 () 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。 初始化过程的注意点： clinit()方法中静态成员变量的赋值顺序是根据Java代码中成员变量的出现的顺序决定的。 静态代码块能访问出现在静态代码块之前的静态成员变量，无法访问出现在静态代码块之后的成员变量。 静态代码块能给出现在静态代码块之后的静态成员变量赋值。 构造函数init()需要显示调用父类构造函数，而类的构造函数clinit()不需要调用父类的类构造函数，因为虚拟机会确保子类的clinit()方法执行前已经执行了父类的clinit()方法。 如果一个类/接口中没有静态代码块，也没有静态成员变量的赋值操作，那么编译器就不会生成clinit()方法。 接口也需要通过clinit()方法为接口中定义的静态成员变量显示初始化。 接口中不能使用静态代码块。 接口在执行clinit()方法前，虚拟机不会确保其父接口的clinit()方法被执行，只有当父接口中的静态成员变量被使用到时才会执行父接口的clinit()方法。 虚拟机会给clinit()方法加锁，因此当多条线程同时执行某一个类的clinit()方法时，只有一个方法会被执行，其它的方法都被阻塞。并且，只要有一个clinit()方法执行完，其它的clinit()方法就不会再被执行。因此，在同一个类加载器下，同一个类只会被初始化一次。 静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示： public class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.out.println(i); // 这句编译器会提示“非法向前引用” } static int i = 1; } () 方法不需要显式调用父类构造器，虚拟机会保证在子类的 () 方法执行之前，父类的 () 方法已经执行完毕。 由于父类的 () 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示： static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125; &#125; static class Sub extends Parent &#123; public static int B = A; &#125; public static void main(String[] args) &#123; System.out.println(Sub.B); // 输出 2 &#125; () 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 () 方法。 接口中不能使用静态代码块，但接口也需要通过 () 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 () 方法不需要先执行父类的 () 方法，只有当父接口中定义的变量使用时，父接口才会初始化。 虚拟机会保证一个类的 () 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 () 方法。 3 类加载器3.1 类与类加载器类加载器的作用：将class文件加载进JVM的方法区，并在方法区中创建一个java.lang.Class对象作为外界访问这个类的接口。 类与类加载器的关系：比较两个类是否相等，只有当这两个类由同一个加载器加载才有意义；否则，即使同一个class文件被不同的类加载器加载，那这两个类必定不同，即通过类的Class对象的equals执行的结果必为false。 任意一个类，都由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。 因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。 这里的“相等”，包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。 3.2 类加载器种类JVM提供如下三种类加载器： （1）启动类加载器（Bootstrap ClassLoader）: 负责加载Java_Home\lib中的class文件。 负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 （2）扩展类加载器（Extension ClassLoader）: 负责加载Java_Home\lib\ext目录下的class文件。 负责加载 &lt;JAVA_HOME&gt;\lib\ext 目录中的所有类库，开发者可以直接使用扩展类加载器。 （3）应用程序类加载器（Application ClassLoader）: 负责加载用户classpath下的class文件。 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 当然，如果有必要，还可以加入自己定义的类加载器。 3.3 双亲委派模型3.3.1 双亲委派模型的定义双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码） 3.3.2 工作过程如果一个类加载器收到了加载类的请求，它首先将请求交由父类加载器加载；若父类加载器加载失败，当前类加载器才会自己加载类。 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。 在 java.lang.ClassLoader 中的 loadClass() 方法中实现该过程。 3.3.3 作用像java.lang.Object这些存放在rt.jar中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的Object类都是同一个。 相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。 3.3.4 原理双亲委派模型的代码在java.lang.ClassLoader类中的loadClass函数中实现，其逻辑如下： 首先检查类是否被加载； 若未加载，则调用父类加载器的loadClass方法； 若该方法抛出ClassNotFoundException异常，则表示父类加载器无法加载，则当前类加载器调用findClass加载类； 若父类加载器可以加载，则直接返回Class对象；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类文件结构]]></title>
    <url>%2Fposts%2F2019-03-07-JVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 1 JVM的“无关性”Java具有平台无关性，也就是任何操作系统都能运行Java代码。之所以能实现这一点，是因为Java运行在虚拟机之上，不同的操作系统都拥有各自的Java虚拟机，因此Java能实现“一次编写，处处运行”。 而JVM不仅具有平台无关性，还具有语言无关性。 平台无关性是指不同操作系统都有各自的JVM，而语言无关性是指Java虚拟机能运行除Java以外的代码！ (1)平台无关性：任何操作系统都能运行 Java 代码 (2)语言无关性： JVM 能运行除 Java 以外的其他代码 这听起来非常惊人，但JVM对能运行的语言是有严格要求的。首先来了解下Java代码的运行过程。 Java源代码首先需要使用Javac编译器编译成.class文件，然后启动JVM执行.class文件，从而程序开始运行。 也就是JVM只认识.class文件，它并不管何种语言生成了.class文件，只要.class文件符合JVM的规范就能运行。 因此目前已经有Scala、JRuby、Jython等语言能够在JVM上运行。它们有各自的语法规则，不过它们的编译器都能将各自的源码编译成符合JVM规范的class文件，从而能够借助JVM运行它们。 Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的， 因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。 因此，有一些 Java 语言本身无法有效支持的语言特性，不代表字节码本身无法有效支持。 2 Class文件结构class文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全是连续的0/1。class文件中的所有内容被分为两种类型：无符号数 和 表。 (1)无符号数：它表示Class文件中的值，这些值没有任何类型，但有不同的长度。根据这些值长度的不同分为：u1、u2、u4、u8，分别代表1字节的无符号数、2字节的无符号数、4字节的无符号数、8字节的无符号数。 (2)表：由多个无符号数或者其他表作为数据项构成的符合数据类型。class文件中所有数据（即无符号数）要么单独存在，要么由多个无符号数组成二维表。即class文件中的数据要么是单个值，要么是二维表。 2.1 class文件的组织结构魔数 本文件的版本信息 常量池 访问标志 类索引、父类索引、接口索引集合 字段表集合 方法表集合 属性表集合 2.1.1 Class文件的构成1：魔数class文件的头4个字节称为魔数，用来表示这个class文件的类型。 魔数的作用就相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在class文件中标示文件类型比较合适。 class文件的魔数是用16进制表示的“CAFEBABE”，非常具有浪漫主义色彩！ 2.1.2 Class文件的构成2：版本信息紧接着魔数的4个字节是版本号。5-6 字节表示次版本号，7-8 字节表示主版本号，它表示当前class文件中使用的是哪个版本的JDK。 在高版本的JVM上能够运行低版本的class文件，但在低版本的JVM上无法运行高版本的class文件，即使该class文件中没有用到任何高版本JDK的特性也无法运行，虚拟机也必需拒绝执行超过其版本号的 Class 文件。 2.1.3 Class文件的构成3：常量池2.1.3.1 常量池的定义紧接着版本号之后的就是常量池。常量池中存放两种类型的常量： （1）字面值常量 字面值常量即我们在程序中定义的字符串、被final修饰的值。 （2）符号引用 符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符 2.1.3.2 常量池的特点（1）常量池长度不固定 常量池的大小是不固定的，因此常量池开头放置一个u2类型的无符号数，用来存储当前常量池的容量。JVM根据这个值就知道常量池的头尾来。 注： 这个值是从1开始的，若为5表示池中有4个常量。 （2）常量池中的常量由表来表示 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。 常量池开头有个常量池容量计数器，接下来就全是一个个常量了，只不过常量都是由一张张二维表构成，除了记录常量的值以外，还记录当前常量的相关信息。 常量池是class文件的资源仓库 常量池是与本class中其它部分关联最多的部分 常量池是class文件中空间占用最大的部分之一 2.1.3.3 常量池中常量的类型刚才介绍了，常量池中的常量大体上分为：字面值常量 和 符号引用。在此基础上，根据常量的数据类型不同，又可以被细分为14种常量类型。这14种常量类型都有各自的二维表示结构。每种常量类型的头1个字节都是tag，用于表示当前常量属于14种类型中的哪一个。 类型 tag 描述 CONSTANT_utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整型字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info 5 长整型字面量 CONSTANT_Double_info 6 双精度浮点型字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型字面量 CONSTANT_Fieldref_info 9 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的符号引用 CONSTANT_MethodHandle_info 15 表示方法句柄 CONSTANT_MethodType_info 16 标识方法类型 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 以CONSTANT_Class_info常量（此类型的常量代表一个类或者接口的符号引用）为例，它的二维表示结构如下： 类型 名称 数量 u1 tag 1 u2 name_index 1 tag是标志位，用于区分常量类型，表示当前常量的类型(当前常量为CONSTANT_Class_info，因此tag的值应为7，表示一个类或接口的全限定名)； name_index 是一个索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表这个类（或接口）的全限定名，这里 name_index 值若为 0x0002，也即是指向了常量池中的第二项常量。表示这个类或接口全限定名的位置。它的值表示指向常量池的第几个常量。它会指向一个CONSTANT_Utf8_info类型的常量，CONSTANT_Utf8_info的二维表结构如下： 类型 名称 数量 u1 tag 1 u2 length 1 u1 bytes length CONSTANT_Utf8_info表示字符串常量； tag表示当前常量的类型，这里应该是1；length表示这个字符串的长度；bytes为这个字符串的内容（采用缩略的UTF8编码） 问：为什么Java中定义的类、变量名字必须小于64K？ 类、接口、变量等名字都属于符号引用，它们都存储在常量池中。而不管哪种符号引用，它们的名字都由CONSTANT_Utf8_info类型的常量表示，这种类型的常量使用u2存储字符串的长度。由于2字节最多能表示65535个数，因此这些名字的最大长度最多只能是64K。 问：什么是UTF-8编码？什么是缩略UTF-8编码？ 前者每个字符使用3个字节表示，而后者把128个ASKII码用1字节表示，某些字符用2字节表示，某些字符用3字节表示。 2.1.4 Class文件的构成4：访问标志在常量池之后是2字节的访问标志。访问标志是用来表示这个class文件是类还是接口、是否被public修饰、是否被abstract修饰、是否被final修饰等。 由于这些标志都由是/否表示，因此可以用0/1表示。 访问标志为2字节，可以表示16位标志，但JVM目前只定义了8种，未定义的直接写0. 2.1.5 Class文件的构成5：类索引、父类索引、接口索引集合类索引、父类索引、接口索引集合是用来表示当前class文件所表示类的名字、父类名字、接口们的名字。 它们按照顺序依次排列，类索引和父类索引各自使用一个u2类型的无符号常量，这个常量指向CONSTANT_Class_info类型的常量，该常量的bytes字段记录了本类、父类的全限定名。 由于一个类的接口可能有好多个，因此需要用一个集合来表示接口索引，它在类索引和父类索引之后。这个集合头两个字节表示接口索引集合的长度，接下来就是接口的名字索引。 类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。 由于 Java 不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为 u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。 类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。 2.1.6 Class文件的构成6：字段表的集合2.1.6.1 什么是字段表集合？字段表集合用于存储本类所涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量。 每一个字段表只表示一个成员变量，本类中所有的成员变量构成了字段表集合。 2.1.6.2 字段表结构的定义 类型 名称 数量 说明 u2 access_flags 1 字段的访问标志，与类稍有不同 u2 name_index 1 字段名字的索引 u2 descriptor_index 1 描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。 u2 attributes_count 1 属性表集合的长度 u2 attributes attributes_count 属性表集合，用于存放属性的额外信息，如属性的值。 access_flags：字段的访问标志。在Java中，每个成员变量都有一系列的修饰符，和上述class文件的访问标志的作用一样，只不过成员变量的访问标志与类的访问标志稍有区别。 name_index：本字段名字的索引。指向一个CONSTANT_Class_info类型的常量，这里面存储了本字段的名字等信息。 descriptor_index：描述符。用于描述本字段在Java中的数据类型等信息（下面详细介绍）。 attributes_count：属性表集合的长度。 attributes：属性表集合。到descriptor_index为止是字段表的固定信息，光有上述信息可能无法完整地描述一个字段，因此用属性表集合来存放额外的信息，比如一个字段的值（下面会详细介绍）。 2.1.6.3 什么是描述符？成员变量（包括静态成员变量和实例变量）和 方法都有各自的描述符。 对于字段而言，描述符用于描述字段的数据类型； 对于方法而言，描述符用于描述字段的数据类型、参数列表、返回值。 在描述符中，基本数据类型用大写字母表示，对象类型用“L对象类型的全限定名”表示，数组用“[数组类型的全限定名”表示。 描述方法时，将参数根据上述规则放在()中，()右侧按照上述方法放置返回值。而且，参数之间无需任何符号。 2.1.6.4 字段表集合的注意点字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 一个class文件的字段表集合中不能出现从父类/接口继承而来的字段； 一个class文件的字段表集合中可能会出现程序没有定义的字段 如编译器会自动地在内部类的class文件的字段表集合中添加外部类对象的成员变量，供内部类访问外部类。 Java中只要两个字段名字相同就无法通过编译。但在JVM规范中，允许两个字段的名字相同但描述符不同的情况，并且认为它们是两个不同的字段。 2.1.7 Class文件的构成7：方法表的集合在class文件中，所有的方法以二维表的形式存储，每张表来表示一个函数，一个类中的所有方法构成方法表的集合。 方法表的结构和字段表的结构一致，只不过访问标志和属性表集合的可选项有所不同。 volatile 关键字 和 transient 关键字不能修饰方法，所以方法表的访问标志中没有 ACC_VOLATILE 和 ACC_TRANSIENT 标志。 方法表的属性表集合中有一张Code属性表，用于存储当前方法经编译器编译过后的字节码指令。 方法表集合的注意点 如果本class没有重写父类的方法，那么本class文件的方法表集合中是不会出现父类/父接口的方法表； 本class的方法表集合可能出现程序猿没有定义的方法 编译器在编译时会在class文件的方法表集合中加入类构造器和实例构造器。 重载一个方法需要有相同的简单名称和不同的特征签名。JVM的特征签名和Java的特征签名有所不同： Java特征签名：方法参数在常量池中的字段符号引用的集合 JVM特征签名：方法参数＋返回值 2.1.8 Class文件的构成8：属性表的集合每个属性对应一张属性表，属性表的结构如下： 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u1 info attribute_length]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-JVM性能调优]]></title>
    <url>%2Fposts%2F2019-03-06-JVM-JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 在高性能硬件上部署程序，目前主要有两种方式： (1)通过 64 位 JDK 来使用大内存；(2)使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。 1 使用 64 位 JDK 管理大内存堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。 如果堆内存为14 G，那么每次 Full GC 将长达数十秒。如果 Full GC 频繁发生，那么对于一个网站来说是无法忍受的。 对于用户交互性强、对停顿时间敏感的系统，可以给 Java 虚拟机分配超大堆的前提是有把握把应用程序的 Full GC 频率控制得足够低，至少要低到不会影响用户使用。 可能面临的问题： (1)内存回收导致的长时间停顿； (2)现阶段，64位 JDK 的性能普遍比 32 位 JDK 低； (3)需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生超过 10GB 的 Dump 文件），哪怕产生了快照也几乎无法进行分析； (4)相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。 2 使用 32 位 JVM 建立逻辑集群在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口， 然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。 考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性能需求， 也不需要保证每个虚拟机进程有绝对的均衡负载，因此使用无 Session 复制的亲合式集群是一个不错的选择。 我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据 SessionID 分配） 将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可。 可能遇到的问题： (1)尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致 IO 异常； (2)很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余； (3)各个节点受到 32 位的内存限制； (4)大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。 3 调优案例分析与实战3.1 场景描述一个小型系统，使用 32 位 JDK，4G 内存，测试期间发现服务端不定时抛出内存溢出异常。 加入 -XX:+HeapDumpOnOutOfMemoryError（添加这个参数后，堆内存溢出时就会输出异常日志）， 但再次发生内存溢出时，没有生成相关异常日志。 3.2 分析在 32 位 JDK 上，1.6G 分配给堆，还有一部分分配给 JVM 的其他内存，直接内存最大也只能在剩余的 0.4G 空间中分出一部分， 如果使用了 NIO，JVM 会在 JVM 内存之外分配内存空间，那么就要小心“直接内存”不足时发生内存溢出异常了。 3.3 直接内存的回收过程直接内存虽然不是 JVM 内存空间，但它的垃圾回收也由 JVM 负责。 垃圾收集进行时，虚拟机虽然会对直接内存进行回收， 但是直接内存却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收， 它只能等老年代满了后 Full GC，然后“顺便”帮它清理掉内存的废弃对象。 否则只能一直等到抛出内存溢出异常时，先 catch 掉，再在 catch 块里大喊 “System.gc()”。 要是虚拟机还是不听，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-内存分配与回收策略]]></title>
    <url>%2Fposts%2F2019-03-05-JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 Java所承诺的自动内存管理主要是针对对象内存的回收和对象内存的分配。 对象的内存分配，就是在堆上分配（也可能经过 JIT 编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的 Eden 区上，少数情况下可能直接分配在老年代，分配规则不固定，取决于当前使用的垃圾收集器组合以及相关的参数配置。 在Java虚拟机的五块内存空间中，程序计数器、Java虚拟机栈、本地方法栈内存的分配和回收都具有确定性，一半都在编译阶段就能确定下来需要分配的内存大小，并且由于都是线程私有，因此它们的内存空间都随着线程的创建而创建，线程的结束而回收。也就是这三个区域的内存分配和回收都具有确定性。 而Java虚拟机中的方法区因为是用来存储类信息、常量 静态变量，这些数据的变动性较小，因此不是Java内存管理重点需要关注的区域。 而对于堆，所有线程共享，所有的对象都需要在堆中创建和回收。虽然每个对象的大小在类加载的时候就能确定，但对象的数量只有在程序运行期间才能确定，因此堆中内存的分配具有较大的不确定性。此外，对象的生命周期长短不一，因此需要针对不同生命周期的对象采用不同的内存回收算法，增加了内存回收的复杂性。 综上所述：Java自动内存管理最核心的功能是堆内存中对象的分配与回收。 1 对象优先在 Eden 区中分配目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代。 在新生代中为了防止内存碎片问题，因此垃圾收集器一般都选用“复制”算法。因此，堆内存的新生代被进一步分为：Eden区＋Survior1区＋Survior2区。 每次创建对象时，首先会在Eden区中分配。 若Eden区已满，则在Survior1区中分配。 若Eden区＋Survior1区剩余内存太少，导致对象无法放入该区域时，就会启用“分配担保”，将当前Eden区＋Survior1区中的对象转移到老年代中，然后再将新对象存入Eden区。 大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 Minor GC vs Major GC/Full GC： Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。 Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。 在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。 2 大对象直接进入老年代所谓“大对象”就是指一个占用大量连续存储空间的对象，如数组。 大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或数据。 当发现一个大对象在Eden区＋Survior1区中存不下的时候就需要分配担保机制把当前Eden区＋Survior1区的所有对象都复制到老年代中去。 我们知道，一个大对象能够存入Eden区＋Survior1区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及到大量的复制，就会造成效率低下。 因此，对于大对象我们直接把他放到老年代中去，从而就能避免大量的复制操作。 那么，什么样的对象才是“大对象”呢？ 通过-XX:PretrnureSizeThreshold参数设置大对象 该参数用于设置大小超过该参数的对象被认为是“大对象”，直接进入老年代。 注意： 该参数只对Serial和ParNew收集器有效。 一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。 虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。（还记得吗，新生代采用复制算法回收垃圾） 3 生命周期较长的对象进入老年代(长期存活的对象将进入老年代)JVM 给每个对象定义了一个对象年龄计数器。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。使用 -XXMaxTenuringThreshold 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。 老年代用于存储生命周期较长的对象，那么我们如何判断一个对象的年龄呢？ 新生代中的每个对象都有一个年龄计数器，当新生代发生一次MinorGC后，存活下来的对象的年龄就加一，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。 使用-XXMaxTenuringThreshold设置新生代的最大年龄 设置该参数后，只要超过该参数的新生代对象都会被转移到老年代中去。 4 相同年龄的对象内存超过Survior内存一半的对象进入老年代(动态对象年龄判定)如果当前新生代的Survior中，年龄相同的对象的内存空间总和超过了Survior内存空间的一半，那么所有年龄相同的对象和超过该年龄的对象都被转移到老年代中去。无需等到对象的年龄超过MaxTenuringThreshold才被转移到老年代中去。 5 “分配担保”策略详解(空间分配担保)JDK 6 Update 24 之前的规则是这样的： 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立，Minor GC 可以确保是安全的； 如果不成立，则虚拟机会查看 HandlePromotionFailure 值是否设置为允许担保失败， 如果是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那此时也要改为进行一次 Full GC。 JDK 6 Update 24 之后的规则变为： 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。 通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。 当垃圾收集器准备要在新生代发起一次MinorGC时，首先会检查“老年代中最大的连续空闲区域的大小 是否大于 新生代中所有对象的大小？”，也就是老年代中目前能够将新生代中所有对象全部装下？ 若老年代能够装下新生代中所有的对象，那么此时进行MinorGC没有任何风险，然后就进行MinorGC。 若老年代无法装下新生代中所有的对象，那么此时进行MinorGC是有风险的，垃圾收集器会进行一次预测：根据以往MinorGC过后存活对象的平均数来预测这次MinorGC后存活对象的平均数。 如果以往存活对象的平均数小于当前老年代最大的连续空闲空间，那么就进行MinorGC，虽然此次MinorGC是有风险的。 如果以往存活对象的平均数大于当前老年代最大的连续空闲空间，那么就对老年代进行一次Full GC，通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。 这个过程就是分配担保。 注意： 分配担保是老年代为新生代作担保； 新生代中使用“复制”算法实现垃圾回收，老年代中使用“标记-清除”或“标记-整理”算法实现垃圾回收，只有使用“复制”算法的区域才需要分配担保，因此新生代需要分配担保，而老年代不需要分配担保。 总结一下有哪些情况可能会触发 JVM 进行 Full GC： (1)System.gc() 方法的调用 此方法的调用是建议 JVM 进行 Full GC，注意这只是建议而非一定，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。 (2)老年代空间不足 老年代空间不足会触发 Full GC操作，若进行该操作后空间依然不足，则会抛出错误： java.lang.OutOfMemoryError: Java heap space (3)永久代空间不足 JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中也称为永久代（Permanet Generation），存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出错误信息：java.lang.OutOfMemoryError: PermGen space (4)CMS GC 时出现 promotion failed 和 concurrent mode failure promotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。 (5)统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-HotSpot垃圾收集器]]></title>
    <url>%2Fposts%2F2019-03-04-JVM-HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 HotSpot 虚拟机提供了多种垃圾收集器，每种收集器都有各自的特点，虽然我们要对各个收集器进行比较，但并非为了挑选出一个最好的收集器。我们选择的只是对具体应用最合适的收集器。 1 新生代垃圾收集器(1)Serial 垃圾收集器（单线程） 只开启一条 GC 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程(Stop The World)。一般客户端应用所需内存较小，不会创建太多对象，而且堆内存不大，因此垃圾收集器回收时间短，即使在这段时间停止一切用户线程，也不会感觉明显卡顿。因此 Serial 垃圾收集器适合客户端使用。由于 Serial 收集器只使用一条 GC 线程，避免了线程切换的开销，从而简单高效。 (2)ParNew 垃圾收集器（多线程） ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。但清理过程依然需要 Stop The World。ParNew 追求“低停顿时间”,与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但线程切换需要额外的开销，因此在单 CPU 环境中表现不如 Serial。 (3)Parallel Scavenge 垃圾收集器（多线程） Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点： Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。 ParNew：追求降低用户停顿时间，适合交互式应用。 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) 追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC 需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行 GC 以便更快速完成，反过来又导致吞吐量下降。 通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比。 通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间。 通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略。我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio。 2 老年代垃圾收集器(1)Serial Old 垃圾收集器（单线程） Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用“标记-整理”算法；Serial 工作在新生代，使用“复制”算法。 (2)Parallel Old 垃圾收集器（多线程） Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。 (3)CMS 垃圾收集器 CMS(Concurrent Mark Sweep，并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。 并发标记：使用多条标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。 重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。 并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。 并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，总体上说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。 CMS 的缺点：a.吞吐量低b.无法处理浮动垃圾，导致频繁 Full GCc,使用“标记-清除”算法产生碎片空间 对于产生碎片空间的问题，可以通过开启 -XX:+UseCMSCompactAtFullCollection，在每次 Full GC 完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数 -XX:CMSFullGCsBeforeCompaction告诉 CMS，经过了 N 次 Full GC 之后再进行一次内存整理。 3 G1 通用垃圾收集器G1 是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。 从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 这里抛个问题👇：一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？ 并不！每个 Region 都有一个 Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历。 如果不计算维护 Remembered Set 的操作，G1 收集器的工作过程分为以下几个步骤： 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。 并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。 最终标记：Stop The World，使用多条标记线程并发执行。 筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-垃圾收集策略与算法]]></title>
    <url>%2Fposts%2F2019-03-03-JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。 这五个区域既然是存储空间，那么为了避免Java虚拟机在运行期间内存存满的情况，就必须得有一个垃圾收集者的角色，不定期地回收一些无效内存，以保障Java虚拟机能够健康地持续运行。 这个垃圾收集者就是平常我们所说的“垃圾收集器”，那么垃圾收集器在何时清扫内存？清扫哪些数据？这就是接下来我们要解决的问题。 程序计数器、Java虚拟机栈、本地方法栈都是线程私有的，也就是每条线程都拥有这三块区域，而且会随着线程的创建而创建，随着线程的结束而销毁。那么，垃圾收集器在何时清扫这三块区域的问题就解决了。 此外，Java虚拟机栈、本地方法栈中的栈帧会随着方法的开始而入栈，方法的结束而出栈，并且每个栈帧中的本地变量表都是在类被加载的时候就确定的。因此以上三个区域的垃圾收集工作具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。垃圾收集器能够清楚地知道何时清扫这三块区域中的哪些数据。 然而，堆和方法区中的内存清理工作就没那么容易了。只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。 堆和方法区所有线程共享，并且都在JVM启动时创建，一直得运行到JVM停止时。因此它们没办法根据线程的创建而创建、线程的结束而释放。 堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象只有在程序运行期间才能确定。 方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。 因此，堆和方法区的内存回收具有不确定性，因此垃圾收集器在回收堆和方法区内存的时候花了一些心思。 1 堆内存的回收1.1 如何判定哪些对象需要回收？在对堆进行对象回收之前，首先要判断哪些是无效对象。我们知道，一个对象不被任何对象或变量引用，那么就是无效对象，需要被回收。一般有两种判别方式： (1)引用计数法 每个对象都有一个计数器，当这个对象被一个变量或另一个对象引用一次，该计数器加一；若该引用失效则计数器减一。当计数器为0时，就认为该对象是无效对象。 在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。 引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。 例如：对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。 (2)可达性分析法 所有和GC Roots直接或间接关联的对象都是有效对象，和GC Roots没有关联的对象就是无效对象。 GC Roots是指： Java虚拟机栈所引用的对象(栈帧中局部变量表中引用类型的变量所引用的对象) 方法区中静态属性引用的对象 方法区中常量所引用的对象 本地方法栈所引用的对象 GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。 两者对比： 引用计数法虽然简单，但存在一个严重的问题，它无法解决循环引用的问题。 因此，目前主流语言均使用可达性分析方法来判断对象是否有效。 1.2 回收无效对象的过程对于可达性分析中不可达的对象，也并不是没有存活的可能。 当JVM筛选出失效的对象之后，并不是立即清除，而是再给对象一次重生的机会，具体过程如下： （1）判断该对象是否覆盖了finalize()方法 JVM 会判断此对象是否有必要执行 finalize() 方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。 如果对象被判定为有必要执行 finalize() 方法，那么对象会被放入一个 F-Queue 队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。 若已覆盖该方法，并该对象的finalize()方法还没有被执行过，那么就会将finalize()扔到F-Queue队列中； 若未覆盖该方法，则直接释放对象内存。 （2）执行F-Queue队列中的finalize()方法 虚拟机会以较低的优先级执行这些finalize()方法们，也不会确保所有的finalize()方法都会执行结束。如果finalize()方法中出现耗时操作，虚拟机就直接停止执行，将该对象清除。 （3）对象重生或死亡 如果在执行finalize()方法时，将this赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。 注意： 强烈不建议使用finalize()函数进行任何操作！如果需要释放资源，请使用try-finally。因为finalize()不确定性大，开销大，无法保证顺利执行。 任何一个对象的 finalize() 方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，想继续在 finalize() 中自救就失效了。 2 Java中引用的种类判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾手收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。 在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态reachable和垃圾收集的影响。 Java中根据生命周期的长短，将引用分为4类。 2.1 强引用（Strong Reference）类似 “Object obj = new Object()” 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们错误地保持了强引用，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。 我们平时所使用的引用就是强引用。 A a = new A(); 也就是通过关键字new创建的对象所关联的引用就是强引用。 只要强引用存在，该对象永远也不会被回收。 2.2 软引用（Soft Reference）软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 只有当堆即将发生OOM异常时，JVM才会回收软引用所指向的对象。 软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。 2.3 弱引用（Weak Reference）弱引用的强度比软引用更弱一些。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。 只要垃圾收集器运行，软引用所指向的对象就会被回收。 弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。 2.4 虚引用（Phantom Reference）虚引用也叫幽灵引用或者幻影引用，它和没有引用没有区别，无法通过虚引用访问对象的任何属性或函数。 一个对象关联虚引用唯一的作用就是在该对象被垃圾收集器回收之前会受到一条系统通知。 虚引用通过PhantomReference类来实现。 它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。 3 方法区的内存回收如果使用复制算法实现堆的内存回收，堆就会被分为新生代和老年代，新生代中的对象“朝生夕死”，每次垃圾回收都会清除掉大量的对象；而老年代中的对象生命较长，每次垃圾回收只有少量的对象被清除掉。 由于方法区中存放生命周期较长的类信息、常量、静态变量，因此方法区就像是堆的老年代，每次垃圾收集的只有少量的垃圾被清除掉。 方法区中主要清除两种垃圾： 废弃常量 废弃的类 3.1 如何判定废弃常量？清除废弃的常量和清除对象类似，只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 “blog” 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 “blog” 常量，也没有其它地方引用这个字面量，必要的话，”blog”常量会被清理出常量池。 3.2 如何废弃废弃的类？清除废弃类的条件较为苛刻： (1)该类的所有对象都已被清除 (2)该类的java.lang.Class对象没有被任何对象或变量引用,无法在任何地方通过反射访问该类的方法 只要一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区的时候创建，在方法区中该类被删除时清除。 (3)加载该类的ClassLoader已经被回收 4 垃圾收集算法知道了判定一个对象是无效对象、判定一个类是废弃类、判定一个常量是废弃常量的方法，也就是知道了垃圾收集器会清除哪些数据，那么接下来介绍如何清除这些数据。 4.1 标记-清除算法首先利用刚才介绍的方法判断需要清除哪些数据，并给它们做上标记；然后清除被标记的数据。 标记的过程：遍历所有的 GC Roots，然后将所有 GC Roots 可达的对象标记为存活的对象。 清除的过程：将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。 分析不足： 这种算法标记和清除过程效率都很低，而且清除完后存在大量碎片空间，导致无法存储大对象，降低了空间利用率。 （1）效率问题：标记和清除两个过程的效率都不高。 （2）空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 4.2 复制算法（新生代）为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。 将内存分成两份，只将数据存储在其中一块上。当需要回收垃圾时，也是首先标记出废弃的数据，然后将有用的数据复制到另一块内存上，最后将第一块内存全部清除。 分析： 这种算法避免了碎片空间，但内存被缩小了一半。而且每次都需要将有用的数据全部复制到另一片内存上去，效率不高。 优点：不会有内存碎片的问题。 缺点：内存缩小为原来的一半，浪费空间。 解决空间利用率问题： 在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，因此我们可以将内存划分成三块：Eden、From Survivor（Survior1）、To Survivor（Survior2），内存大小分别是8:1:1。分配内存时，只使用Eden和一块Survior1。当发现Eden+Survior1的内存即将满时，JVM会发起一次MinorGC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。 回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。 通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。 但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，那么此时就需要将对象转移到老年代中，这种方式叫做“分配担保”。无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。 什么是分配担保？ 当JVM准备为一个对象分配内存空间时，发现此时Eden+Survior中空闲的区域无法装下该对象，那么就会触发MinorGC，对该区域的废弃对象进行回收。但如果MinorGC过后只有少量对象被回收（依然有超过 10% 的对象存活），仍然无法装下新对象，那么此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程就是“分配担保”。 4.3 标记-整理算法（老年代）在回收垃圾前，首先将所有废弃的对象做上标记，然后将所有未被标记的对象移到一边，最后清空另一边区域即可。 标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历 GC Roots，然后将存活的对象标记。 整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。 分析： 它是一种老年代的垃圾收集算法。老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，因此如果选用“复制”算法，每次需要复制大量存活的对象，会导致效率很低。而且，在新生代中使用“复制”算法，当Eden+Survior中都装不下某个对象时，可以使用老年代的内存进行“分配担保”，而如果在老年代使用该算法，那么在老年代中如果出现Eden+Survior装不下某个对象时，没有其他区域给他作分配担保。因此，老年代中一般使用“标记-整理”算法。 4.4 分代收集算法将内存划分为老年代和新生代。老年代中存放寿命较长的对象，新生代中存放“朝生夕死”的对象。然后在不同的区域使用不同的垃圾收集算法。 根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。 新生代：复制算法老年代：标记-清除算法、标记-整理算法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-HotSpot虚拟机对象探秘]]></title>
    <url>%2Fposts%2F2019-03-02-JVM-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 1 对象的内存模型一个对象从逻辑角度看，它由成员变量和成员函数构成，从物理角度来看，对象是存储在堆中的一串二进制数，这串二进制数的组织结构如下: 在 HotSpot 虚拟机中，对象的内存布局分为以下 3 块区域： （1）对象头（Header） （2）实例数据（Instance Data） （3）对齐填充（Padding） 1.1 对象头对象头中记录了对象在运行过程中所需要使用的一些数据： (1)哈希码 (2)GC分代年龄 (3)锁状态标志 (4)线程持有的锁 (5)偏向线程ID (6)偏向时间戳 此外，对象头中可能还包含类型指针。通过该指针能确定这个对象所属哪个类。 此外，如果对象是一个数组，那么对象头中还要包含数组长度。 1.2 实例数据实例数据部分就是成员变量的值，其中包含父类的成员变量和本类的成员变量。 1.3 对齐填充用于确保对象的总长度为8字节的整数倍。 HotSpot要求对象的总长度必须是8字节的整数倍。由于对象头一定是8字节的整数倍，但实例数据部分的长度是任意的，因此需要对齐补充字段确保整个对象的总长度为8的整数倍。 对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。 2 对象的创建过程当虚拟机遇到一条含有new的指令时，会进行一系列对象创建的操作： （1）检查常量池中是否有即将要创建的这个对象所属的类的符号引用； 若常量池中没有这个类的符号引用，说明这个类还没有被定义！抛出ClassNotFoundException； 若常量池中有这个类的符号引用，则进行下一步工作； （2）进而检查这个符号引用所代表的类是否已经被JVM加载、解析和初始化过； 若该类还没有被加载，就找该类的class文件，并加载进方法区； 若该类已经被JVM加载，则准备为对象分配内存； （3）根据方法区中该类的信息确定该类所需的内存大小； 一个对象所需的内存大小是在这个对象所属类被定义完就能确定的！且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。 （4）从堆中划分一块对应大小的内存空间给新的对象；分配堆中内存有两种方式： a)指针碰撞 如果 Java 堆中内存绝对规整（说明采用的是“复制算法”或“标记整理法”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“指针碰撞”。 如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。 b)空闲列表 如果 Java 堆中内存并不规整，已使用的内存和空闲内存交错（说明采用的是标记-清除法，有碎片），此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“空闲列表”。 如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。 综上所述：JVM究竟采用哪种内存分配方法，取决于它使用了何种垃圾收集器。 （5）为对象中的成员变量赋上初始值(默认初始化)； （6）设置对象头中的信息； （7）调用对象的构造函数进行初始化：分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。 此时，整个对象的创建过程就完成了。 3 对象的访问方式所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 引用类型的变量中存放的是一个地址，那么根据地址类型的不同，对象有不同的访问方式： (1)句柄访问方式 堆中需要有一块叫做“句柄池”的内存空间，用于存放所有对象的地址和所有对象所属类的类信息，句柄中包含了对象实例数据与类型数据各自的具体地址信息。 引用类型的变量存放的是该对象在句柄池中的地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。 (2)直接指针访问方式 引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。 但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址。 比较: HotSpot采用直接指针方式访问对象，因为它只需一次寻址操作，从而在性能上比句柄访问方式快一倍。但它需要额外的策略来存储对象在方法区中类信息的地址。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-JVM内存结构]]></title>
    <url>%2Fposts%2F2019-03-01-JVM-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一直零零散散的学习JVM，看完就忘了，这里做个JVM的入门记录。 Java 虚拟机（Java Virtual Machine=JVM）的内存空间分为5个部分，分别是： 1.程序计数器 2.Java 虚拟机栈 3.本地方法栈 4.堆 5.方法区 JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。 1 程序计数器（PC 寄存器）1.1 程序计数器的定义程序计数器是一块较小的内存空间，是当前线程正在执行的字节码的行号指示器，即当前线程正在执行的那一条字节码指令的地址。 注： 若当前线程正在执行的是一个本地方法，那么此时程序计数器为空（Undefined）。 1.2 程序计数器的作用程序计数器有两个作用： （1）字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 （2）在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候，就能够知道该线程上次运行到哪儿了。 1.3 程序计数器的特点（1）一块较小的内存空间 （2）线程私有，每条线程都有自己的一个程序计数器。 （3）唯一一个不会出现OutOfMemoryError的内存区域。 （4）生命周期随着线程的创建而创建，随着线程的结束而销毁。 2 Java虚拟机栈（JVM Stack）（Java 栈）2.1 Java虚拟机栈的定义Java虚拟机栈是描述Java方法运行过程的内存模型。 Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括： （1）局部变量表 （2）存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。 （3）操作数栈 （4）动态链接 （5）方法出口信息 2.2 压栈出栈过程当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。 Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。 由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。 当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。 注意： 人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。 这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。真正的Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息等。 2.3 Java 虚拟机栈的特点（1）局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。而且，局部变量表的大小在编译时期就确定下来了，在创建的时候只需分配事先规定好的大小即可。此外，在方法运行的过程中局部变量表的大小是不会发生改变的。 （2）Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。 a) StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 b) OutOfMemoryError： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。 （3）Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的结束而销毁。 注：StackOverFlowError和OutOfMemoryError的异同？ StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 3 本地方法栈（C 栈）3.1 本地方法栈的定义本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。 本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。 3.2 栈帧变化过程本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、方法出口信息等。 方法执行结束后，相应的栈帧也会出栈，并释放内存空间。 也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。 4 堆4.1 堆的定义堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。 4.2 堆的特点（1）线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个的。 （2）在虚拟机启动时创建。 （3）垃圾回收的主要场所。 （4）可以进一步细分为：新生代(Eden区 、From Survior 、To Survivor)、老年代。 新生代又可被分为：Eden、From Survior、To Survior。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，更高效。 （5）堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出 OutOfMemoryError。 注意: Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。 5 方法区5.1 方法区的定义Java 虚拟机规范中定义方法区是堆的一个逻辑部分。 方法区中存放以下信息： （1）已经被虚拟机加载的类信息、 （2）常量 （3）静态变量 （4）即时编译器编译后的代码 5.2 方法区的特点（1）线程共享：方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。 （2）永久代：方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代（“永久代”）。 （3）内存回收效率低：方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。 （4）Java虚拟机规范对方法区的要求比较宽松：和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 5.3 运行时常量池方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。 一般在一个类中通过public static final来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。 当这个类被Java虚拟机加载后，.class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：String类的intern()方法就能在运行期间向常量池中添加字符串常量。 当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。 6 直接内存（堆外内存）直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。 6.1 操作直接内存在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的 DirectByteBuffer 对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。 直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出OOM（OutOfMemoryError ）异常。 6.2 直接内存与堆内存比较（1）直接内存申请空间耗费更高的性能 （2）直接内存读取 IO 的性能要优于普通的堆内存。 （3）直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO （4）堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO 注意：服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。 7 总结Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。 两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。 只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。 Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。 堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。 程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法栈。并且他们的生命周期和所属的线程一样。 而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WPS政府版最全整理集合]]></title>
    <url>%2Fposts%2F2019-01-20-wpsgov%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;WPS2019的政府版本已经更新了4个地区，可以下载。 使用方法： （1）把那行xxxx单位的字去了的方法： \Program Files (x86)\Kingsoft\WPS Office\11.8.2.8053\oem 替换图片就行了 （2）简单去广告方法： 首先打开控制面板，假装要卸载wps.然后卸载，wps会问你卸载原因。这时候你就选择广告太多，这时候会弹出彻底关闭广告的弹窗。 （3）赠送个人版的序列号： 序列号1：9DP6T-9AGWG-KWV33-9MPC8-JDCVF 序列号2：THUV2-32HH7-6NMHN-PTX7Y-QQCTH 序列号3：R7AKQ-KLBXV-RNX3F-BPACQ-NQDGE 1.广东省：广东省政府机关单位： http://wpspro.support.wps.cn/gov/guangdong/ WPS Office 2016 专用版（10.8.0.6423） 潮州市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/chaozhou/ WPS Office 2019 专业增强版（11.8.2.8053） 惠州市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/huizhou/ WPS Office 2019 专业版（11.8.2.7978） 中山市政府党政机关： http://wpspro.support.wps.cn/gov/guangdong/zhongshan/ WPS Office 2016 专业版（10.8.0.6470） 珠海市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/zhuhai/ WPS Office 2016 专业增强版（10.8.2.6726） 佛山市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/foshan/ （需要密码才能进入） 茂名市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/maoming/ WPS Office 2019 专业增强版（11.8.2.8053） 河源市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/heyuan/ WPS Office 2016 专业版（10.8.2.6837） 揭阳市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/jieyang/ WPS Office 2016 专业版（10.8.0.6423） 肇庆市党政机关单位： http://wpspro.support.wps.cn/gov/guangdong/zhaoqing/ WPS Office 2016 专业增强版（10.8.2.6613） 2.重庆市：重庆市政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/ WPS Office 2016 专用版（10.8.2.6762） 铜梁区党政机关单位： http://wpspro.support.wps.cn/gov/chongqing/tongliang/ WPS Office 2019 铜梁区党政机关专业版（11.8.2.8053） 巴南区党政机关单位： http://wpspro.support.wps.cn/gov/chongqing/banan/ WPS Office 2016 专业增强版（10.8.2.6837） 沙坪坝区政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/shapingba/ WPS Office 2016 专用版（10.8.2.6837） 荣昌区政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/rongchang/ WPS Office 2016 专业版（10.8.0.6206） 云阳县政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/yunyang/ WPS Office 2016 专业版（10.8.2.6726） 奉节县政府机关单位： http://wpspro.support.wps.cn/gov/chongqing/fengjie/ WPS Office 2016 专业增强版（10.8.0.6206） 巫溪县党政机关单位： http://wpspro.support.wps.cn/gov/chongqing/wuxi/ WPS Office 2016 专业版（10.8.0.6206） 秀山县党政机关单位： http://wpspro.support.wps.cn/gov/chongqing/xiushan/ WPS Office 2016 专用版（10.8.2.6666） 3.海南省：海南省党政机关单位： http://wpspro.support.wps.cn/gov/hainan/ WPS Office 2016 专业版（10.8.2.6784） 三亚市党政机关单位： http://wpspro.support.wps.cn/gov/hainan/sanya/ WPS Office 2016 专业版（10.8.2.6784） 4.云南省：云南省党政机关单位： http://wpsupdate.ynxgj.gov.cn:21009/wps_download/index.html WPS Office 2016 专业增强版（10.8.2.6837） 5.山东省：山东省部分省级预算单位： http://wpspro.support.wps.cn/gov/shandong/ WPS Office 2016 专业版（版本号：10.8.2.6726） 德州市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/dezhou/ WPS Office 2016 专业版（版本号：10.8.2.6837） 日照市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/rizhao/ WPS Office 2016 专业版（版本号：10.8.2.6948） 莱芜市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/laiwu/ WPS Office 2016 专业版（版本号：10.8.2.6870） 烟台市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/yantai/ WPS Office 2016 专业版（版本号：10.8.2.6726） 枣庄市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/zaozhuang/ WPS Office 2016 专业版（版本号：10.8.2.6949） 威海市党政机关单位： http://wpspro.support.wps.cn/gov/shandong/weihai/ WPS Office2019 （版本号：11.8.2.7978） 6.山西省：晋城市政府机关单位： http://wpspro.support.wps.cn/gov/shanxi/jincheng/ WPS Office 2016 专业版（10.8.0.6870） 运城市党政机关单位： http://wpspro.support.wps.cn/gov/shanxi/yuncheng/ WPS Office 2016 运城市党政机关专用版（10.8.0.6058） 国家税务总局山西省税务局： http://wpspro.support.wps.cn/gov/shanxi/shuiwu/ WPS Office 2016 专业版（10.8.0.6423） 7.广西省：广西省党政机关单位： http://wpspro.support.wps.cn/gov/guangxi/ WPS Office 2016 专用版（10.8.2.6666） 8.吉林省：吉林市党政机关单位： http://wpspro.support.wps.cn/gov/jilin/ WPS Office 2016 专用版（10.8.0.6501） 9.湖南省：长沙市党政机关单位： http://wpspro.support.wps.cn/gov/hunan/changsha/ WPS Office 2016 专业版（10.8.0.6058） 10.四川省：四川省政府机关单位： http://wpspro.support.wps.cn/gov/sichuan/ WPS Office 2016 专业版（10.8.2.6784） 成都市党政机关单位： http://wpspro.support.wps.cn/gov/sichuan/chengdu/ WPS Office 2016 专业版（10.8.0.6058） 雅安市党政机关单位： http://wpspro.support.wps.cn/gov/sichuan/yaan/ WPS Office 2016 专业版（10.8.0.6058） 广元市教育行业： http://wpspro.support.wps.cn/gov/sichuan/guangyuan/ WPS Office 2016 广元市教育专用版（10.8.0.6253） 11.辽宁省：辽宁省直机关政府单位： http://wpspro.support.wps.cn/gov/liaoning/ WPS_Office_2016_辽宁省直机关政府专用版 沈阳市党政机关单位： http://wpspro.support.wps.cn/gov/liaoning/shenyang/ WPS Office 2013 专业增强版（9.1.0.5026） 12.黑龙江省：黑龙江省直党政机关： http://wpspro.support.wps.cn/gov/heilongjiang/ WPS Office 2016 专业版（版本号：10.8.2.6870） 大庆市党政机关单位： http://wpspro.support.wps.cn/gov/heilongjiang/daqing/ WPS Office 2016 专业版（版本号：10.8.2.6666） 绥化市党政机关单位： http://wpspro.support.wps.cn/gov/heilongjiang/suihua/ WPS Office 2016 专业版（版本号：10.8.2.6784） 13.福建省：福建省党政机关单位： http://wpspro.support.wps.cn/gov/fujian/ WPS Office 2016 福建省直试用版（10.8.0.6501） 泉州市党政机关单位： http://wpspro.support.wps.cn/gov/fujian/quanzhou/ WPS Office 2016 专业增强版（10.8.0.6058） 福州市党政机关单位： http://wpspro.support.wps.cn/gov/fujian/fuzhou/ WPS Office 2016 专业增强版（10.8.0.6058） 厦门市党政机关单位： http://wpspro.support.wps.cn/gov/fujian/xiamen/ WPS Office 2016 专业版和专业增强版（10.8.0.6501） 14.江西省：江西省党政机关单位： http://wpspro.support.wps.cn/gov/jiangxi/ WPS Office 2016 江西省电子政务专版（10.8.0.6294） 15.西藏自治区：西藏自治区党政机关单位： http://wpspro.support.wps.cn/gov/xizang/ WPS Office 2016 专业版（10.8.2.6666） 16.北京市：西城区政府机关单位： http://wpspro.support.wps.cn/gov/beijing/xicheng/ WPS Office 2016 专业版（10.8.0.6253） 平谷区政府机关单位： http://wpspro.support.wps.cn/gov/beijing/pinggu/ WPS Office 2016 专业版（10.8.2.6726） 石景山区党政机关单位： http://wpspro.support.wps.cn/gov/beijing/shijingshan/ WPS Office 2016 专业版（10.8.0.6058） 17.安徽省：六安市政府机关单位： http://wpspro.support.wps.cn/gov/anhui/liuan/ WPS Office 2016 专业增强版（10.8.0.6253） 18.湖北省：武汉市党政机关单位： http://wpspro.support.wps.cn/gov/hubei/wuhan/ WPS Office 2016 专业增强版（10.8.2.6837） 19.各其他企业单位：中国能源建设股份有限公司： http://wpspro.support.wps.cn/enterprise/ceec/ WPS Office 2016 专业增强版（10.8.2.6784） 中国铁建： http://wpspro.support.wps.cn/enterprise/crcc/ WPS Office（10.8.0.6470） 石家庄市人力资源和社会保障局： http://www.sjzrs.gov.cn/col/1515395624617/2018/02/11/1518329562990.html WPS Office 2016 专业版（10.8.0.5562）]]></content>
      <categories>
        <category>IT</category>
        <category>WPS</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>WPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用深度学习识别12306图片验证码]]></title>
    <url>%2Fposts%2F2019-01-12-12306_captcha%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在写12306抢票软件，发现图片验证码绕不过，开始用手动输入图片验证码的方式去登录12306账户，幸好，只有登录的时候需要验证图片，下单的时候不需要图片验证码识别，成功购票！ &emsp;&emsp;但是，怎么能这么轻易的放过图片验证码呢？这里，学以致用，如何使用深度学习去识别12306图片验证码呢？ &emsp;&emsp;12306的图片验证码是从8个图片中找到要求的物体，如下图所示： &emsp;&emsp;统计了1000个左右的样本图片，发现12306的图片类别只有80个，如下列表： 药片 中国结 仪表盘 公交卡 冰箱 创可贴 刺绣 剪纸 印章 卷尺 双面胶 口哨 啤酒 安全帽 开瓶器 手掌印 打字机 护腕 拖把 挂钟 排风机 文具盒 日历 本子 档案袋 棉棒 樱桃 毛线 沙包 沙拉 海报 海苔 海鸥 漏斗 烛台 热水袋 牌坊 狮子 珊瑚 电子秤 电线 电饭煲 盘子 篮球 红枣 红豆 红酒 绿豆 网球拍 老虎 耳塞 航母 苍蝇拍 茶几 茶盅 菠萝 蒸笼 薯条 蚂蚁 蜜蜂 蜡烛 蜥蜴 订书机 话梅 调色板 跑步机 路灯 辣椒酱 金字塔 钟表 铃铛 锅铲 锣 锦旗 雨靴 鞭炮 风铃 高压锅 黑板 龙舟 &emsp;&emsp;通过一轮又一轮的训练12306的图片，生成了识别的模型。关于具体的模型训练，此处省略一亿字。 &emsp;&emsp;由于是小白，这里图片的识别不是很高，没有达到100%，测试总体的准确率在75% - 85% 之间，还有完善的空间。 &emsp;&emsp;这里，在本地搭建了个临时访问的web网站，可以体验体验图片的识别。 &emsp;&emsp;请用电脑浏览器打开 http://idl.free.idcfengye.com/ 演示：&emsp;&emsp;打开上面的演示地址： &emsp;&emsp;演示的图片验证码文件： &emsp;&emsp;上传文件之后，跳到显示识别出来的结果的页面： &emsp;&emsp;OK，最后有个问题，最近一直在思考：Deep Learning 真的是泡沫吗？]]></content>
      <categories>
        <category>图片识别</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>12306</tag>
        <tag>深度学习</tag>
        <tag>验证码</tag>
        <tag>图片识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派安装Tensorflow]]></title>
    <url>%2Fposts%2F2018-12-03-raspberrypi_tensorflow%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;树莓派如何安装Tensorflow呢？ &emsp;&emsp;官方提供的方式感觉太复杂，这里按照如下步骤，也能完成Tensorflow在树莓派上的安装。 # 安装驱动 sudo apt install libatlas-base-dev # 安装TensorFlow pip3 install tensorflow &emsp;&emsp;安装TensorFlow的时候会自动下载安装依赖的工具，如：numpy，tensorboard，markdown 等等。 &emsp;&emsp;如果下载很慢，可以去 piwheels网站 上下载。 &emsp;&emsp;如果现实cv2导入错误，可以去之前的博客文章《python3安装opencv爬坑步骤》找到解决方法 &emsp;&emsp;实现Hello World: import tensorflow as tf hello = tf.constant(&#39;Hello, TensorFlow!&#39;) sess = tf.Session() print(sess.run(hello)) &emsp;&emsp; &emsp;&emsp;OK，大功告成！]]></content>
      <categories>
        <category>Tensorflow</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>raspberry pi</tag>
        <tag>pi</tag>
        <tag>raspbian</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派配置WIFI信息]]></title>
    <url>%2Fposts%2F2018-12-01-raspberrypi_wifi%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;树莓派如何配置WIFI信息？ &emsp;&emsp;通过配置wpa_supplicant.conf可以设置要连接的无线网。 sudo nano /etc/wpa_supplicant/wpa_supplicant.conf &emsp;&emsp;在文件末尾出添加一下代码，并替换掉ssid_name以及password即可。 network=&#123; ssid=&quot;ssid_name&quot; key_mgmt=WPA-PSK psk=&quot;password&quot; &#125; &emsp;&emsp;添加多个无线网络配置,只要添加多个network即可。 network=&#123; ssid=&quot;SSID1&quot; psk=&quot;passwordl&quot; id_str=&quot;ssidl&quot; &#125; network=&#123; ssid=&quot;SSID2&quot; psk=&quot;password2&quot; id_str=&quot;ssid2&quot; &#125; &emsp;&emsp;如果有多个网络，可以添加优先级选项来选择具体连接哪一个网络。具有最高优先级的范围内的网络将是优先连接的网络。 network=&#123; ssid=&quot;SSID1&quot; psk=&quot;password1&quot; priority=1 id_str=&quot;ssid1&quot; &#125; network=&#123; ssid=&quot;SSID2&quot; psk=&quot;password2&quot; priority=2 id_str=&quot;ssid2&quot; &#125; &emsp;&emsp;添加没有密码的WIFI网络，只要将key_mgmt设置为NONE network=&#123; ssid=&quot;ssid_name&quot; key_mgmt=NONE &#125;]]></content>
      <categories>
        <category>IT</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>raspberry pi</tag>
        <tag>pi</tag>
        <tag>raspbian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2Fposts%2F2019-01-04-HashMap%2F</url>
    <content type="text"><![CDATA[HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序； 简介HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序； 继承体系 HashMap实现了Cloneable，可以被克隆。 HashMap实现了Serializable，可以被序列化。 HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。 存储结构 在Java中，HashMap的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。 在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。 当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。 数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。 源码解析属性/** * The default initial capacity - MUST be a power of two. * 默认的初始容量为16 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. * 最大的容量为2的30次方 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. * 默认的装载因子 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. * 当一个桶中的元素个数大于等于8时进行树化 */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. * 当一个桶中的元素个数小于等于6时把树转化为链表 */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * 当桶的个数达到64的时候才进行树化 */ static final int MIN_TREEIFY_CAPACITY = 64; /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) * 数组，又叫作桶（bucket） */ transient Node&lt;K,V&gt;[] table; /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). * 作为entrySet()的缓存 */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * The number of key-value mappings contained in this map. * 元素的数量 */ transient int size; /** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). * 修改次数，用于在迭代的时候执行快速失败策略 */ transient int modCount; /** * The next size value at which to resize (capacity * load factor). * 当桶的使用数量达到多少时进行扩容，threshold = capacity * loadFactor * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; /** * The load factor for the hash table. * 装载因子 * @serial */ final float loadFactor; （1）容量 容量为数组的长度，亦即桶的个数，默认为16，最大为2的30次方，当容量达到64时才可以树化。 （2）装载因子 装载因子用来计算容量达到多少时才进行扩容，默认装载因子为0.75。 （3）树化 树化，当容量达到64且链表的长度达到8时进行树化，当链表的长度小于6时反树化。 Node内部类Node是一个典型的单链表节点，其中，hash用来存储key计算得来的hash值。 /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; TreeNode内部类这个类继承自LinkedHashMap中的Entry类。 TreeNode是一个典型的树型节点，其中，prev是链表中的节点，用于在删除元素的时候可以快速找到它的前置节点。 // 位于HashMap中 /** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */ static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; &#125; // 位于LinkedHashMap中，典型的双向链表节点 static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; HashMap()构造方法空参构造方法，全部使用默认值。 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; HashMap(int initialCapacity)构造方法调用HashMap(int initialCapacity, float loadFactor)构造方法，传入默认装载因子。 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; HashMap(int initialCapacity, float loadFactor)构造方法判断传入的初始容量和装载因子是否合法，并计算扩容门槛，扩容门槛为传入的初始容量往上取最近的2的n次方。 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; // 检查传入的初始容量是否合法 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检查装载因子是否合法 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; // 计算扩容门槛 this.threshold = tableSizeFor(initialCapacity); &#125; /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; // 扩容门槛为传入的初始容量往上取最近的2的n次方 int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; put(K key, V value)方法添加元素的入口。 /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; // 调用hash(key)计算出key的hash值 return putVal(hash(key), key, value, false, true); &#125; /** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don&#39;t benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */ static final int hash(Object key) &#123; int h; // 如果key为null，则hash值为0，否则调用key的hashCode()方法 // 并让高16位与整个hash异或，这样做是为了使计算出的hash更分散 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 如果桶的数量为0，则初始化 if ((tab = table) == null || (n = tab.length) == 0) // 调用resize()初始化 n = (tab = resize()).length; // (n - 1) &amp; hash 计算元素在哪个桶中 // 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 新建一个节点放在桶中 tab[i] = newNode(hash, key, value, null); else &#123; // 如果桶中已经有元素存在了 Node&lt;K,V&gt; e; K k; // 如果桶中第一个元素的key与待插入元素的key相同，保存到e中用于后续修改value值 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 如果第一个元素是树节点，则调用树节点的putTreeVal插入元素 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 遍历这个桶对应的链表，binCount用于存储链表中元素的个数 for (int binCount = 0; ; ++binCount) &#123; // 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表最后插入一个新节点 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 如果插入新节点后链表长度大于8，则判断是否需要树化，因为第一个元素没有加到binCount中，所以这里-1 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果待插入的key在链表中找到了，则退出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 如果找到了对应key的元素 if (e != null) &#123; // existing mapping for key // 记录下旧值 V oldValue = e.value; // 判断是否需要替换旧值 if (!onlyIfAbsent || oldValue == null) // 替换旧值为新值 e.value = value; // 在节点被访问后做点什么事，在LinkedHashMap中用到 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 到这里了说明没有找到元素 // 修改次数加1 ++modCount; // 元素数量加1，判断是否需要扩容 if (++size &gt; threshold) // 扩容 resize(); // 在节点插入后做点什么事，在LinkedHashMap中用到 afterNodeInsertion(evict); // 没找到元素返回null return null; &#125; （1）计算key的hash值； （2）如果桶（数组）数量为0，则初始化桶； （3）如果key所在的桶没有元素，则直接插入； （4）如果key所在的桶中的第一个元素的key与待插入的key相同，说明找到了元素，转后续流程（9）处理； （5）如果第一个元素是树节点，则调用树节点的putTreeVal()寻找元素或插入树节点； （6）如果不是以上三种情况，则遍历桶对应的链表查找key是否存在于链表中； （7）如果找到了对应key的元素，则转后续流程（9）处理； （8）如果没找到对应key的元素，则在链表最后插入一个新节点并判断是否需要树化； （9）如果找到了对应key的元素，则判断是否需要替换旧值，并直接返回旧值； （10）如果插入了元素，则数量加1并判断是否需要扩容； resize()方法扩容方法 /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() &#123; // 旧数组 Node&lt;K,V&gt;[] oldTab = table; // 旧容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 旧扩容门槛 int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 如果旧容量达到了最大容量，则不再进行扩容 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 如果旧容量的两倍小于最大容量并且旧容量大于默认初始容量（16），则容量扩大为两部，扩容门槛也扩大为两倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold // 使用非默认构造方法创建的map，第一次插入元素会走到这里 // 如果旧容量为0且旧扩容门槛大于0，则把新容量赋值为旧门槛 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults // 调用默认构造方法创建的map，第一次插入元素会走到这里 // 如果旧容量旧扩容门槛都是0，说明还未初始化过，则初始化容量为默认容量，扩容门槛为默认容量*默认装载因子 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; // 如果新扩容门槛为0，则计算为容量*装载因子，但不能超过最大容量 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 赋值扩容门槛为新门槛 threshold = newThr; // 新建一个新容量的数组 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 把桶赋值为新数组 table = newTab; // 如果旧数组不为空，则搬移元素 if (oldTab != null) &#123; // 遍历旧数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 如果桶中第一个元素不为空，赋值给e if ((e = oldTab[j]) != null) &#123; // 清空旧桶，便于GC回收 oldTab[j] = null; // 如果这个桶中只有一个元素，则计算它在新桶中的位置并把它搬移到新桶中 // 因为每次都扩容两倍，所以这里的第一个元素搬移到新桶的时候新桶肯定还没有元素 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // 如果这个链表不止一个元素且不是一颗树 // 则分化成两个链表插入到新的桶中去 // 比如，假如原来容量为4，3、7、11、15这四个元素都在三号桶中 // 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去 // 也就是分化成了两个链表 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // (e.hash &amp; oldCap) == 0的元素放在低位链表中 // 比如，3 &amp; 4 == 0 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; // (e.hash &amp; oldCap) != 0的元素放在高位链表中 // 比如，7 &amp; 4 != 0 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 遍历完成分化成两个链表了 // 低位链表在新桶中的位置与旧桶一样（即3和11还在三号桶中） if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了） if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; （1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12； （2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方； （3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍； （4）创建一个新容量的桶； （5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置； TreeNode.putTreeVal(…)方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Map</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派修改镜像源]]></title>
    <url>%2Fposts%2F2018-12-02-raspberrypi_source%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;树莓派如何修改镜像源呢？ &emsp;&emsp;树莓派内置的镜像源，访问很慢，这里修改成国内访问速度快的镜像源。 &emsp;&emsp;一、树莓派基金会提供的源 &emsp;&emsp;/etc/apt/sources.list.d/raspi.list里的软件源是树莓派基金会单独（非Raspbian开发者）提供/维护的软件源，主要包括raspi-config、minecraftpi、树莓派桌面环境、内核固件驱动等少量软件。 &emsp;&emsp;1.Debian 8 Jessie 中科大 deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ jessie main ui 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/debian/ jessie main ui 默认官方源 deb http://archive.raspberrypi.org/debian/ jessie main ui &emsp;&emsp;2.Debian 9 Stretch 中科大 deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/debian/ stretch main ui 默认官方源 deb http://archive.raspberrypi.org/debian/ stretch main ui &emsp;&emsp;二、Raspbian源 &emsp;&emsp;raspbian这个源是由独立开发者维护的，与树莓派基金会并无直接联系。国内源比较多，选择一个与自己延迟最小或连接速度最好或物理距离最短的即可。无需担心各个软件源内容上会有不同，基本上各个站点每天都会同步一次，绝大部分情况下某软件安装不了与用了哪个站点提供的源无关。通常位于/etc/apt/sources.list &emsp;&emsp;1.Debian 8 Jessie 中科大 deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 大连东软 deb http://mirrors.neusoft.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 重庆大学 deb http://mirrors.cqu.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 浙江大学 deb http://mirrors.zju.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 阿里云 deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main contrib non-free rpi 搜狐 deb http://mirrors.sohu.com/raspbian/raspbian/ jessie main contrib non-free rpi 元智大学（中国台湾） deb http://ftp.cse.yzu.edu.tw/Linux/raspbian/raspbian/ jessie main contrib non-free rpi 新加坡国立大学 deb http://mirror.nus.edu.sg/raspbian/raspbian/ jessie main contrib non-free rpi 北陆先端科学技术大学院大学（日本知名镜像站，日常出口带宽2g） deb http://ftp.jaist.ac.jp/raspbian/ jessie main contrib non-free rpi 牛津大学 deb http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/ jessie main contrib non-free rpi 美国Berkely大学 deb http://mirrors.ocf.berkeley.edu/raspbian/raspbian/ jessie main contrib non-free rpi 美国俄克拉荷马大学 deb http://reflection.oss.ou.edu/raspbian/raspbian/ jessie main contrib non-free rpi 南非知名软件源 deb http://mirror.liquidtelecom.com/raspbian/raspbian/ jessie main contrib non-free rpi 默认源（带重定向by mirrorbrain） deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi 官方源 deb https://archive.raspbian.org/raspbian/ jessie main contrib non-free rpi &emsp;&emsp;2.Debian 9 Stretch 中科大 deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 大连东软 deb http://mirrors.neusoft.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 重庆大学 deb http://mirrors.cqu.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 浙江大学 deb http://mirrors.zju.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 阿里云 deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi 搜狐 deb http://mirrors.sohu.com/raspbian/raspbian/ stretch main contrib non-free rpi 元智大学（中国台湾） deb http://ftp.cse.yzu.edu.tw/Linux/raspbian/raspbian/ stretch main contrib non-free rpi 新加坡国立大学 deb http://mirror.nus.edu.sg/raspbian/raspbian/ stretch main contrib non-free rpi 北陆先端科学技术大学院大学（日本知名镜像站，日常出口带宽2g） deb http://ftp.jaist.ac.jp/raspbian/ stretch main contrib non-free rpi 牛津大学 deb http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/ stretch main contrib non-free rpi 美国Berkely大学 deb http://mirrors.ocf.berkeley.edu/raspbian/raspbian/ stretch main contrib non-free rpi 美国俄克拉荷马大学 deb http://reflection.oss.ou.edu/raspbian/raspbian/ stretch main contrib non-free rpi 南非知名软件源 deb http://mirror.liquidtelecom.com/raspbian/raspbian/ stretch main contrib non-free rpi 默认源（带重定向by mirrorbrain） deb http://mirrordirector.raspbian.org/raspbian/ stretch main contrib non-free rpi 官方源 deb https://archive.raspbian.org/raspbian/ stretch main contrib non-free rpi &emsp;&emsp;这里提供个raspbian官方镜像列表 : https://www.raspbian.org/RaspbianMirrors]]></content>
      <categories>
        <category>IT</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>raspberry pi</tag>
        <tag>pi</tag>
        <tag>raspbian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CopyOnWriteArrayList 源码分析]]></title>
    <url>%2Fposts%2F2019-01-03-CopyOnWriteArrayList%2F</url>
    <content type="text"><![CDATA[CopyOnWriteArrayList是ArrayList的线程安全版本，内部也是通过数组实现，每次对数组的修改都完全拷贝一份新的数组来修改，修改完了再替换掉老数组，这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。 简介CopyOnWriteArrayList是ArrayList的线程安全版本，内部也是通过数组实现，每次对数组的修改都完全拷贝一份新的数组来修改，修改完了再替换掉老数组，这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。 继承体系 CopyOnWriteArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。 CopyOnWriteArrayList实现了List，提供了基础的添加、删除、遍历等操作。 CopyOnWriteArrayList实现了RandomAccess，提供了随机访问的能力。 CopyOnWriteArrayList实现了Cloneable，可以被克隆。 CopyOnWriteArrayList实现了Serializable，可以被序列化。 源码分析主要属性/** * The lock protecting all mutators * 用于修改时加锁 */ final transient ReentrantLock lock = new ReentrantLock(); /** * The array, accessed only via getArray/setArray. * 真正存储元素的地方，只能通过getArray()/setArray()访问 */ private transient volatile Object[] array; （1）lock 用于修改时加锁，使用transient修饰表示不自动序列化。 （2）array 真正存储元素的地方，使用transient修饰表示不自动序列化，使用volatile修饰表示一个线程对这个字段的修改另外一个线程立即可见。 问题：为啥没有size字段？ CopyOnWriteArrayList()构造方法创建空数组： /** * Creates an empty list. */ public CopyOnWriteArrayList() &#123; setArray(new Object[0]); &#125; /** * Sets the array. */ final void setArray(Object[] a) &#123; array = a; &#125; CopyOnWriteArrayList 构造方法如果c是CopyOnWriteArrayList类型，直接把它的数组赋值给当前list的数组，注意这里是浅拷贝，两个集合共用同一个数组。 如果c不是CopyOnWriteArrayList类型，则进行拷贝把c的元素全部拷贝到当前list的数组中。 /** * Creates a list containing the elements of the specified * collection, in the order they are returned by the collection&#39;s * iterator. * * @param c the collection of initially held elements * @throws NullPointerException if the specified collection is null */ public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) //如果c也是CopyOnWriteArrayList类型,直接把它的数组拿过来使用 elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; // 否则调用其toArray()方法将集合元素转化为数组 elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) // 这里c.toArray()返回的不一定是Object[]类型,详细原因见ArrayList里面的分析 if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements); &#125; CopyOnWriteArrayList(E[] toCopyIn)构造方法把toCopyIn的元素拷贝给当前list的数组。 /** * Creates a list holding a copy of the given array. * * @param toCopyIn the array (a copy of this array is used as the * internal array) * @throws NullPointerException if the specified array is null */ public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class)); &#125; add(E e)方法添加一个元素到末尾。 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 获取旧数组 Object[] elements = getArray(); int len = elements.length; // 将旧数组元素拷贝到新数组中 // 新数组大小是旧数组大小加1 Object[] newElements = Arrays.copyOf(elements, len + 1); // 将元素放在最后一位 newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; （1）加锁； （2）获取元素数组； （3）新建一个数组，大小为原数组长度加1，并把原数组元素拷贝到新数组； （4）把新添加的元素放到新数组的末尾； （5）把新数组赋值给当前对象的array属性，覆盖原数组； （6）解锁； add(int index, E element)方法添加一个元素在指定索引处。 /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 获取旧数组 Object[] elements = getArray(); int len = elements.length; // 检查是否越界, 可以等于len if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+len); Object[] newElements; int numMoved = len - index; if (numMoved == 0) // 如果插入的位置是最后一位,那么拷贝一个n+1的数组, 其前n个元素与旧数组一致 newElements = Arrays.copyOf(elements, len + 1); else &#123; // 如果插入的位置不是最后一位,那么新建一个n+1的数组 newElements = new Object[len + 1]; // 拷贝旧数组前index的元素到新数组中 System.arraycopy(elements, 0, newElements, 0, index); // 将index及其之后的元素往后挪一位拷贝到新数组中 // 这样正好index位置是空出来的 System.arraycopy(elements, index, newElements, index + 1, numMoved); &#125; // 将元素放置在index处 newElements[index] = element; setArray(newElements); &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; （1）加锁； （2）检查索引是否合法，如果不合法抛出IndexOutOfBoundsException异常，注意这里index等于len也是合法的； （3）如果索引等于数组长度（也就是数组最后一位再加1），那就拷贝一个len+1的数组； （4）如果索引不等于数组长度，那就新建一个len+1的数组，并按索引位置分成两部分，索引之前（不包含）的部分拷贝到新数组索引之前（不包含）的部分，索引之后（包含）的位置拷贝到新数组索引之后（不包含）的位置，索引所在位置留空； （5）把索引位置赋值为待添加的元素； （6）把新数组赋值给当前对象的array属性，覆盖原数组； （7）解锁； addIfAbsent(E e)方法添加一个元素如果这个元素不存在于集合中。 /** * Appends the element, if not present. * * @param e element to be added to this list, if absent * @return &#123;@code true&#125; if the element was added */ public boolean addIfAbsent(E e) &#123; // 获取元素数组, 取名为快照 Object[] snapshot = getArray(); // 检查如果元素不存在,直接返回false // 如果存在再调用addIfAbsent()方法添加元素 return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false : addIfAbsent(e, snapshot); &#125; /** * A version of addIfAbsent using the strong hint that given * recent snapshot does not contain e. */ private boolean addIfAbsent(E e, Object[] snapshot) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 重新获取旧数组 Object[] current = getArray(); int len = current.length; // 如果快照与刚获取的数组不一致 // 说明有修改 if (snapshot != current) &#123; // Optimize for lost race to another addXXX operation // 重新检查元素是否在刚获取的数组里 int common = Math.min(snapshot.length, len); for (int i = 0; i &lt; common; i++) // 到这个方法里面了, 说明元素不在快照里面 if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) return false; if (indexOf(e, current, common, len) &gt;= 0) return false; &#125; // 拷贝一份n+1的数组 Object[] newElements = Arrays.copyOf(current, len + 1); // 将元素放在最后一位 newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; （1）检查这个元素是否存在于数组快照中； （2）如果存在直接返回false，如果不存在调用addIfAbsent(E e, Object[] snapshot)处理; （3）加锁； （4）如果当前数组不等于传入的快照，说明有修改，检查待添加的元素是否存在于当前数组中，如果存在直接返回false; （5）拷贝一个新数组，长度等于原数组长度加1，并把原数组元素拷贝到新数组中； （6）把新元素添加到数组最后一位； （7）把新数组赋值给当前对象的array属性，覆盖原数组； （8）解锁； get(int index)获取指定索引的元素，支持随机访问，时间复杂度为O(1)。 /** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; // 获取元素不需要加锁 // 直接返回index位置的元素 // 这里是没有做越界检查的, 因为数组本身会做越界检查 return get(getArray(), index); &#125; @SuppressWarnings(&quot;unchecked&quot;) private E get(Object[] a, int index) &#123; return (E) a[index]; &#125; /** * Gets the array. Non-private so as to also be accessible * from CopyOnWriteArraySet class. */ final Object[] getArray() &#123; return array; &#125; （1）获取元素数组； （2）返回数组指定索引位置的元素； remove(int index)方法删除指定索引位置的元素。 /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). Returns the element that was removed from the list. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 获取旧数组 Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) // 如果移除的是最后一位 // 那么直接拷贝一份n-1的新数组, 最后一位就自动删除了 setArray(Arrays.copyOf(elements, len - 1)); else &#123; // 如果移除的不是最后一位 // 那么新建一个n-1的新数组 Object[] newElements = new Object[len - 1]; // 将前index的元素拷贝到新数组中 System.arraycopy(elements, 0, newElements, 0, index); // 将index后面(不包含)的元素往前挪一位 // 这样正好把index位置覆盖掉了, 相当于删除了 System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; （1）加锁； （2）获取指定索引位置元素的旧值； （3）如果移除的是最后一位元素，则把原数组的前len-1个元素拷贝到新数组中，并把新数组赋值给当前对象的数组属性； （4）如果移除的不是最后一位元素，则新建一个len-1长度的数组，并把原数组除了指定索引位置的元素全部拷贝到新数组中，并把新数组赋值给当前对象的数组属性； （5）解锁并返回旧值； size()方法返回数组的长度。 /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() &#123; // 获取元素个数不需要加锁 // 直接返回数组的长度 return getArray().length; &#125; 总结（1）CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全； （2）CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能比较低下； （3）CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)； （4）CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合； （5）CopyOnWriteArrayList只保证最终一致性，不保证实时一致性； 问题:为什么CopyOnWriteArrayList没有size属性？因为每次修改都是拷贝一份正好可以存储目标个数元素的数组，所以不需要size属性了，数组的长度就是集合的大小，而不像ArrayList数组的长度实际是要大于集合的大小的。 比如，add(E e)操作，先拷贝一份n+1个元素的数组，再把新元素放到新数组的最后一位，这时新数组的长度为len+1了，也就是集合的size了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
        <tag>Collection</tag>
        <tag>源码分析</tag>
        <tag>CopyOnWriteArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList 源码分析]]></title>
    <url>%2Fposts%2F2019-01-02-LinkedList%2F</url>
    <content type="text"><![CDATA[LinkedList是一个以双向链表实现的List，它除了作为List使用，还可以作为队列或者栈来使用，它是怎么实现的呢？让我们一起来学习吧。 问题（1）LinkedList只是一个List吗？ （2）LinkedList还有其它什么特性吗？ （3）LinkedList为啥经常拿出来跟ArrayList比较？ 简介LinkedList是一个以双向链表实现的List，它除了作为List使用，还可以作为队列或者栈来使用，它是怎么实现的呢？ 继承体系 通过继承体系，我们可以看到LinkedList不仅实现了List接口，还实现了Queue和Deque接口，所以它既能作为List使用，也能作为双端队列使用，当然也可以作为栈使用。 源码分析主要属性// 元素个数 transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) * * 链表首节点 */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) * * 链表尾节点 */ transient Node&lt;E&gt; last; 属性很简单，定义了元素个数size和链表的首尾节点。 主要内部类典型的双链表结构： private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 主要构造方法/** * Constructs an empty list. */ public LinkedList() &#123; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#39;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 两个构造方法也很简单，可以看出是一个无界的队列。 添加元素作为一个双端队列，添加元素主要有两种，一种是在队列尾部添加元素，一种是在队列首部添加元素，这两种形式在LinkedList中主要是通过下面两个方法来实现的。 /** * Links e as first element. * 从队列首添加元素 */ private void linkFirst(E e) &#123; // 首节点 final Node&lt;E&gt; f = first; // 创建新节点，新节点的next是首节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 让新节点作为新的首节点 first = newNode; // 判断是不是第一个添加的元素，如果是就把last也置为新节点，否则把原首节点的prev指针置为新节点 if (f == null) last = newNode; else f.prev = newNode; // 元素个数加1 size++; // 修改次数加1，说明这是一个支持fail-fast的集合 modCount++; &#125; /** * Links e as last element. * 从队列尾添加元素 */ void linkLast(E e) &#123; // 队列尾节点 final Node&lt;E&gt; l = last; // 创建新节点，新节点的prev是尾节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 让新节点成为新的尾节点 last = newNode; // 判断是不是第一个添加的元素，如果是就把first也置为新节点，否则把原尾节点的next指针置为新节点 if (l == null) first = newNode; else l.next = newNode; // 元素个数加1 size++; // 修改次数加1 modCount++; &#125; /** * Inserts the specified element at the beginning of this list. * * @param e the element to add */ public void addFirst(E e) &#123; linkFirst(e); &#125; /** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;. * * @param e the element to add */ public void addLast(E e) &#123; linkLast(e); &#125; // Deque operations /** * Inserts the specified element at the front of this list. * 作为无界队列，添加元素总是会成功的 * * @param e the element to insert * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerFirst&#125;) * @since 1.6 */ public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; /** * Inserts the specified element at the end of this list. * * @param e the element to insert * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerLast&#125;) * @since 1.6 */ public boolean offerLast(E e) &#123; addLast(e); return true; &#125; 典型的双链表在首尾添加元素的方法了。 上面是作为双端队列来看，它的添加元素分为首尾添加元素，那么，作为List呢？ 作为List，是要支持在中间添加元素的，主要是通过下面这个方法实现的。 /** * Inserts element e before non-null Node succ. * 在节点succ之前添加元素 */ void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // succ是待添加节点的后继节点 ， 找到待添加节点的前置节点 final Node&lt;E&gt; pred = succ.prev; // 在其前置节点和后继节点之间创建一个新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 修改后继节点的前置指针指向新节点 succ.prev = newNode; // 判断前置节点是否为空，如果为空，说明是第一个添加的元素，修改first指针，否则修改前置节点的next为新节点 if (pred == null) first = newNode; else pred.next = newNode; // 修改元素个数 size++; // 修改次数加1 modCount++; &#125; /** * Returns the (non-null) Node at the specified element index. * 寻找index位置的节点 */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 因为是双链表，所以根据index是在前半段还是后半段决定从前遍历还是从后遍历 // 这样index在后半段的时候可以少遍历一半的元素 if (index &lt; (size &gt;&gt; 1)) &#123; // 如果是在前半段，就从前遍历 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 如果是在后半段， 就从后遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * 在指定index位置处添加元素 * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; // 判断是否越界 checkPositionIndex(index); // 如果index是在队列尾节点之后的一个位置 // 把新节点直接添加到尾节点之后 // 否则调用linkBefore()方法在中间添加节点 if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125; 在中间添加元素的方法，典型的双链表在中间添加元素的方法。 添加元素的三种方式大致如下图所示： 在队列首尾添加元素很高效，时间复杂度为O(1)。 在中间添加元素比较低效，首先要先找到插入位置的节点，再修改前后节点的指针，时间复杂度为O(n)。 删除元素作为双端队列，删除元素也有两种方式，一种是队列首删除元素，一种是队列尾删除元素。 作为List，又要支持中间删除元素，所以删除元素一个有三个方法，分别如下： /** * Unlinks non-null first node f. * 删除首节点 */ private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; // 首节点的元素值 final E element = f.item; // 首节点的next指针 final Node&lt;E&gt; next = f.next; // 添加首节点的内容，协助GC f.item = null; f.next = null; // help GC // 把首节点的next作为新的首节点 first = next; // 如果只有一个元素，删除了，把last也置为空，否则把next的前置指针置为空 if (next == null) last = null; else next.prev = null; // 元素个数减1 size--; // 修改次数加1 modCount++; // 返回删除的元素 return element; &#125; /** * Unlinks non-null last node l. * // 删除尾节点 */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; // 尾节点的元素值 final E element = l.item; // 尾节点的前置指针 final Node&lt;E&gt; prev = l.prev; // 清空尾节点的内容，协助GC l.item = null; l.prev = null; // help GC // 让前置节点成为新的尾节点 last = prev; // 如果只有一个元素，删除了把first置为空 // 否则把前置节点的next置为空 if (prev == null) first = null; else prev.next = null; // 元素个数减1 size--; // 修改次数加1 modCount++; // 返回删除的元素 return element; &#125; /** * Unlinks non-null node x. * 删除指定节点x */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; // x的元素值 final E element = x.item; // x的前置节点 final Node&lt;E&gt; next = x.next; // x的后置节点 final Node&lt;E&gt; prev = x.prev; // 如果前置节点为空，说明是首节点，让first指向x的后置节点，否则修改前置节点的next为x的后置节点 if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; // 如果后置节点为空，说明是尾节点，让last指向x的前置节点， 否则修改后置节点的prev为x的前置节点 if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; // 清空x的元素值，协助GC x.item = null; // 元素个数减1 size--; // 修改次数加1 modCount++; // 返回删除的元素 return element; &#125; /** * Removes and returns the first element from this list. * remove的时候如果没有元素抛出异常 * * @return the first element from this list * @throws NoSuchElementException if this list is empty */ public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125; /** * Removes and returns the last element from this list. * remove的时候如果没有元素抛出异常 * * @return the last element from this list * @throws NoSuchElementException if this list is empty */ public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; /** * Retrieves and removes the first element of this list, * or returns &#123;@code null&#125; if this list is empty. * poll的时候如果没有元素返回null * * @return the first element of this list, or &#123;@code null&#125; if * this list is empty * @since 1.6 */ public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; /** * Retrieves and removes the last element of this list, * or returns &#123;@code null&#125; if this list is empty. * poll的时候如果没有元素返回null * * @return the last element of this list, or &#123;@code null&#125; if * this list is empty * @since 1.6 */ public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); &#125; /** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * 删除中间节点 * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; // 检查是否越界 checkElementIndex(index); // 删除指定index位置的节点 return unlink(node(index)); &#125; 删除元素的三种方法都是典型的双链表删除元素的方法，大致流程如下图所示: 在队列首尾删除元素很高效，时间复杂度为O(1)。 在中间删除元素比较低效，首先要找到删除位置的节点，再修改前后指针，时间复杂度为O(n)。 栈LinkedList是双端队列，双端队列可以作为栈使用： /** * Pushes an element onto the stack represented by this list. In other * words, inserts the element at the front of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addFirst&#125;. * * @param e the element to push * @since 1.6 */ public void push(E e) &#123; addFirst(e); &#125; /** * Pops an element from the stack represented by this list. In other * words, removes and returns the first element of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #removeFirst()&#125;. * * @return the element at the front of this list (which is the top * of the stack represented by this list) * @throws NoSuchElementException if this list is empty * @since 1.6 */ public E pop() &#123; return removeFirst(); &#125; 栈的特性是LIFO(Last In First Out)，所以作为栈使用也很简单，添加删除元素都只操作队列首节点即可 总结（1）LinkedList是一个以双链表实现的List； （2）LinkedList还是一个双端队列，具有队列、双端队列、栈的特性； （3）LinkedList在队列首尾添加、删除元素非常高效，时间复杂度为O(1)； （4）LinkedList在中间添加、删除元素比较低效，时间复杂度为O(n)； （5）LinkedList不支持随机访问，所以访问非队列首尾的元素比较低效； （6）LinkedList在功能上等于ArrayList + ArrayDeque；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
        <tag>Collection</tag>
        <tag>源码分析</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3安装opencv爬坑步骤]]></title>
    <url>%2Fposts%2F2018-12-04-python_opencv%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;python3安装opencv，但是导入失败？ &emsp;&emsp;各种尝试安装opencv,但是导入都是失败，这是什么问题呢？ &emsp;&emsp;以前总是这样安装：pip3 install opencv-python，安装是成功了，可是导入的时候总是报错，没找到cv2的包，这里，再安装一个opencv-contrib-python模块。 &emsp;&emsp;试试 pip3 install opencv-contrib-python &emsp;&emsp;这时候，如果导入cv2还报错，请按照如下错误解决问题： &emsp;&emsp;（1）ImportError: libjasper.so.1: cannot open shared object file: No such file or directory &emsp;&emsp;请安装 apt install libjasper-dev &emsp;&emsp;（2）ImportError: libQtGui.so.4: cannot open shared object file: No such file or directory &emsp;&emsp;请安装 apt install libqtgui4 &emsp;&emsp;（3）ImportError: libQtTest.so.4: cannot open shared object file: No such file or directory &emsp;&emsp;请安装 apt install libqt4-test &emsp;&emsp;这些问题，看着不难，但是从遇到到解决，还是花了不少时间。总结下，还是直接一次安装完比较好，这里提供一份完整爬坑指南： &emsp;&emsp;pip3 install opencv-contrib-python &emsp;&emsp;apt install libjasper-dev libqtgui4 libqt4-test libhdf5-dev libatlas-base-dev &emsp;&emsp;apt update &emsp;&emsp;相信到了这里，应该能搞定了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 源码分析]]></title>
    <url>%2Fposts%2F2019-01-01-ArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList是一种以数组实现的List，与数组相比，它具有动态扩展的能力，因此也可称之为动态数组。 简介ArrayList是一种以数组实现的List，与数组相比，它具有动态扩展的能力，因此也可称之为动态数组。 继承体系 ArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。 ArrayList实现了List，提供了基础的添加、删除、遍历等操作。 ArrayList实现了RandomAccess，提供了随机访问的能力。 ArrayList实现了Cloneable，可以被克隆。 ArrayList实现了Serializable，可以被序列化。 源码解析属性/** * Default initial capacity. * 默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. * 空数组，如果传入的容量是0时使用 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * 空数组，传入容量时使用，添加第一个元素的时候会重新初始化为默认容量大小 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * 存储元素的数值 */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * 集合中元素的个数 * @serial */ private int size; DEFAULT_CAPACITY 默认容量为10，也就是通过new ArrayList()创建时的默认容量。 EMPTY_ELEMENTDATA 空的数组，这种是通过new ArrayList(0)创建时用的是这个空数组。 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 也是空数组，这种是通过new ArrayList()创建时用的是这个空数组，与EMPTY_ELEMENTDATA的区别是在添加第一个元素时使用这个空数组的会初始化为DEFAULT_CAPACITY（10）个元素。 elementData 真正存放元素的地方，使用transient是为了不序列化这个字段。 至于没有使用private修饰，后面注释是写的“为了简化嵌套类的访问”，但是实测加了private嵌套类一样可以访问（?）。 private表示是类私有的属性，只要是在这个类内部都可以访问，嵌套类或者内部类也是在类的内部，所以也可以访问类的私有成员。 size 真正存储元素的个数，而不是elementData数组的长度。 ArrayList(int initialCapacity)构造方法传入初始容量，如果大于0就初始化elementData为对应大小，如果等于0就使用EMPTY_ELEMENTDATA空数组，如果小于0抛出异常。 /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 如果传入的初始容量大于0，就新建一个数组存储元素 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 如果传入的初始容量等于0，使用空数组EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 如果传入的初始容量小于0，抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity); &#125; &#125; ArrayList()构造方法不传初始容量，初始化为DEFAULTCAPACITY_EMPTY_ELEMENTDATA空数组，会在添加第一个元素的时候扩容为默认的大小，即10。 /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; // 如果没有传入初始容量，则使用空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA // 使用这个数组是在添加第一个元素的时候会扩容到默认大小10 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; ArrayList 构造方法传入集合并初始化elementData，这里会使用拷贝把传入集合的元素拷贝到elementData数组中，如果元素个数为0，则初始化为EMPTY_ELEMENTDATA空数组。 /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#39;s * iterator. * * 把传入集合的元素初始化到ArrayList中 * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 集合转数组 elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) // 检查c.toArray()返回的是不是Object[]类型，如果不是，重新拷贝成Object[].class类型 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. // 如果c的空集合，则初始化为空数组EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 为什么c.toArray();返回的有可能不是Object[]类型呢？ add(E e)方法添加元素到末尾，平均时间复杂度为O(1)。 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; // 检查是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 把元素插入到最后一位 elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; // 如果是空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，就初始化为默认大小10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code // 扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新容量为旧容量的1.5倍 【右移运算 除以2的n次方】 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果新容量发现比需要的容量还小，则以需要的容量为准 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量已经超过最大容量了，则使用最大容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 以新容量拷贝出来一个新数组 elementData = Arrays.copyOf(elementData, newCapacity); &#125; （1）检查是否需要扩容； （2）如果elementData等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA则初始化容量大小为DEFAULT_CAPACITY； （3）新容量是老容量的1.5倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果加了这么多容量发现比需要的容量还小，则以需要的容量为准； （4）创建新容量的数组并把老数组拷贝到新数组； add(int index, E element)方法添加元素到指定位置，平均时间复杂度为O(n)。 /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; // 检查是否越界 rangeCheckForAdd(index); // 检查是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将inex及其之后的元素往后挪一位，则index位置处就空出来了 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将元素插入到index的位置 elementData[index] = element; // 大小增1 size++; &#125; /** * A version of rangeCheck used by add and addAll. */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; （1）检查索引是否越界； （2）检查是否需要扩容； （3）把插入索引位置后的元素都往后挪一位； （4）在插入索引位置放置插入的元素； （5）大小加1； addAll 方法求两个集合的并集。 /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection&#39;s Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * 将集合c中所有元素添加到当前ArrayList中 * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 将集合c转为数组 Object[] a = c.toArray(); int numNew = a.length; // 检查是否需要扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 将c中元素全部拷贝到数组的最后 System.arraycopy(a, 0, elementData, size, numNew); // 大小增加c的大小 size += numNew; // 如果c不为空就返回true，否则返回false return numNew != 0; &#125; （1）拷贝c中的元素到数组a中； （2）检查是否需要扩容； （3）把数组a中的元素拷贝到elementData的尾部； get(int index)方法获取指定索引位置的元素，时间复杂度为O(1)。 /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; // 检查是否越界 rangeCheck(index); // 返回数组index位置的元素 return elementData(index); &#125; /** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; @SuppressWarnings(&quot;unchecked&quot;) E elementData(int index) &#123; return (E) elementData[index]; &#125; （1）检查索引是否越界，这里只检查是否越上界，如果越上界抛出IndexOutOfBoundsException异常，如果越下界抛出的是ArrayIndexOutOfBoundsException异常。 （2）返回索引位置处的元素； remove(int index)方法删除指定索引位置的元素，时间复杂度为O(n)。 /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; // 检查是否越界 rangeCheck(index); modCount++; // 获取index位置的元素 E oldValue = elementData(index); // 如果index不是最后一位，则将index之后的元素往前挪一位 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素删除，帮助GC elementData[--size] = null; // clear to let GC do its work // 返回旧值 return oldValue; &#125; （1）检查索引是否越界； （2）获取指定索引位置的元素； （3）如果删除的不是最后一位，则其它元素往前移一位； （4）将最后一位置为null，方便GC回收； （5）返回删除的元素。 可以看到，ArrayList删除元素的时候并没有缩容。 remove(Object o)方法删除指定元素值的元素，时间复杂度为O(n)。 /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; // 遍历整个数组，找到元素第一次出现的位置，并将其快速删除 for (int index = 0; index &lt; size; index++) // 如果要删除的元素为null，则以null进行比较，使用== if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; // 遍历整个数组，找到元素第一次出现的位置，并将其快速删除 for (int index = 0; index &lt; size; index++) // 如果要删除的元素不为null，则进行比较，使用equals()方法 if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; // 这里没有越界的检查，是不是少了？？？ modCount++; // 如果index不是最后一位，则将index之后的元素往前挪一位 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素删除，帮助GC elementData[--size] = null; // clear to let GC do its work &#125; （1）找到第一个等于指定元素值的元素； （2）快速删除； fastRemove(int index)相对于remove(int index)少了检查索引越界的操作，可见jdk将性能优化到极致。 retainAll方法求两个集合的交集。 /** * Retains only the elements in this list that are contained in the * specified collection. In other words, removes from this list all * of its elements that are not contained in the specified collection. * * @param c collection containing elements to be retained in this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) &#123; // 集合c不能为null Objects.requireNonNull(c); // 调用批量删除方法，这时complement传入true，表示删除不包含在c中的元素 return batchRemove(c, true); &#125; /** * 批量删除元素 * complement为true表示删除c中不包含的元素 * complement为false表示删除c中包含的元素 */ private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // 使用读写两个指针同时遍历数组 // 读指针每次自增1，写指针放入元素的时候才加1 // 这样不需要额外的空间，只需要在原有的数组上操作就可以了 int r = 0, w = 0; boolean modified = false; try &#123; // 遍历整个数组，如果c中包含该元素，则把该元素放到写指针的位置（以complement为准） for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. // 正常来说r最后是等于size的，除非c.contains()抛出了异常 if (r != size) &#123; // 如果c.contains()抛出了异常，则把未读的元素都拷贝到写指针之后 System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work // 将写指针之后的元素置为空，帮助GC for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; // 新大小等于写指针的位置（因为每写一次写指针就加1，所以新大小正好等于写指针的位置） size = w; modified = true; &#125; &#125; // 有修改返回true return modified; &#125; （1）遍历elementData数组； （2）如果元素在c中，则把这个元素添加到elementData数组的w位置并将w位置往后移一位； （3）遍历完之后，w之前的元素都是两者共有的，w之后（包含）的元素不是两者共有的； （4）将w之后（包含）的元素置为null，方便GC回收； removeAll求两个集合的单方向差集，只保留当前集合中不在c中的元素，不保留在c中不在当前集体中的元素。 /** * Removes from this list all of its elements that are contained in the * specified collection. * * @param c collection containing elements to be removed from this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) &#123; // 集合c不能为空 Objects.requireNonNull(c); // 同样调用批量删除方法，这时complement传入false，表示删除包含在c中的元素 return batchRemove(c, false); &#125; 与retainAll(Collection&lt;?&gt; c)方法类似，只是这里保留的是不在c中的元素。 总结（1）ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容； （2）ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)； （3）ArrayList添加元素到尾部极快，平均时间复杂度为O(1)； （4）ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)； （5）ArrayList从尾部删除元素极快，时间复杂度为O(1)； （6）ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)； （7）ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可； （8）ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可； （9）ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可； 思考elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？ /** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff // 防止序列化期间有修改 int expectedModCount = modCount; // 写出非transient非static属性（会写出size属性） s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() // 写出元素个数 s.writeInt(size); // Write out all elements in the proper order. // 依次写出元素 for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; // 如果有修改，抛出异常 if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // 声明为空数组 elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff // 读入非transient非static属性（会读取size属性） s.defaultReadObject(); // Read in capacity // 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读 s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity // 计算容量 int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); // 检查是否需要扩容 ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. // 依次读取元素到数组中 for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。 一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。 在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。 elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
        <tag>ArrayList</tag>
        <tag>Collection</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内主流视频网站VIP视频解析接口]]></title>
    <url>%2Fposts%2F2018-11-02-vipjiexi%2F</url>
    <content type="text"><![CDATA[为什么使用需要这些视频解析接口？ 首先没有广告，最重要的是支持VIP等需要会员才能观看的视频。 使用方法： 将需要播放VIP视频的网址复制到上述任一接口后面，在浏览器打开即可。 注意：如果接口失效，请联系我或者留言，我会及时更新！ 2019年01月02日更新：http://api.smq1.com/?url= https://api.smq1.com/?url= https://jx.hezeshi.net/ce/jlexi.php?url= http://api.hellosex.cc/jlexi.php?url= https://api.pangujiexi.com/player.php?url= http://at520.cn/jx/?url=http://www.cmys.tv/?url= https://jx.km58.top/jx/?url= http://www.fantee.net/fantee/?url= http://api.51ckm.com/Box.php?url= https://www.3aym.cn/?url= http://beaacc.com/api.php?url= http://api.zuilingxian.com/jiexi.php?url= http://jx.2tv.org/?url= http://api.bbbbbb.me/ipsign/player.php?v= http://17kyun.com/api.php?url= 2018年12月06日更新：https://jx.hezeshi.net/ce/jlexi.php?url= http://api.hellosex.cc/jlexi.php?url= https://api.pangujiexi.com/player.php?url= http://at520.cn/jx/?url= http://player.jidiaose.com/supapi/iframe.php?v= https://jx.okokjx.com/okok/?url= http://api.jykkk.com/?url= https://jx.km58.top/jx/?url= http://jx.fantee.net/fantee/?url= http://api.51ckm.com/Box.php?url= http://www.1717yun.com/jx/ty.php?url= https://www.3aym.cn/?url= http://beaacc.com/api.php?url= http://api.zuilingxian.com/jiexi.php?url= http://jx.2tv.org/?url= http://cdn.yangju.vip/k/?url= http://api.bbbbbb.me/ipsign/player.php?v= http://17kyun.com/api.php?url= 2018年08月10日更新：http://www.iwkan.cn/jx2/?url= http://api.ledboke.com/?url= http://ckparse.kaizhoukm.com/play/vippcq.php?url= http://jqaaa.com/jx.php?url= http://api.47ks.com/webcloud/?v= http://api.xfsub.com/index.php?url= http://jx.du2.cc/jx6.php?url= http://jx.du2.cc/?url= 2018年07月08日更新：http://lykezhan.com/vip/ http://yy.zhiliaotang.com/vip/ http://www.5ifxw.com/vip/ http://www.qmaile.com http://tv.myhack58.com http://www.51onb.com/filmvip/ 2018年06月27日更新：https://api.pangujiexi.com/player.php?url= http://api.ledboke.com/vip/?url= http://vip.qike.ink/?url= http://jx.598110.com/index.php?url= http://player.jidiaose.com/supapi/iframe.php?v= http://api.91exp.com/svip/?url= http://v.72du.com/api/?url= http://api.bbbbbb.me/ipsign/player.php?v= http://17kyun.com/api.php?url= 2018年05月02日更新：http://www.662820.com/xnflv/index.php?url= http://api.lldyy.net/svip/?url= http://www.82190555.com/index/qqvod.php?url= http://jiexi.92fz.cn/player/vip.php?url= http://jiexi.071811.cc/jx2.php?url= http://api.wlzhan.com/sudu/?url= http://beaacc.com/api.php?url= http://qxkkk.bid/jx/jx.php?url= http://www.27v9.cn/index.php?url= http://www.ckplayer.tv/kuku/?url= http://o8ve.cn/1/?url= http://api.xyingyu.com/?url= https://jx.kt111.top/jx/mf/?url= https://api.pangujiexi.com/player.php?url= http://api.lvcha2017.cn/?url= http://kkk.2016ve.cn/kkjx/index.php?url= http://mlxztz.com/vip/?url= http://www.aktv.men/?url= http://jy777.cn/XSD/XSD/?url= http://api.visaok.net/?url= http://api.xyingyu.com/?url= http://api.greatchina56.com/?url= http://jx.618g.com/?url= http://api.baiyug.vip/index.php?url= http://jx.jfysz.cn/jx.php/?url= http://jx.ektao.cn/jx.php/?url= http://jx.reclose.cn/jx.php/?url= http://jx.eayn.org.cn/jx.php/?url= http://api.xyingyu.com/?url= http://jx.iaeec.cn/jx.php/?url= http://jx.83y4n7a.cn/jx.php/?url= http://jx.cmbzzs.cn/jx.php/?url= http://api.greatchina56.com/?url= http://jx.as19811.cn/jx.php/?url= http://jx.sdjnd09.cn/jx.php/?url= http://api.baiyug.vip/index.php?url= http://jx.09876as.cn/jx.php/?url= http://jx.17ktv.com.cn/jx.php/?url= http://jx.ab78a.cn/jx.php/?url= http://jx.09877as.cn/jx.php/?url= http://jx.yipolo111.cn/jx.php/?url= http://jx.908astbb.cn/jx.php/?url= http://jx.dlzyrk001.cn/jx.php/?url= http://jx.dccmy.org.cn/jx.php/?url= http://jx.boctx.cn/jx.php/?url= http://jx.hxbte.cn/jx.php/?url= http://api.visaok.net/?url= http://jx.618g.com/?url= http://yun.baiyug.cn/vip/?url= http://api.baiyug.cn/vip/?url= https://api.flvsp.com/?url= http://api.xfsub.com/index.php?url= http://api.xfsub.com/index.php?url= http://jiexi.071811.cc/jx2.php?url= http://player.jidiaose.com/supapi/iframe.php?v= http://www.82190555.com/index/qqvod.php?url= http://api.pucms.com/?url= http://api.baiyug.cn/vip/index.php?url= https://api.flvsp.com/?url= http://www.82190555.com/index/qqvod.php?url= http://2gty.com/apiurl/yun.php?url= http://v.2gty.com/apiurl/yun.php?url= 2018年04月17日更新：http://api.visaok.net/?url= http://api.xyingyu.com/?url= http://api.greatchina56.com/?url= http://jx.618g.com/?url= http://api.xyingyu.com/?url= http://api.greatchina56.com/?url= http://api.visaok.net/?url= http://jx.618g.com/?url= http://zuiai.ml/dh/jx/ajx.php?url= http://zuiai.ml/dh/jx/jx.php?url= http://zuiai.ml/dh/jx/jiexi.php?url= 2018年03月22日更新：无广告 http://player.jidiaose.com/supapi/iframe.php?v= 爱奇艺推荐(无广告) http://api.xfsub.com/index.php?url= 爱奇艺、优酷推荐 https://jx.okokjx.com/okokjx/?url= 万能接口1 http://api.47ks.com/webcloud/?v= 万能接口2 http://wwwhe1.177kdy.cn/4.php?pass=2&amp;url= 万能接口3 https://api.daidaitv.com/index/?url= 万能接口4 http://jx.aeidu.cn/index.php?url= 爱奇艺接口1 http://api.baiyug.cn/vip/?url= 爱奇艺接口2 http://api.baiyug.cn/vip/index.php?url= 腾讯视频接口1 http://www.82190555.com/index/qqvod.php?url= 2018年01月22日更新：http://17kyun.com/api.php?url= http://jx.biaoge.tv/index.php?url= http://www.85105052.com/admin.php?url= http://api.iy11.cn/apiget.php?url= http://api.baiyug.cn/vip/index.php?url= http://jx.hanximeng.com/m3u8.php?url= http://jx.39book.com/Client/apiget.php?url= http://014670.cn/jx/ty.php?url= http://www.ibb6.com/x1/?url= http://tv.x-99.cn/api/wnapi.php?id= http://www.52rjb.cn/vip1/?url= http://www.52rjb.cn/vip2/?url= http://www.52rjb.cn/vip3/?url= http://49.4.144.33/xfjx/1.php?url= http://7cyd.com/vip/?url= https://47ksvip.duapp.com/vip/2mm/?vid= 2016年12月06日更新：http://www.vipjiexi.com/yun.php?url= http://www.wmxz.wang/video.php?url= http://www.yydy8.com/common/?url= http://www.wmxz.wang/video.php?url= http://5qiyi.sdyhy.cn/5qiyi/5qiyi1.php?url= http://5qiyi.sdyhy.cn/5qiyi/5qiyi2.php?url= http://vip.sdyhy.cn/ckflv/?url= http://player.gakui.top/?url= http://mt2t.com/yun?url= http://qtzr.net/s/?qt= http://www.xiguaso.com/api/index.php?url= http://www.vipjiexi.com/yun.php?url=]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>vip</tag>
        <tag>video</tag>
        <tag>视频解析</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Nginx以及uwsgi 的 Django 环境搭建]]></title>
    <url>%2Fposts%2F2018-04-12-django_centos_setup%2F</url>
    <content type="text"><![CDATA[基于Nginx以及uwsgi环境下，Django环境搭建，记录下来 !!! 安装 Django先安装pip,再通过pip安装Django。 1.安装pip cd /data; mkdir tmp; cd tmp; wget https://bootstrap.pypa.io/get-pip.py; python ./get-pip.py; 2.使用 PIP，安装 Django pip install Django==1.11.7 安装 Mysql1.安装并启动 mariadb 因为 CentOS 7 之后的版本都不在提供 Mysql 安装源，这里我们使用 mariadb 代替 mysql，依次执行下列命令 yum install mariadb mariadb-server -y yum install MySQL-python -y systemctl start mariadb 2.对 mariadb 进行初始化设置 执行下面命令，根据提示操作 设置新密码为 test 默认密码为空，直接回车即可 mysql_secure_installation 3.使用设置的密码登陆 mariadb 登陆 db，这里假设密码被设置为 test mysql -uroot -ptest 4.创建一个数据库 create database mysite; 5.成功后，输入 exit 命令退出 db exit 创建 Django 项目1.创建 mysite 项目 在 /data/ 目录下，创建一个名为 mysite 的 Django 项目 cd /data/ django-admin startproject mysite 2.修改配置文件，与 Mysql 数据库相关联 备注：SECRET_KEY 配置项无需修改 编辑 /data/mysite/mysite/settings.py 示例代码：/data/mysite/mysite/settings.py """ Django settings for mysite project. Generated by 'django-admin startproject' using Django 1.11.7. For more information on this file, see https://docs.djangoproject.com/en/1.11/topics/settings/ For the full list of settings and their values, see https://docs.djangoproject.com/en/1.11/ref/settings/ """ import os # Build paths inside the project like this: os.path.join(BASE_DIR, ...) BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # Quick-start development settings - unsuitable for production # See https://docs.djangoproject.com/en/1.11/howto/deployment/checklist/ # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = 'm4@g1=hz^08y(9d)v5l!8^*0wbla=oe15s@u8@5^pw=llfz48%' # SECURITY WARNING: don't run with debug turned on in production! DEBUG = True ALLOWED_HOSTS = ["*"] # Application definition INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] ROOT_URLCONF = 'mysite.urls' TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] WSGI_APPLICATION = 'mysite.wsgi.application' # Database # https://docs.djangoproject.com/en/1.11/ref/settings/#databases DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mysite', 'PASSWORD':'test', 'USER': 'root', 'HOST':'127.0.0.1', 'PORT':'3306', } } # Password validation # https://docs.djangoproject.com/en/1.11/ref/settings/#auth-password-validators AUTH_PASSWORD_VALIDATORS = [ { 'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', }, { 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', }, { 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', }, { 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', }, ] # Internationalization # https://docs.djangoproject.com/en/1.11/topics/i18n/ LANGUAGE_CODE = 'en-us' TIME_ZONE = 'UTC' USE_I18N = True USE_L10N = True USE_TZ = True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/1.11/howto/static-files/ STATIC_URL = '/static/' 3.创建 Django 数据库 cd /data/mysite python manage.py migrate 4.启动 Django python manage.py runserver 如果没有报错，就说明 Django 已经安装成功了，并且跟 Mysql 的连接正常 5.退出 Django 按 ctrl+c 退出 Django 服务 安装 Nginx1.通过 yum 安装 Nginx yum install nginx -y 2.启动 Nginx 服务 systemctl start nginx 访问你的服务器IP，可以看到 nginx 的欢迎界面 http://&lt;您的 server IP 地址&gt;/ 安装 uwsgi使用 yum 命令安装 uwsgi yum install uwsgi uwsgi-plugin-python -y 让 Nginx，uwsgi，Django 协同工作[精华部分]1.修改 Nginx 配置文件 编辑 /etc/nginx/nginx.conf # For more information on configuration, see: # * Official English Documentation: http://nginx.org/en/docs/ # * Official Russian Documentation: http://nginx.org/ru/docs/ user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; # Load dynamic modules. See /usr/share/nginx/README.dynamic. include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8000; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } # Settings for a TLS enabled server. # # server { # listen 443 ssl http2 default_server; # listen [::]:443 ssl http2 default_server; # server_name _; # root /usr/share/nginx/html; # # ssl_certificate "/etc/pki/nginx/server.crt"; # ssl_certificate_key "/etc/pki/nginx/private/server.key"; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 10m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # # # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # # location / { # } # # error_page 404 /404.html; # location = /40x.html { # } # # error_page 500 502 503 504 /50x.html; # location = /50x.html { # } # } } 2.重启 Nginx /usr/sbin/nginx -s reload 3.创建 uwsgi 配置文件 在 /data/mysite 目录下创建 uwsgi.ini，参考下面的内容 示例代码：/data/mysite/uwsgi.ini [uwsgi] socket = 127.0.0.1:8000 chdir = /data/mysite wsgi-file = mysite/wsgi.py processes = 4 threads = 2 stats = 127.0.0.1:9191 uid = nobody gid = nobody master = true harakiri = 30 daemonize = /data/mysite/uwsgi.log plugins = python 4.启动 uwsgi uwsgi uwsgi.ini 搭建完成访问链接 http://&lt;您的 server IP 地址&gt;/ 如果可以看到 Django 的界面，恭喜你，环境搭建成功]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[180G喜马拉雅收费音频大合集]]></title>
    <url>%2Fposts%2F2018-04-10-ximalaya%2F</url>
    <content type="text"><![CDATA[所有链接密码都是6666，无任何解压密码，价值不清楚，选你喜欢的来存。 主要网站 No. 网站 链接 1 传统国学(14套) https://pan.baidu.com/s/12O8lYNrV9c2ixraP7_gY6A 2 健康养生 https://pan.baidu.com/s/136CBDpo1cxc4MJzeHyEMCA 3 金融财经 https://pan.baidu.com/s/1w5Mc4EHbP2ZNVsRpdV60uw 4 亲子育儿 https://pan.baidu.com/s/19jTHFqw0tIMO9yzwkLaP6w 5 外语语言 https://pan.baidu.com/s/1bNAxiNgrrXbe-jdZALIUEA 6 职场管理 https://pan.baidu.com/s/10VLPuVf21Y6-HwY0igHKXg 7 情感心理 https://pan.baidu.com/s/1OqFm40915-QV-9SOZSme0A 8 演讲语言 https://pan.baidu.com/s/1-wUFDqetIWWgdK9v_FnnaA 9 诗歌小说 https://pan.baidu.com/s/1ERmupi5LCiZP20eRGeMpDg 10 烧脑记忆 https://pan.baidu.com/s/1QFaQxQGpsQBL2YGy-2VvwA 密码：mkpt 11 文学艺术 https://pan.baidu.com/s/1eDZJDfgeAT4Y-Zjoo3rC_A 12 女神养成 https://pan.baidu.com/s/15X0sCMqMIRY_T9cvl0koBg 13 音乐艺术 https://pan.baidu.com/s/1Z8yugUin03MWH7xD1Is4-g 14 中学课程 https://pan.baidu.com/s/1SGnwi48txASVFht9Enwq5g 15 读书类 https://pan.baidu.com/s/1e1oM7o3Mbd4Oj8jBvU3gdw 16 人文社会 https://pan.baidu.com/s/1heGyEioXxTa6tEGItBC3Eg 17 个人素质 https://pan.baidu.com/s/1-VC0fcZchgq4LR6VtLHBZg 18 其他类 https://pan.baidu.com/s/1C-eNzhCujO0QfT35P4U4yA 19 新增栏目尚未分类 https://pan.baidu.com/s/1-uIgEDUEFt-WKYgacxZBhQ]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>喜马拉雅FM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你敢信?Java10发布了！！！]]></title>
    <url>%2Fposts%2F2018-03-21-java10%2F</url>
    <content type="text"><![CDATA[没有跳票的Java10，正式发布！ 不知是不是OUT了，Java9还没在生产环境中使用过，Java10就发布了。 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html 为了更快地迭代更新，以及跟进社区反馈，Java 的版本发布周期变更为每六个月一次，并且承诺不会跳票。 新的发布周期也会严格遵循时间点，将在每年的 3 月份和 9 月份发布，所以 Java 10 的版本号是 18.3。 （貌似有点像Ubuntu的发布周期的模式） Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性。 JDK10 包含 12 个JEP (改善提议）：1.【286】局部变量类型推断：对于开发者来说，这是JDK10唯一的真正特性。 它向Java中引入在其他语言中很常见的 var ，比如JavaScript。只要编译器可以推断此种类型，你不再需要专门声明一个局部变量的类型。 一个简单的例子是： var x = new ArrayList(); 这就消除了之前必须执行的 ArrayList 类型定义的重复。 有趣的是，需要注意 var 不能成为一个关键字，而是一个保留字。这意味着你仍然可以使用 var 作为一个变量，方法或包名，但是现在不能再有一个类被调用。 2.[310]应用类数据共享(CDS) ：CDS 在JDK5时被引进以改善 JVM 启动的表现，同时减少当多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。 JDK10 将扩展 CDS 到允许内部系统的类加载器、内部平台的类加载器和自定义类加载器来加载获得的类。 之前，CDS 的使用仅仅限制在了 bootstrap 的类加载器。 3.[314]额外的 Unicode 语言标签扩展：这将改善 java.util.Locale 类和相关的 API 以实现额外 BCP 47 语言标签的 Unicode 扩展。 尤其是，货币类型，一周的第一天，区域覆盖和时区等标签现在将被支持。 4.[322]基于时间的版本控制：JDK 版本字符串格式几乎与 JDK 版本一样多。有幸的是，这是最后需要使用到的，可以坚持用它。这种格式使用起来很像 JDK9 中介绍的提供一个更加语义的形式。 有一件困扰我的事是包含了一个 INTERIM 元素，正如 JEP 提议中所说，“永远是0”。好吧，如果永远是0，那它有什么意义呢？他们说这是为未来使用做保留… 这也消除了在 JDK9 中有过的相当奇怪的情形。 第一次更新是 JDK 9.0.1 , 非常符合逻辑。第二次更新是 JDK 9.0.4 ，不合逻辑。原因是，在 JDK9 的版本计数模式下，需要留下空白以便应急或不在预期安排的更新使用。但既然没有更新是必须的，为什么不简单称之为 JDK 9.0.2 呢？ 5.[319]根证书：在 JDK 中将提供一套默认的 CA 根证书。关键的安全部件，如 TLS ，在 OpenJDK 构建中将默认有效。这是 Oracle 正在努力确保 OpenJDK 二进制和 Oracle JDK 二进制功能上一样的工作的一部分，是一项有用的补充内容。 6.[307] 并行全垃圾回收器 G1 :G1 是设计来作为一种低延时的垃圾回收器（但是如果它跟不上旧的堆碎片产生的提升速率的话，将仍然采用完整压缩集合）。 在 JDK9 之前，默认的收集器是并行，吞吐，收集器。为了减少在使用默认的收集器的应用性能配置文件的差异，G1 现在有一个并行完整收集机制。 7.[313]移除 Native-Header 自动生成工具：Java9 开始了一些对 JDK 的家务管理，这项特性是对它的延续。当编译 JNI 代码时，已不再需要单独的工具来生成头文件，因为这可以通过 javac 完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还不清楚。 8.[304]垃圾回收器接口:这不是让开发者用来控制垃圾回收的接口；而是一个在 JVM 源代码中的允许另外的垃圾回收器快速方便的集成的接口。 9.[312]线程-局部变量管控：这是在 JVM 内部相当低级别的更改，现在将允许在不运行全局虚拟机安全点的情况下实现线程回调。这将使得停止单个线程变得可能和便宜，而不是只能启用或停止所有线程。 10.[316]在备用存储装置上的堆分配：硬件技术在持续进化，现在可以使用与传统 DRAM 具有相同接口和类似性能特点的非易失性 RAM 。这项 JEP 将使得 JVM 能够使用适用于不同类型的存储机制的堆。 11.[317]试验性的基于 Java 的 JIT 编译器：最近宣布的 Metropolis 项目，提议用 Java 重写大部分 JVM 。乍一想，觉得很奇怪。如果 JVM 是用 Java 编写的，那么是否需要一个 JVM 来运行 JVM ？ 相应的，这导致了一个很好的镜像类比。 现实情况是，使用 Java 编写 JVM 并不意味着必须将其编译为字节码，你可以使用 AOT 编译，然后在运行时编译代码以提高性能。 这项 JEP 将 Graal 编译器研究项目引入到 JDK 中,并给将 Metropolis 项目成为现实，使 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。 12.[296]合并 JDK 多个代码仓库到一个单独的储存库中：在 JDK9 中，有 8 个仓库： root、corba、hotspot、jaxp、jaxws、jdk、langtools 和 nashorn 。 在 JDK10 中这些将被合并为一个，使得跨相互依赖的变更集的存储库运行 atomic commit （原子提交）成为可能。 新 API有 73 项新增内容添加到了标准类库中。 1.java.awt.Toolkit int getMenuShortcutKeyMaskEx(): 确定哪个扩展修饰符键是菜单快捷键的适当加速键。 2.java.awt.geom.Path2D: void trimToSize(): 将此 Path2D 实例的容量计算到它当前的大小。应用可使用此操作将路径的存储空间最小化。这个方法也被添加到 Path2D.Double 和 Path2D.Float 类。 3.java.io.ByteArrayOutputStream: String toString(Charset): 重载 toString()，通过使用指定的字符集解码字节，将缓冲区的内容转换为字符串。 4.java.io.PrintStream: &amp;&amp; lang.io.PrintWriter: 这两个类都有三个新的构造函数，它们需要额外的 Charset 参数。 5.java.io.Reader: &amp;&amp; long transferTo(Writer): 从这个 Reader 中读取所有字符，并按照所读的顺序将字符写入给定的 Writer 。 6.java.lang.Runtime.Version: 有四种新方法返回新（JEP 322）版本字符串字段的整数值: feature()、interim()、patch() 和 update() 。 7.java.lang.StackWalker.StackFrame: String getDescriptor(): 按照 JVM 标准返回此堆栈帧所代表的方法的描述符。 String getMethodType():返回此堆栈帧所代表的方法类型，描述参数类型和返回值类型。 8.java.lang.invoke.MethodType: Class&lt;?&gt; lastParameterType():返回这个方法类型的最后一个参数类型。如果这个方法类型没有参数，则返回空类型作为岗哨值（Sentinel Value）。 9.java.lang.management.RuntimeMXBean: long getPid(): R 返回正在运行的 JVM 的进程 ID 。 10.java.lang.management.ThreadMXBean: ThreadInfo[] dumpAllThreads(boolean, boolean, int): 返回所有活动线程的线程信息，其中有指定的最大元素数量和同步信息的堆栈跟踪。 ThreadInfo[] getThreadInfo(long[], boolean, boolean, int): 返回每个线程的线程信息，这些线程的标识位于输入数组中，其中有指定的最大元素数量和同步信息的堆栈跟踪。 11.java.lang.reflect.MalformedParameterizedTypeException: 添加了一个新的构造函数，它以字符串的形式作为参数来获取详细信息。 12.java.net.URLDecoder: java.net.URLEncoder: 这两个类都有新的重载的解码和编码方法，将 charset 作为附加参数。 13.java.nio.channels.Channels: 两个新的静态重载方法，允许使用 Charset 的 newReader（ReadByteChannel，Charset）和newWriter（WriteByteChannel，Charset）。 14.java.nio.file.FileStore: long getBlockSize(): 在这个文件存储中返回每个块的字节数。 15.java.time.chrono: 这个包里有三个类，HijrahEra、MiinguoEra 和 ThaiBuddhistEra ，都有同样的方法。 String getDisplayName(TextStyle, Locale): 这将返回用于识别 era 的文本名称，适合于向用户展示。 16.java.time.format.DateTimeFormatter: localizedBy(Locale): 返回指定格式器的一个副本，其中包含地区、日历、区域、小数和/或时区的本地化值，这将取代该格式器中的值。 17.java.util: DoubleSummaryStatistics、IntSummaryStatistics 和 LongSummaryStatistics 都有一个新的构造函数，它包含 4 个数值。 它使用指定的计数、最小值、最大值和总和构造一个非空实例。 18.java.util.List: &amp;&amp; java.util.Map: &amp;&amp; java.util.Set: 这些接口中的每一个都增加了一个新的静态方法，copyOf(Collection）。这些函数按照其迭代顺序返回一个不可修改的列表、映射或包含给定集合的元素的集合。 19.java.util.Optional: &amp;&amp; java.util.OptionalDouble: &amp;&amp; java.util.OptionalInt: &amp;&amp; java.util.OptionalLong: 每一个类都有一个新的方法，orElseThrow() ，它本质上和 get() 一样，也就是说，如果 Optional 有值则返回。否则，将抛出 NoSuchElementException 。 20.java.util.Formatter: &amp;&amp; java.util.Scanner: 这两个类都有三个新的构造函数，除了其他参数之外，它们都带有一个 charset 参数。 21.java.util.Properties: 这有一个新的构造函数，它接受一个 int 参数。这将创建一个没有默认值的空属性列表，并且指定初始大小以容纳指定的元素数量，而无需动态调整大小。 还有一个新的重载的 replace 方法，接受三个 Object 参数并返回一个布尔值。只有在当前映射到指定值时，才会替换指定键的条目。 22.java.SplittableRandom: void nextBytes(byte[]): 用生成的伪随机字节填充一个用户提供的字节数组。 23.java.util.concurrent.FutureTask: 添加了 toString() 方法，该方法返回一个标识 FutureTask 的字符串，以及它的完成状态。 在括号中，状态包含如下字符串中的一个，“Completed Normally” 、“Completed Exceptionally”、 “Cancelled” 或者 “Not completed”。 24.java.util.concurrent.locks.StampedLock: boolean isLockStamp(long): 返回一个标记戳表示是否持有一个锁。 boolean isOptimisticReadStamp(long): 返回一个标记戳代表是否成功的进行了乐观读（optimistic read）。 boolean isReadLockStamp(long): 返回一个标记戳表示是否持有一个非独占锁（即 read lock ）。 boolean isWriteLockStamp(long): 返回一个标记戳表示是否持有一个独占锁（即 write lock ）。 25.java.jar.JarEntry: String getRealName(): 返回这个 JarEntry 的真实名称。如果这个 JarEntry 是一个多版本 jar 文件的入口，它被配置为这样处理，这个方法返回的名字是 JarEntry 所代表的版本条目的入口，而不是 ZipEntry.getName（） 返回的基本条目的路径名。 如果 JarEntry 不代表一个多版本 jar 文件的版本化条目或者 jar 文件没有被配置为作为一个多版本 jar 文件进行处理，这个方法将返回与 ZipEntry.getName（） 返回的相同名称。 26.java.util.jar.JarFile: Stream versionedStream(): 返回 jar 文件中指定版本的入口对应 Stream 。与 JarEntry 的 getRealName 方法类似，这与多版本 jar 文件有关。 27.java.util.spi.LocaleNameProvider: getDisplayUnicodeExtensionKey(String, Locale): 为给定的 Unicode 扩展键返回一个本地化名称。 getDisplayUnicodeExtensionType(String, String, Locale): 为给定的 Unicode 扩展键返回一个本地化名称。 28.java.util.stream.Collectors: toUnmodifiableList(): toUnmodifiableSet(): toUnmodifiableMap(Function, Function): toUnmodifiableMap(Function, Function, BinaryOperator): 这四个新方法都返回 Collectors ，将输入元素聚集到适当的不可修改的集合中。 29.java.lang.model.SourceVersion: 现在有了一个字段，它代表了 JDK 10 的版本。 30.java.lang.model.util.TypeKindVisitor6: javax.lang.model.util.TypeKindVisitor9: R visitNoTypeAsModule(NoType, P): 访问一个 MODULE 的 pseudo-type 。不确定为什么只有这两个类得到这个方法，因为还有 Visitor7 和 Visitor8 变量。 31.javax.remote.management.rmi.RMIConnectorServer: 这个类已经添加了两个字段： CREDENTIALS_FILTER_PATTERN 和 SERIAL_FILTER_PATTERN 。 32.javax.ButtonModel： Swing 还在更新！ ButtonGroup getGroup(): 返回按钮所属的组。通常用于单选按钮，它们在组中是互斥的。 33.javax.plaf.basic.BasicMenuUI: Dimension getMinimumSize(JComponent): 返回指定组件适合观感的最小大小。 JVM 规范改动这些改动相当小： 4.6节： 类文件格式（第99页）。在方法访问标志方面有小的改动。 4.7节： 模块属性（第169页）。如果模块不是 java.base ，则 JDK 10 不再允许设置 ACC_TRANSITIVE 或 ACC_STATIC_PHASE 。 4.10节： 类文件的校验（第252页）。dup2 指令已改变了 typesafe form 1 的定义，颠倒了 canSafleyPushList 一节中类型的顺序（你需要仔细查看才能发现它）。 5.2节： Java 虚拟机启动（第350页）。该描述添加了在创建初始类或接口时可使用用户定义的类加载器（ bootstrap 类加载器除外）。 对 Java 语言规范的更改这里还有一些更改，但主要是为了支持局部变量类型推断。 第3.8节： 标识符（第23页）。在忽略了可忽略的字符之后，标识符的等价性现在被考虑了。这似乎是合乎逻辑的。 （第24页）一个新的 Token，TypeIdentifier，它支持对局部变量类型推断的新用法，而 var 的使用不是关键字，而是一个具有特殊含义的标识符，作为局部变量声明的类型。 第4.10.5节： 类型预测（第76页）。这是一个相当复杂的部分，它涉及到捕获变量、嵌套类以及如何使用局部变量类型推断。建议阅读规范中的这一部分，而不是试图解释它。 第6.1节： 声明（第134页）。一个反映使用 TypeIdentifier 来支持局部变量类型的推断的小改动。 第6.5节： 确定名字的含义（第153页，第158页和第159页）。根据类型标识符的使用而更改类类型。 第6.5.4.1: 简单的 PackageOrTypeNames（第160页） 第6.5.4.2节： 合规的 PackageOrTypeNames（第160页）。这两种方式都与使用 TypeIdentifier 有细微的变化。 第7.5.3: 单静态导入声明（第191页）。这改变了导入具有相同名称的静态类型的规则。除非类型是相同的，否则这将成为一个错误，在这种情况下，重复被忽略。 第7.7.1: 依赖（第198页）。如果你明确声明一个模块需要 java.base ，那在必要的关键字之后，你就不能再使用修饰符（例如静态）了。 第8部分： 正式参数（第244页）。接收者参数可能只出现在一个实例方法的 formalparameters 列表，或者是一个内部类的构造函数中，其中内部类没有在静态上下文中声明。 第9.7.4节： 注释可能出现的地方（第335页）。有一个与局部变量类型推断相关的变更。 第14.4部分： 局部变量声明语句（第433页）。实现局部变量类型推断所需的大量更改。 第14节： 增强的 for 语句（第455页）。这个结构已经更新，包括对局部变量类型推断的支持。 第14.20.3节: try-with-resources（474页）。这个结构已经更新，包括对局部变量类型推断的支持。 最后，第 19 章有多处语法更新，反映了应更多使用 TypeIdentifier 类型标识符，而不仅仅是 Identifier 标识符，以支持局部变量类型推断。 杂项如果 Kerberos 的配置文件 krb5.conf 包含一个 INCLUDEDIR 选项，那么在 INCLUDEDIR 这个目录下所有以 .conf 结尾的文件都会被默认加载进来。 以前版本中已经过期的 Java 的启动选项 -d32 和 –d64 在当前版本已经被移除。如果在新的版本里仍然使用了这两个选项，JVM 将无法正常启动。 JDK10 支持 JDK9 中的新版本 Doclet，JDK6、JDK7、JDK8 中的 Doclet 版本都不再支持。 JDK10 重新启用了在 JDK9 中被不当过时的 newFactory() 方法。 JDK10 引入了一个新的 Javadoc 标签： {@summary…}，解决了以前版本无法生成 API 摘要的问题。 JDK10 去掉了 BiasedLockingStartupDelay 的 4 秒启动延时。 以下在 com.sun.security.auth 包中的过时的类在新版本中都已经被移除： PolicyFile SolarisNumericGroupPrincipal SolarisNumericUserPrincipal X500Principal SolarisLoginModule SolarisSystem 在 java.lang.SecurityManager 类中的以下属性和方法（从 JDK 1.2 就已经过时）终于被移除了： inCheck (属性) getInCheck classDepth classLoaderDepth currentClassLoader currentLoadedClass inClass inClassLoader 以下 java.lang.Runtime 类中已经被废弃的国际化方法在新版本被移除： getLocalizedInputStream getLocalizedOutputStream 以下废弃的 Hotspot –X 选项在新版本中被移除：-Xoss, -Xsqnopause, -Xoptimize, -Xboundthreads and –Xusealtsigs.policytool 在新版本中被移除。 javadoc 工具在新版本中可以通过 –add-stylesheets 命令选项支持多个 stylesheets 。 新版本的 JVM 能够根据系统分配给当前 Docker 容器的 CPU 数和内存来配置线程池和 GC 机制，而不再是直接使用系统的 CPU 和内存。并且增加了三个更强大的命令选项：-XX:InitialRAMPercentage、-XX:MaxRAMPercentage 和 -XX:MinRAMPercentage 。 新版本增加了一个新的系统属性：jdk.disableLastUsageTracking。 这个新增的属性就像它的名字一样，会禁用 JRE 的上一次使用跟踪。 如上所述，尽管距离 JDK 9 发布仅有六个月的时间，但 JDK 10 实际上有相当多的变化。 当然，它们中的一些是非常小的变更，但这表明目前每 6 个月发布一次的节奏，将在 Java 平台快速迭代改进方面起到作用。 也许以后的以后，每当Java新版本发布： 我们都会感慨一句：我X，JavaX又发布了！！！]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Java10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你修改苹果设备定位]]></title>
    <url>%2Fposts%2F2018-03-20-changeAppleLocation%2F</url>
    <content type="text"><![CDATA[安卓修改定位比较简单，工具一大堆，这里提供一种修改苹果设备定位的方法！ 1.下载工具首先下载工具—-&gt;爱思助手 现在爱思助手已经更新到7.x版本了，安装并打开。 打开后，通过数据线连接好手机,连接成功后就会显示这个窗口。 2.修改步骤点击左上方的“设备信息”。打开后可以看到有一个“备份/恢复”，点击全备份设备。 然后选择“立即备份”，就可以把手机上面的数据备份到电脑上了，这里时间可能会有点长。 当显示备份完成后,点击上面的“备份恢复”界面，然后找到刚刚使用的“全备份文件管理”，然后直接打开查看。 打开后，可以看到“AppDomain-com.apple.Maps”的文件夹，点击打开。 然后接着打开Library/Preferences，并往下拉找到com.apple.Maps.plist文件，继续打开。 会看到有两行代码&lt;/dict&gt;和&lt;/plist&gt;，然后把下面的代码写在这两行上面： &lt;key&gt;__internal__PlaceCardLocationSimulation&lt;/key&gt;&lt;true/&gt; 完成后点击保存。 添加完成后，找到刚刚界面的全“全恢复数据”然后点击立即恢复。 重启一下手机。 打开手机地图，会发现下面多了一个选项Simulate Location。 点击这个，所有的软件位置定位都是这个虚拟位置。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>定位</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序猿视角"手撕"微信多开]]></title>
    <url>%2Fposts%2F2018-03-14-multi-wechat%2F</url>
    <content type="text"><![CDATA[白色情人节，快！ 乐！ 微信多开，不想使用其他多开软件，胆小，怕封号！ 从程序猿的视角，实现微信多开，对，徒手撕！ 1.简介软件代码是如何实现同一个软件只能打开一次的？ “死锁”操作系统上有两类锁，一类是进程内可见的，一类是跨进程可见的。 软件程序想要单实例运行，是使用了第二类锁， 声明一个跨进程可见的锁（互斥量Mutex）。 当你第二次打开同一个软件，启动时检测跨进程可见的锁是否存在，如果存在就退出，如果不存在就正常启动。 2.具体实现(1)下载微软的增强版资源管理器 下载地址：https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer (2)下载后用管理员身份运行，找到微信的进程 WeChat (3)按下Ctrl+L,显示详细信息，找到如下的两把锁。 WeChat_GlobalConfig_Multi_Process_Mutex _WeChat_App_Instance_Identity_Mutex_Name 然后右键， Close Handle， 结束掉这两把锁。 (4)OK,可以打开第二个微信了。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
        <tag>微信</tag>
        <tag>微信多开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的 Docker 镜像]]></title>
    <url>%2Fposts%2F2018-02-08-docker-images%2F</url>
    <content type="text"><![CDATA[收集一些有趣的Docker镜像！！！ Docker 一键安装脚本 wget -qO- get.docker.com | sh 常用基础镜像Centos/Debian/Ubuntu CentOS：kinogmt/centos-ssh （默认用户名root，密码password，CentOS6.7） Debian：itscaro/debian-ssh（默认用户名root，密码root，Debian Jessie） Ubuntu：rastasheep/ubuntu-sshd（默认用户名root，密码root） 镜像1：rastasheep/ubuntu-sshd （带ssh的ubuntu）地址：https://hub.docker.com/r/rastasheep/ubuntu-sshd/ sudo docker run -d -p 22:22 rastasheep/ubuntu-sshd:16.04 用户名、密码为root 镜像2：itscaro/debian-ssh （带ssh的ubuntu）地址：https://hub.docker.com/r/itscaro/debian-ssh/ sudo docker run -d -p 22:22 itscaro/debian-ssh 用户名、密码为root 镜像3：tutum/centos （带ssh的centos）地址：https://hub.docker.com/r/tutum/centos/ sudo docker run -d -p 22:22 tutum/centos（centos7：tutum/centos:centos7 ） 用户名root，密码随机，请执行 docker logs 查看 镜像4：alexwhen/docker-2048（游戏2048）地址：https://hub.docker.com/r/alexwhen/docker-2048/ sudo docker run -d -p 80:80 alexwhen/docker-2048 镜像5：dorowu/ubuntu-desktop-lxde-vnc（noVNC、Firefox51）地址：https://hub.docker.com/r/dorowu/ubuntu-desktop-lxde-vnc/ docker run -it -p 80:80 dorowu/ubuntu-desktop-lxde-vnc Browse http://ip/ 镜像6：consol/centos-xfce-vnc （VNC、noVNC、密码、chrome、Firefox45）地址：https://hub.docker.com/r/consol/ubuntu-xfce-vnc/ run -it -p 5901:5901 -p 6901:6901 -e “VNC_PW=my-new-password” -e VNC_RESOLUTION=800x600 consol/centos-xfce-vnc 默认VNC密码：vncpassword VNC-Server (default VNC port 5901) noVNC - HTML5 VNC client (default http port 6901) 其他相关 onsol/centos-xfce-vnc: Centos7 with Xfce4 UI session consol/ubuntu-xfce-vnc: Ubuntu with Xfce4 UI session consol/centos-icewm-vnc: dev Centos7 with IceWM UI session consol/ubuntu-icewm-vnc: dev Ubuntu with IceWM UI session 镜像7：fish/peerflix-server （支持磁力，种子）地址：https://hub.docker.com/r/dorowu/ubuntu-desktop-lxde-vnc/ docker run -it -p 9000:9000 fish/peerflix-server Browse http://ip:9000/ 镜像8：jpillora/cloud-torrent（种子下载，搜索）地址：https://hub.docker.com/r/jpillora/cloud-torrent/ docker run -d -p 3000:3000 -v /path/to/my/downloads:/downloads jpillora/cloud-torrent Browse http://ip:3000/ 镜像9：jim3ma/google-mirror（google镜像，如需ssl要手动添加）地址：https://hub.docker.com/r/jim3ma/google-mirror/ docker run -d -p 80:80 jim3ma/google-mirror Browse http://ip/ 镜像10：google-reverse-proxy（google镜像，有ssl）地址：https://hub.docker.com/r/jokester/google-reverse-proxy/ docker run -d –publish 54321:20081 –restart=always jokester/google-reverse-proxy Browse http://ip:54321/ 镜像11：forsaken-mail（临时邮箱）地址：https://hub.docker.com/r/rockmaity/forsaken-mail/ docker run –name forsaken-mail -itd -p 25:25 -p 3000:3000 rockmaity/forsaken-mail Browse http://ip:3000/ 镜像12：imdjh/owncloud-with-ocdownloader支持 owncloud, torrent, aria2, youtube-dl 地址：https://hub.docker.com/r/imdjh/owncloud-with-ocdownloader/ docker run -d -p 80:80 -e OWNCLOUD_VERSION=9.1.4 -v /var/www/html/data:/var/www/html/data imdjh/owncloud-with-ocdownloader Browse http://ip/ 镜像13：v2ray/official（v2ray）地址：https://hub.docker.com/r/v2ray/official/ docker run -d -p 8001:8001 v2ray/official 镜像14：timonier/aria2地址：https://hub.docker.com/r/timonier/aria2/ docker run -i -t -v /data:/data –net host timonier/aria2 –dir=/data –enable-rpc –rpc-listen-all=true 配合使用：timonier/webui-aria2（aria2web管理） 地址：https://hub.docker.com/r/timonier/webui-aria2/ docker run -i -t -p 80:80 timonier/webui-aria2]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Docker</tag>
        <tag>Docker镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 搭建 Docker 环境]]></title>
    <url>%2Fposts%2F2018-02-08-centos-docker%2F</url>
    <content type="text"><![CDATA[Docker, Docker, Docker !!! 有人说Docker是未来，也有人说Docker已死，不管怎样，该学还得学，该搬的砖一块都不会少。 2013年Docker刚发布那会，懵懂不甚理解，通过2015年慢慢的接触，才了解了点皮毛，还记得2016年arukas.io提供的Docker服务，玩的不亦乐乎。 关于介绍还是请各位Google去，这里系统地整理下Docker入门，在CentOS下搭建Docker环境。 安装与配置Docker1.安装Docker Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 docker，只需要运行下面的 yum 命令： yum install docker-io -y 直接yum安装，安装成功后查看版本 docker -v 启动docker service docker start 设置开机启动 chkconfig docker on 2.配置 Docker 因为国内访问 Docker Hub 较慢, 可以使用腾讯云提供的国内镜像源, 加速访问 Docker Hub,依次执行以下命令: echo "OPTIONS='--registry-mirror=https://mirror.ccs.tencentyun.com'" >> /etc/sysconfig/docker systemctl daemon-reload service docker restart Docker的简单操作1.下载镜像 下载一个官方的 CentOS 镜像到本地 docker pull centos 下载好的镜像就会出现在镜像列表里 docker images 2.运行容器 这时我们可以在刚才下载的 CentOS 镜像生成的容器内操作了。生成一个 centos 镜像为模板的容器并使用 bash shell docker run -it centos /bin/bash 这个时候可以看到命令行的前端已经变成了 [root@(一串 hash Id)] 的形式, 这说明我们已经成功进入了 CentOS 容器。 在容器内执行任意命令, 不会影响到宿主机, 如下: mkdir -p /data/simple_docker 可以看到 /data 目录下已经创建成功了 simple_docker 文件夹 ls /data 退出容器 exit 查看宿主机的 /data 目录, 并没有 simple_docker 文件夹, 说明容器内的操作不会影响到宿主机 ls /data 3.保存容器 查看所有的容器信息， 能获取容器的id docker ps -a 然后执行如下命令，保存镜像： docker commit -m=”备注” 你的CONTAINER_ID 你的IMAGE 部署完成大功告成！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Ubuntu搭建FTP文件服务器]]></title>
    <url>%2Fposts%2F2018-02-07-ubuntu-ftp%2F</url>
    <content type="text"><![CDATA[经常需要搭建FTP，各种配置起来很繁琐，今天整理下，方便以后使用！ 安装并启动FTP服务(1) 安装VSFTPD 使用 apt-get 安装 vsftpd： sudo apt-get install vsftpd -y (2) 启动 VSFTPD 安装完成后 VSFTPD 会自动启动，通过 netstat 命令可以看到系统已经 监听了 21 端口： sudo netstat -nltp | grep 21 如果没有启动，可以手动开启 VSFTPD 服务： sudo systemctl start vsftpd.service 配置用户访问目录(1)新建用户主目录 sudo mkdir /home/uftp 执行完后，在 /home/uftp 就能看到新建的文件夹 uftp 了。 创建登录欢迎文件: sudo touch /home/uftp/welcome.txt (2)新建用户 uftp 并设置密码 创建一个用户 uftp: sudo useradd -d /home/uftp -s /bin/bash uftp 为用户 uftp 设置密码: sudo passwd uftp 删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败： sudo rm /etc/pam.d/vsftpd (3)限制该用户仅能通过 FTP 访问 限制用户 uftp 只能通过 FTP 访问服务器，而不能直接登录服务器： sudo usermod -s /sbin/nologin uftp (4)修改 vsftpd 配置 sudo chmod a+w /etc/vsftpd.conf 修改 /etc/vsftpd.conf 文件中的配置（直接将如下配置添加到配置文件最下方）： # 限制用户对主目录以外目录访问 chroot_local_user=YES # 指定一个 userlist 存放允许访问 ftp 的用户列表 userlist_deny=NO userlist_enable=YES # 记录允许访问 ftp 用户列表 userlist_file=/etc/vsftpd.user_list # 不配置可能导致莫名的530问题 seccomp_sandbox=NO # 允许文件上传 write_enable=YES # 使用utf8编码 utf8_filesystem=YES 新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户： sudo touch /etc/vsftpd.user_list sudo chmod a+w /etc/vsftpd.user_list 修改 /etc/vsftpd.user_list ，加入刚刚创建的用户： uftp (5)设置访问权限 设置主目录访问权限（只读）： sudo chmod a-w /home/uftp 新建公共目录，并设置权限（读写）：[可选] sudo mkdir /home/uftp/public &amp;&amp; sudo chmod 777 -R /home/uftp/public 重启vsftpd 服务： sudo systemctl restart vsftpd.service 访问 FTP 服务FTP 服务已安装并配置完成，下面我们来使用该 FTP 服务。根据您个人的工作环境，选择一种方式来访问已经搭建的 FTP 服务。 (1)通过 FTP 客户端工具访问 FTP 客户端工具众多，下面推荐两个常用的： ① FileZilla - 跨平台的 FTP 客户端，支持 Windows 和 Mac ② WinSCP - Windows 下的 FTP 和 SFTP 连接客户端 下载和安装 FTP 客户端后，使用服务器的登录信息(服务器IP和ftp的用户名以及密码)进行连接即可，例如： 主机：100.100.100.100 用户名以及密码： uftp/uftp 输入密码后，如果能够正常连接，那么大功告成，您可以开始使用属于您自己的 FTP 服务器了！ 接下来，请上传任意一张图片到 FTP 服务器上的 uftp 的 public 目录下，然后，就可以在 /home/uftp/public 中看到了。 (2)通过 Windows 资源管理器访问 Windows 用户可以复制下面的链接到资源管理器的地址栏访问： ftp://uftp:uftp@100.100.100.100]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 SVN 服务器]]></title>
    <url>%2Fposts%2F2018-02-06-linux-svn%2F</url>
    <content type="text"><![CDATA[虽然当今江湖上Git当道，但是SVN也是需要搭建的，今天整理下，方便以后使用！ 安装SVN服务端Subversion 是一个版本控制系统，相对于的 RCS 、 CVS ，采用了分支管理系统，它的设计目标就是取代 CVS 。 yum install -y subversion 创建SVN版本库创建项目版本库 mkdir -p /data/svn/myproject svnadmin create /data/svn/myproject 配置SVN信息1.配置文件简介 版本库中的配置目录 conf 有三个文件: authz 是权限控制文件 passwd 是帐号密码文件 svnserve.conf 是SVN服务综合配置文件 2.配置权限配置文件 authz 编辑 authz ，内容参考如下： [groups] #用户组 admin = admin,root,test #用户组所对应的用户 [/] #库目录权限 @admin = rw #用户组权限 *=r #非用户组权限 3.配置账号密码文件 passwd 编辑 passwd ，内容参考如下： [users] # harry = harryssecret # sally = sallyssecret admin = 123456 root = 123456 test = 123456 4.配置 SVN 服务综合配置文件 svnserve.conf 编辑 svnserve.conf ，内容参考如下： [general] # force-username-case = none # 匿名访问的权限 可以是read、write，none，默认为read anon-access = none #使授权用户有写权限 auth-access = write #密码数据库的路径 password-db = passwd #访问控制文件 authz-db = authz #认证命名空间，SVN会在认证提示里显示，并且作为凭证缓存的关键字 realm = /data/svn/myproject [sasl] 启动SVN服务1.启动SVN svnserve -d -r /data/svn 2.checkout SVN 项目 mkdir -p /data/workspace/myproject svn co svn://127.0.0.1/myproject /data/workspace/myproject --username root --password 123456 --force --no-auth-cache 3.提交文件到SVN服务器 从本地提交文件到 SVN 服务器，其中 root 密码为 /data/svn/myproject/conf/passwd 文件存储的密码 cd /data/workspace/myproject echo test >> test.txt svn add test.txt svn commit test.txt -m 'test' 提交成功后可以通过如下命令从本地项目删除文件: cd /data/workspace/myproject rm -rf test.txt 删除后可以通过 SVN 服务器恢复: cd /data/workspace/myproject svn update 部署完成大功告成！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 搭建 Git 服务器]]></title>
    <url>%2Fposts%2F2018-02-05-centos-git%2F</url>
    <content type="text"><![CDATA[当今江湖上Git当道，整理下，方便以后使用！ Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 这里以 CentOS 7.2 x64 的系统为环境，搭建 Git 服务器。 下载安装Git1.安装依赖库和编译工具 为了后续安装能正常进行，我们先来安装一些相关依赖库和编译工具 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel 安装编译工具: yum install gcc perl-ExtUtils-MakeMaker 2.下载 Git 选一个目录，用来放下载下来的安装包，这里将安装包放在 /usr/local/src 目录里 cd /usr/local/src 到官网找一个新版稳定的源码包下载到 /usr/local/src 文件夹里 wget https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz 解压和编译: 解压下载的源码包 tar -zvxf git-2.10.0.tar.gz 解压后进入 git-2.10.0 文件夹 cd git-2.10.0 执行编译 make all prefix=/usr/local/git 编译完成后, 安装到 /usr/local/git 目录下 make install prefix=/usr/local/git 配置环境变量将 git 目录加入 PATH 将原来的 PATH 指向目录修改为现在的目录: echo ‘export PATH=$PATH:/usr/local/git/bin’ &gt;&gt; /etc/bashrc 生效环境变量； source /etc/bashrc 此时我们能查看 git 版本号，说明我们已经安装成功了； git –version 创建Git账号密码创建 git 账号 为我们刚刚搭建好的 git 创建一个账号 useradd -m gituser 然后为这个账号设置密码: passwd gituser 初始化Git仓库并配置用户权限1.创建 git 仓库并初始化 我们创建 /data/repositories 目录用于存放 git 仓库 mkdir -p /data/repositories 创建好后，初始化这个仓库 cd /data/repositories/ &amp;&amp; git init –bare test.git 2.配置用户权限 给 git 仓库目录设置用户和用户组并设置权限 chown -R gituser:gituser /data/repositories chmod 755 /data/repositories 查找 git-shell 所在目录, 编辑 /etc/passwd 文件，将最后一行关于 gituser 的登录 shell 配置改为 git-shell 的目录如下: gituser:x:500:500::/home/gituser:/usr/local/git/bin/git-shell 3.使用搭建好的 Git 服务 克隆 test repo 到本地: cd ~ &amp;&amp; git clone &#103;&#105;&#116;&#117;&#115;&#101;&#x72;&#64;&#x31;&#x32;&#51;&#x2e;&#50;&#48;&#55;&#46;&#x34;&#x35;&#x2e;&#49;&#x32;&#51;:/data/repositories/test.git 部署完成大功告成！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度莱茨狗免费领取]]></title>
    <url>%2Fposts%2F2018-02-03-baidupet%2F</url>
    <content type="text"><![CDATA[区块链今年是异常的火爆~ 百度推出了区块链数字狗，目前可以免费领取！！虽然不知道这个玩意有啥用，也不知道能玩出什么花，先领取了再说。 官网地址https://pet-chain.baidu.com/ 领取地址第一只：https://pet-chain.baidu.com/chain/splash 第二只：https://pet-chain.baidu.com/chain/splash?appId=2&amp;tpl=wallet 第三只：https://pet-chain.baidu.com/chain/splash?appId=3&amp;tpl=wallet 第四只：https://pet-chain.baidu.com/chain/splash?appId=4&amp;tpl=wallet 我是谁?汪汪汪~ 我是区块链赋能的莱茨狗。 我的小伙伴们，每只都有独一无二的基因。 一旦你拥有了我，我们的关系将被永远记录在区块链上，任何人都不能改变。 我有8个外貌特征，每个特征有两种不同的属性：稀有属性和普通属性。这些属性组合起来，将会决定我最终的稀有等级（普通、稀有、卓越、史诗、神话、传说）。 你要怎么玩儿？你可以在市场中，通过数字积分—微积分，购买你心仪的莱茨狗。 你也能在个人中心，查看并出售你所拥有的莱茨狗。 开发团队百度金融区块链实验室，拥有完整的企业级区块链解决方案，以及面向用户的应用级区块链解决方案。该实验室深入底层技术、平台化、区块链应用以及前瞻性领域研究，目前的技术已应用于多条核心业务线，支撑了超500亿元资产的真实性问题。同时，该实验室也是Hyperledger的核心董事会成员，致力于提升区块链行业的技术发展，推动全球区块链技术规范和标准的建立。 特别提示:01.点击免费领取后，系统将通过区块链，把属于你的狗狗和微积分发放到你的账户中。当领取人数较多时，写入区块链时间可能较长，请耐心等待。 02.当你提交购买订单后，由于订单需要写入区块链，将要一段交易确认时间。待交易确认后，才能在“我的狗窝”看到你所购买的莱茨狗。 03.当你在购买莱茨狗时，需扣除5微积分左右的手续费，用于支付写入区块链所需算力资源的消耗。因此，你的微积分余额必须大于【狗狗出售价格与手续费之和】，才能成功发起购买。实际收取的费用将由具体消耗的算力决定，待交易成功后，可在我的订单中查看。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链初代狗</tag>
        <tag>区块链</tag>
        <tag>初代狗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JetBrains 系列注册码]]></title>
    <url>%2Fposts%2F2018-01-30-jetbrains-mynum%2F</url>
    <content type="text"><![CDATA[由于经常使用JetBrains系列的软件，总是各种找激活信息，很是麻烦，索性自己剁手上车。 2018年01月30日今天又买了一枚激活码，还是一年的有效期，到2019年01月29日。 关注微信公众号《听风吟且行》，回复“jetbrains”即可。 2017年07月30日最近买了个正版IntelliJ 系列注册码（心好痛），可以激活IntelliJ 系列所有产品。 一年有效期，目前到2018年08月25日。 在此分享给大家，拿好，不谢。 1D42KHYC787-eyJsaWNlbnNlSWQiOiJENDJLSFlDNzg3IiwibGljZW5zZWVOYW1lIjoiaXl1IHB1YiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJGb3IgZWR1Y2F0aW9uYWwgdXNlIG9ubHkiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTgtMDgtMjUifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTgtMDgtMjUifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTgtMDgtMjUifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE4LTA4LTI1In0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMTgtMDgtMjUifSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAxOC0wOC0yNSJ9XSwiaGFzaCI6IjY1NDE0MzEvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-c/SJ1KIswpxXLzreXc8ou/XgLUVy3rvhsu9OqB7491QfoTfF8HeO4fxH4MSsB2MwxNhbgcsfCxDGR23u5Gc+RGuCTPlnsahWCsnVYpcFUxjML8MS0FN/5inrDrZXZLE+nUeW+fwgnwM2Y0ttBy/vDcvJKYasqV8YBFAkPIG+HuegiIFz1gYqF99xIofDzeL4pziUi/K5JyWHP/JCgTqQlzDnpNfqILJDyYJNqGkZwJBAWuytkcbvh85lmRPhePKl9gQr+Rh2k9jF8+bUCZh2OrZVey2KK5Kg2pi52QENhcVqJwWVzF0CTwqzpJStCw3g6OLiXUKDX+CJhH8/TfipPg==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>注册码</tag>
        <tag>IntelliJ</tag>
        <tag>IDEA</tag>
        <tag>PyCharm</tag>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code常用技巧]]></title>
    <url>%2Fposts%2F2018-01-22-vscode%2F</url>
    <content type="text"><![CDATA[2018年01月22日更新： 1.去掉vscode右侧的预览窗口 文件&gt;&gt;首选项&gt;&gt;设置 属性editor.minimap.enabled 改为false 2.代码格式化： Shift+Alt+F 或 Ctrl+Shift+P后输入format code]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>VSCode</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[放学别走，等你下课]]></title>
    <url>%2Fposts%2F2018-01-18-dengnixiake%2F</url>
    <content type="text"><![CDATA[欣赏歌曲，全词不押韵！这，其实已经是到了一个新的境界！ 众所周知，无论诗词，韵脚都是极为重要，决定了是否让人朗朗上口！而，周董眼中：押韵是什么？我自己来，随便来！偏偏，效果极好！ 专辑名称随意啦，歌词随意啦，MV随意啦（卡通图，敢不敢再随意一点），内容好，那就够了！ 音乐在线播放： http://music.163.com/song?id=531051217&amp;userid=91899213 下载： 下载地址 MV在线播放：http://music.163.com/mv/?id=5819032&amp;userid=91899213 下载（超清版）：下载地址 歌词作曲 : 周杰伦作词 : 周杰伦 **Jay**： 你住的 巷子里 我租了一间公寓 为了想与你不期而遇 高中三年 我为什么 为什么不好好读书 没考上跟你一样的大学 我找了份工作 离你宿舍很近 当我开始学会做蛋饼 才发现你 不吃早餐 喔 你又擦肩而过 你耳机听什么 能不能告诉我 **合**： 躺在你学校的操场看星空 教室里的灯还亮着你没走 记得 我写给你的情书 都什么年代了 到现在我还在写着 总有一天总有一年会发现 有人默默的陪在你的身边 也许 我不该在你的世界 当你收到情书 也代表我已经走远 **Gary**： 学校旁 的广场 我在这等钟声响 等你下课一起走好吗 **Jay**： 弹着琴 唱你爱的歌 暗恋一点都不痛苦 （Gary：一点都不痛苦） **Jay**： 痛苦的是你 **合**： 根本没看我 **Jay**： 我唱这么走心 却走不进你心里 （Gary：这么走心 进你心里） **Jay**： 在人来人往 **合**： 找寻着你 守护着你 不求结局 **Gary**： 喔 你又擦肩而过 （Jay：喔 而过） **Jay**： 我唱告白气球 终于你回了头 **合**： 躺在你学校的操场看星空 教室里的灯还亮着你没走 记得 我写给你的情书 都什么年代了 到现在我还在写着 总有一天总有一年会发现 有人默默的陪在你的身边 也许 我不该在你的世界 当你收到情书 也代表我已经走远]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>周杰伦</tag>
        <tag>等你下课</tag>
        <tag>单曲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你一定要安装的反挖矿插件]]></title>
    <url>%2Fposts%2F2018-01-17-nocoin%2F</url>
    <content type="text"><![CDATA[为什么我们需要安装反挖矿扩展程序？ 主要此类扩展程序会自动检测网站是否加载挖矿脚本，如果检测到那么直接封锁脚本并禁止脚本加载。禁止后不会影响访问者继续浏览网页或者是使用其中的功能（少部分网站禁止加载挖矿脚本后会设置访问阻挡）。 另外挖矿脚本可以按照网站所有者的意愿进行自定义配置，如果设置的哈希计算强度比较低的话那么CPU负载并不会很高、风扇转速亦不会迅速提高，所以通常情况下我们亦不会发觉已经被挖矿。 当然如果是笔记本电脑的话拦截挖矿脚本还可以节省我们的电量，同时如果使用按流量计费的网络也可以帮助我们节省流量开支（挖矿消耗的流量实际上比较低）。 最重要的是现在越来越多的网站开始使用挖矿脚本，显然如果我们经常访问网页的话那么对于设备性能和电量来说都是个损失。 目前仅发现360极速浏览器和opera浏览器自带防挖矿功能（傲游很逗比的出了个挖矿版） 其他浏览器可下载对应的防挖矿扩展 另外，IE浏览器不支持挖矿脚本…… 相关浏览器插件下载Chrome插件： https://chrome.google.com/webstore/detail/no-coin/gojamcfopckidlocpkbelmpjcgmbgjcl FireFox插件1： https://addons.mozilla.org/zh-CN/firefox/addon/no-coin/?src=search FireFox插件2： https://addons.mozilla.org/zh-CN/firefox/addon/coinblock/?src=search TingBrowser开发事项： 在下个版本的TingChrome和TingFirefox中会集成反挖矿插件。 最近由于事情有点多，没有时间开发其他的浏览器版本。。。 TingBrowser官网： http://browser.iyu.pub]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>IT</tag>
        <tag>反挖矿</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mqtt专题（一）之MQTT协议]]></title>
    <url>%2Fposts%2F2017-12-27-mqtt_subject1%2F</url>
    <content type="text"><![CDATA[MQTT系列专题文章一之MQTT协议 一、基本概念MQTT(Message Queuing Telemetry Transport,消息队列遥测传输)是IBM开发的一个即时通信协议，是物联网的重要组成部分，该协议几乎支持所有的平台。最近工作中正在使用这个，这个博客写的简单是自学的笔记，不喜勿喷啊。。。 二、MQTT的特点MQTT 协议是为大量计算能力有限，且工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性： 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于 XMPP，但是 MQTT 的信息冗余远小于XMPP（因为 XMPP 使用的是 XML 这种格式来传递数据）。 对负载内容屏蔽的消息传输。 使用 TCP/IP 提供网络连接。主流的 MQTT 是基于 TCP 连接进行数据推送的，但是同样有基于 UDP 的版本，叫做 MQTT-SN 。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 有三种消息发布服务质量（Qos）: 最多一次：消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。 至少一次：确保消息到达，但消息重复可能会发生。这一种方式比较鸡肋，在我的想象中没能想到这种质量的发送在常规的 APP 开发中有什么用处。 只有一次：确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP 的推送，确保用户收到且只会收到一次。 小型传输，数据传输和狭义交换的最小化（协议头部只有2个字节），以降低网络流量。 通知机制，异常中断是通知传输双方。使用 Last Will 和 Testament 特性通知有关各方客户端异常中断的机制。Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。 三、MQTT协议原理 协议实现方式 实现MQTT协议需要:客户端和服务器端 MQTT协议中有三种身份：发布者（Pushlish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT的消息分为：主题（Topic）和负载（payload）两部分 Topic,可以理解为消息的类型，订阅者Subscribe之后，就会收到该主题的消息内容（payload）。 payload，可以理解为消息的内容，是指订阅者具体的使用内容 网络传输和应用消息 MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节的双向传输。当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（Qos）和主题名（Topic）相关联。 MQTT客户端 一个使用MQTT的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以: 发布其他客户端可能会订阅的消息 订阅其他客户端发布的消息 退订或删除应用程序的消息 断开与服务器的连接 MQTT服务器 MQTT服务器可以称为“消息代理（Broker）”,也可以是一个 应用程序或者设备，它位于消息发布者和订阅者之间，它可以： 接受来自客户的网络连接 接受客户发布的应用信息 处理来自客户端的订阅和退订请求 向订阅的客户转发应用程序信息 MQTT协议中的订阅、主题、会话 订阅（Subscription） 订阅包换主题筛选器（Topic Filter）和最大服务质量（Qos）。订阅与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话的每个订阅都有一个不同的主题筛选器。 会话（Session）每个客户与服务器建立连接之后就是一个会话，客户端和服务器之间有状态交互。会话存在一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。 主题名（Topic）连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。 主题筛选器（Topic Filter）一个与主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。 负载（Payload）消息订阅者所具体接收的内容 MQTT协议中的方法 MQTT 协议中定义了一些方法（也被称为动作）， 来于表示对确定资源所进行操作。 这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。 Connect，等待与服务器建立连接 Disconnect，等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话 Subscribe，等待完成订阅 UnSubscribe，等待服务器取消客户端的一个或多个topic订阅 Publish， MQTT 客户端发送消息请求，发送完成后返回应用程序线程 未完待续。。。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐一部科幻小说《三体》（1-3全本）]]></title>
    <url>%2Fposts%2F2017-12-22-santi%2F</url>
    <content type="text"><![CDATA[三体 文化大革命如火如荼地进行，天文学家叶文洁在期间历经劫难，被带到军方绝秘计划“红岸工程”。叶文洁以太阳为天线，向宇宙发出地球文明的第一声啼鸣，取得了探寻外星文明的突破性进展。三颗无规则运行的太阳主导下，四光年外的“三体文明”百余次毁灭与重生，正被逼迫不得不逃离母星，而恰在此时，他们接收到了地球发来的信息。对人性绝望的叶文洁向三体人暴露了地球的坐标，彻底改变了人类的命运。 地球的基础科学出现了异常的扰动，纳米科学家汪淼进入神秘的网络游戏《三体》，开始逐步逼近这个世界的真相。汪淼参加一次玩家聚会时，接触到了地球上应对三体人到来而形成的一个秘密组织（ETO）。地球防卫组织中国区作战中心通过“古筝计划”，一定程度上挫败了拯救派和降临派扰乱人类科学界和其他领域思想的图谋，获悉处于困境之中的三体人为了得到一个能够稳定生存的世界决定入侵地球。 在运用超技术锁死地球人的基础科学之后，庞大的三体舰队开始向地球进发，人类的末日悄然来临。 三体Ⅱ·黑暗森林 三体人在利用科技锁死了地球人的科学之后，出动庞大的宇宙舰队直扑太阳系，面对地球文明前所未有的危局，人类组建起同样庞大的太空舰队，同时（PDC）利用三体人思维透明的致命缺陷，制订了“面壁计划”。出乎意料地，社会学教授罗辑被选出作为四位“面壁者”之一，展开对三体人的秘密反击。虽然三体人自身无法识破人类的计谋，却依靠由地球人中的背叛者挑选出的“破壁人”与“面壁者”进行智慧博弈。 在这场你死我活的文明生存竞争中，罗辑由一开始的逃避和享乐主义逐渐意识到自己的责任心，想到了一个对抗三体文明入侵的办法。科研军官章北海试图借一场陨石雨干涉飞船推进形式的研究方向。近二百年后，获选增援未来的他在人类舰队被“水滴”清除殆尽前，成功抢夺战舰逃离。此时罗辑证实了宇宙文明间的黑暗森林法则，任何暴露自己位置的文明都将很快被消灭。 借助于这一发现，他以向全宇宙公布三体世界的位置坐标相威胁，暂时制止了三体对太阳系的入侵，使地球与三体建立起脆弱的战略平衡。 三体Ⅲ·死神永生 身患绝症的云天明买下一颗星星送给暗恋着的大学同学程心，而程心因参与（PIA）向三体舰队发射探测器的工作，却想让航天专业背景的他放弃安乐死，作为被执行人将大脑捐献给阶梯计划。与三体文明的战争使人类首次看到了宇宙黑暗的真相，地球文明因为黑暗森林打击的存在如临大敌，不敢在太空中暴露自己。在零道德的宇宙中发起黑暗战役的战舰被诱导返航，却受到有道德的地球文明审判。 不称职的懦弱少女程心被选来充当掌握地球命运的执剑人，她因为罗辑的成功将这看作一项只需花费时间的任务，刚刚任职水滴就向地球发动攻击，程心为了忠于人性做出了错误的决定。在警示下继续逃离的“蓝色空间”号，受到具有发射引力波能力的“万有引力”号与两个同行的“水滴”追击，其上的人员进入四维空间摧毁水滴并占领了“万有引力”号，启动引力波广播向宇宙公布了三体星系的坐标。 云天明与地球取得联系，通过讲述三个自己编创的童话故事，向程心透露大量情报；人类自以为悟出了生存竞争的秘密，开始进行掩体计划，维德领导的空间曲率驱动研究因为程心的错误判断被终止，使得人类最终没有能够逃脱被高级文明毁灭的命运。因为宇宙中还存在更强大的文明，战争的方式和武器已经远超出人类的想象，极高文明发出了一张卡片大小的“二向箔”，使整个太阳系压缩为二维平面而毁灭。 在地球人类接近灭亡之际，只有程心和艾AA两个幸存者乘坐光速飞船离开。罗辑成为设置于冥王星的地球文明博物馆的“守墓人”，她们在冥王星带走人类文明的精华。在云天明送的恒星的一颗行星上，程心遇到关一帆且探讨了宇宙降维的真相，然而超乎一切之上的力量要求宇宙归零重生，在黑域中穿越长达1800万年的时空……程心没有等到云天明到来，和关一帆在小宇宙中短暂居住后重新进入大宇宙生活。 三体全本下载:点我下载]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>三体</tag>
        <tag>科幻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownPad2.5 注册码分享]]></title>
    <url>%2Fposts%2F2017-12-20-markdownpad-num%2F</url>
    <content type="text"><![CDATA[最近在使用Markdown书写，找到一款Markdown的编辑工具，分享一枚注册码。 邮箱： Soar360@live.com 授权秘钥： 1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==]]></content>
      <categories>
        <category>福利</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>注册码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django开发的微信公众号上线]]></title>
    <url>%2Fposts%2F2017-07-05-django-wechat%2F</url>
    <content type="text"><![CDATA[近期在学习Python的Django框架，写了几个小项目之后，就想着用在公众号（听风吟且行）上试试。 经过一周的开发，终于上线了。现在大概支持3个功能： 1.快递查询：输入“快递公司名字+快递单号”，比如输入“圆通11111111111” 2.天气查询：输入“城市名+天气”，比如输入“深圳天气” 3.自动回复：自动语义回复的功能，随时随地陪您聊天。大概实现了如下的一些功能： （1）笑话大全：“讲个笑话” （2）故事大全：“讲个故事” （3）成语接龙：“成语接龙一心一意” （4）新闻资讯：“今日新闻” （5）姓名测试：“林俊杰这个名字好不好” （6）星座运势：“射手座的运势” （7）生活百科：“树莓派的简介” （8）图片搜索：“计算机的图片” （9）天气查询：“深圳天气” （10）菜谱大全：“糖醋排骨怎么做” （11）聊天对话：“你好” （12）列车查询：“今天深圳到合肥的火车” （13）航班查询：“今天深圳到上海的飞机” （14）数字计算：“3的立方是多少” （15）中英互译：“苹果的单词是什么” （16）问答百科：“天为什么是蓝的” （17）绕口令：“说个绕口令” （18）城市邮编：“深圳的邮编” 目前大概实现了这些功能，当然可能有些Bug，只是为了练手的，不喜勿喷。 有兴趣的童鞋可以关注（听风吟且行），体验一下，尽情的撩吧！ 体验之后，如果有什么好的建议，请回复我，我会逐渐完善的，谢谢！ 最后放上微信公众号的二维码：]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>WeChat</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tool工具页面正式上线！！！]]></title>
    <url>%2Fposts%2F2017-06-15-tool-django%2F</url>
    <content type="text"><![CDATA[2017年06月15日Tool后台写了一个星期，框架大概搭建起来。。。 接下来就是码代码。 先放上几个小工具，后面慢慢增加（针对需求的优先级） 界面目前还没怎么优化，先将就着看吧，先把功能完善。。。哈哈^_^ 项目环境： 整套项目使用Django框架，使用Python3开发。 项目还在持续设计中，如有好的建议，留言告诉我，我会加入你所期待的功能。 https://tool.hunit.cn]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单Python抓取网页下载地址]]></title>
    <url>%2Fposts%2F2017-01-19-getlinkbypython%2F</url>
    <content type="text"><![CDATA[下午，一哥们说要下载美剧《福尔摩斯：基本演绎法》，网页上几十个迅雷下载链接，嫌麻烦不愿一个一个点，我就建议了如下方法： 写个程序去抓取网页上有用的迅雷下载链接，再把全部链接复制到迅雷，就OK。 这里我用Python简单写了个。。。不喜勿喷。。。 抓取的网页：http://www.qtfy.cc/mjxz/13553.html # -*- coding: utf8 -*- import urllib.request as request from bs4 import BeautifulSoup def geturl(href): html = request.urlopen(href).read().decode('utf-8') html_Soup = BeautifulSoup(html, 'lxml') a = html_Soup.find_all('a') for link in a: if link.get('href') is not None: if "thunder" in link.get('href') : print(link.get('href')) if "ed2k" in link.get('href') : print(link.get('href')) if __name__ == '__main__': geturl("http://www.qtfy.cc/mjxz/13553.html") 简单易懂，达到想要的效果就行。 针对其他的电影网站下载链接，稍微改下即可。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[情怀再起--Opera发布概念网页浏览器Opera Neon]]></title>
    <url>%2Fposts%2F2017-01-13-operaneon%2F</url>
    <content type="text"><![CDATA[Opera 今天展示了首款概念网页浏览器,代号为 Opera Neon。Opera Neon 采用与标准版 Opera 浏览器相同的渲染引擎,但 Neon 的重点是突出显示网页内容。Opera Neon 包含全新用户界面,包括使用用户桌面壁纸的起始页面,包含视频播放器、图库和下载管理器的侧栏,以及视觉标签页条,让用户可以更轻松的在标签页之间切换。 &nbsp; 此外,Opera Neon 还内置了“智能系统”,可以管理标签页,将经常访问的标签页整理至顶部,将不经常访问的页面转移至底部。Opera Neon 还支持弹出式视频播放窗口,方便用户浏览其他网页时继续观看视频。其他功能包括,网页截图功能,分屏模式等。 Opera Neon官网：http://www.opera.com/zh-cn/computer/neon Feast your eyes Engage your senses Free your mind Visual tabs and gravity Snap-to-gallery Split screen mode Video pop-out and player&nbsp; 首个版本的Opera Neon目前已经推出了以下内容： 浏览器的起始页面将会和电脑使用相同的背景，也就是浏览器起始页类似透明； 首个版本已经内置媒体播放器、图片库以及下载管理器，其位于浏览器左侧边栏； 在浏览器右侧的视觉化分页栏可以让用户更方便的辨识相关的标签页内容； 自动化管理标签页的智能系统，会将常用的标签页漂浮到上方、其他则沉到下方； 对于还有视频的网页可以将播放的视频弹出（这个似乎不少浏览器都有了）； 可以直接截取屏幕截图到图片库，用户可以在任何地方截图存储并方便上传； 双屏模式：可以让两个页面同时展示、开启和使用等等；Opera Neon属于概念浏览器且代表了Opera对未来浏览器的愿景，其不会取代现有的Opera浏览器，但其中的某些新功能也会被慢慢增添至Opera浏览器中。 目前该浏览器已支持Windows和Mac平台，有兴趣的用户可以下载测试版： 在线安装包： Opera Neon （国内下载较慢） 离线安装包： Opera Neon]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>浏览器</tag>
        <tag>Opera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS获取系统信息的Shell脚本]]></title>
    <url>%2Fposts%2F2017-01-11-getsysteminfobyshell%2F</url>
    <content type="text"><![CDATA[由于要监测服务器的运行状态，练手写了个简单的shell脚本。 大概实现了如下两个简单系统信息的展示： 功能一：获取操作系统的基本信息（内核、系统版本、网络地址等） 功能二：获取系统的运行状态（CPU负载、内存以及磁盘的使用率等） &nbsp; ########################################################################## #File Name:systemmonitor.sh #Author:Yuolvv #Blog:http://blog.iyu.pub ########################################################################## #!/bin/bash #把屏幕上的内容清空 clear if [[ $# -eq 0 ]] then echo -e '\E[33m'"#########################系统分析#########################" #定义一个高亮输出的变量 output=$(tput sgr0) #检查系统类型，使用uname -o命令 os=$(uname -o) echo -e '\E[32m'"系统类型:"$output $os #获取操作系统版本类型 #os_name=$(cat /etc/issue | grep -e "Server") #os_name=$(lsb_release -a | grep -e "Description") os_name=$(cat /etc/redhat-release) echo -e '\E[33m'"系统版本:"$output $os_name #获取CPU的指令集 os_bit=$(uname -m) echo -e '\E[34m'"系统位数:"$output $os_bit #获取内核版本 os_kernel=$(uname -r) echo -e '\E[35m'"内核版本:"$output $os_kernel #获取主机名￥hostname或者uname -n hostname=$(hostname) #获取内网IP inner=$(hostname -I) echo -e '\E[36m'"内网IP:"$output $inner #获取外网IP outer=$(curl -s http://ipecho.net/plain) echo -e '\E[29m'"外网IP:"$output $outer #获取DNS，从/etc/resolv.conf文件提取匹配 nameservers=$(cat /etc/resolv.conf | grep -E "\&lt;nameserver[ ]"+|awk '{print $NF}') echo -e '\E[31m'"系统DNS:"$output $nameservers #判断当前网络的连通性，直接使用ping命令测试 ping -c 2 www.ifeng.com &amp;&gt;/dev/null &amp;&amp; echo "网络连通:yes"||echo "网络连通:no" #检查当前登录的用户，使用who命令输出到一个临时文件中 who &gt;/tmp/who echo -e '\E[32m'"当前登录用户:"$output &amp;&amp; cat /tmp/who #命令输出后删除临时文件 rm -rf /tmp/who echo -e '\E[33m'"##########################################################" echo -e '\E[33m'"#########################运行状态#########################" #获取系统已经使用的内存，通过awk命令文本进行提取，然后计算出结果转换成MB system_men=$(awk '/MemTotal/{total=$2}/MemFree/{free=$2}END{print (total-free)/1024}' /proc/meminfo) echo -e '\E[36m'"系统使用内存:"$output $system_men"M" #获取应用使用内存，通过awk命令文本进行提取，然后计算出结果换算成MB app_men=$(awk '/MemTotal/{total=$2}/MemFree/{free=$2}/Cached/{cached=$2}/Buffers/{buffers=$2}END{print (total-free-cached-buffers)/1024}' /proc/meminfo) echo -e '\E[36m'"应用程序使用内存:"$output $app_men"M" #获取系统CPU负载 load_average=$(top -n 1 -b | grep "load average:" | awk '{print $12 $13 $14}') echo -e '\E[33m'"CPU负载:"$output $load_average #获取磁盘状况 disk=$(df -hP | grep -vE 'Filesystem|tmpfs'|awk '{print $1 "总量:"$2 "已使用:"$3 "使用率:"$5}') echo -e '\E[33m'"磁盘状况:"$output $disk echo -e '\E[33m'"##########################################################" else echo "shell脚本不能运行请联系我Email:1@iyu.pub" fi 代码浅显易懂，也加上了注释，这里就不逐行解释了。 代码的运行方法： 1.新建个sh文件systemmonitor.sh,把上面的代码复制进去。 或者使用wget命令： wget http://www.iyu.pub/fun/systemmonitor.sh 2.给文件执行的权限： chmod +x systemmonitor.sh 3.运行脚本： sh systemmonitor.sh 或者 ./systemmonitor.sh &nbsp; 好了，简单的分享就到这了。 &nbsp; &nbsp;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>脚本</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有道云笔记 去除左下角广告]]></title>
    <url>%2Fposts%2F2017-01-10-delyoudaoad%2F</url>
    <content type="text"><![CDATA[找到有道云笔记的安装路径，xxx\Youdao\YoudaoNote\theme\build.xml 用notepad++打开这个文件，根据type=”adpanel”找到如下代码： PanelAd type=&quot;adpanel&quot; css=&quot;public&quot; ass=&quot;mainform panelclient PanelAd&quot;&gt; &lt;panelTopLine type=&quot;panel&quot; css=&quot;AdPanel&quot; Dockstyle=&quot;top&quot; Bounds=&quot;0,0,0,1&quot;/&gt; &lt;MiddlePhotoPanel type=&quot;panel&quot; css=&quot;public&quot; DockStyle=&quot;top&quot; Bounds=&quot;0,0,250,160&quot; Margin=&quot;0,13,0,13&quot;&gt; &lt;AdPhoto type=&quot;photo&quot; css=&quot;Ad AdPhoto&quot; AnchorStyle=&quot;center&quot; AutoZoom=&quot;ZoomEqual&quot; Bounds=&quot;0,0,200,130&quot;&gt; &lt;AdClose type=&quot;button&quot; css=&quot;adclear&quot; AnchorStyle=&quot;topright&quot; Bounds=&quot;-1,1,24,24&quot; /&gt; &lt;AdText type=&quot;label&quot; css=&quot;AdText&quot; AnchorStyle=&quot;bottomleft&quot; Bounds=&quot;6,-6,25,10&quot;/&gt; &lt;/AdPhoto&gt; &lt;/MiddlePhotoPanel&gt; &lt;/PanelAd&gt; 修改上面的这段代码： （1）修改第2行： &lt;panelTopLine type=&quot;panel&quot; css=&quot;AdPanel&quot; Dockstyle=&quot;top&quot; Bounds=&quot;0,0,0,1&quot;/&gt; 改为： &lt;panelTopLine type=&quot;panel&quot; css=&quot;AdPanel&quot; Dockstyle=&quot;top&quot; Bounds=&quot;0,0,0,0&quot;/&gt; （2）修改第4行： &lt;AdPhoto type=&quot;photo&quot; css=&quot;Ad AdPhoto&quot; AnchorStyle=&quot;center&quot; AutoZoom=&quot;ZoomEqual&quot; Bounds=&quot;0,0,200,130&quot;&gt; 改为： &lt;AdPhoto type=&quot;photo&quot; css=&quot;Ad AdPhoto&quot; AnchorStyle=&quot;center&quot; AutoZoom=&quot;ZoomEqual&quot; Bounds=&quot;0,0,0,0&quot;&gt; 保存之后重启有道云笔记，就可以了。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>去广告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017元旦香港维多利亚港烟火表演]]></title>
    <url>%2Fposts%2F2017-01-01-newyear%2F</url>
    <content type="text"><![CDATA[2017的元旦，香港跨年！ 香港地标维多利亚港以“烟花音乐汇演”喜迎2017！ 烟花、烟火、灯光以及音乐在著名地标的衬托下，于维多利亚港上空交织绽放，共同迎接2017年的到来。 “六星连环”、“蝴蝶飞舞”、“20响礼炮鸣放” Youtube超清：https://www.youtube.com/embed/2QD9InOhd_Q 优酷超清：http://player.youku.com/embed/XMTg5NTMwNjcyNA==]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>香港</tag>
        <tag>烟火</tag>
        <tag>表演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【深圳】TOP 链接公益 • 移动技术年度盛典]]></title>
    <url>%2Fposts%2F2016-12-21-socialprogrammer%2F</url>
    <content type="text"><![CDATA[社会程序员技术改变生活，让信息的流通、人和人的连接、协作变得更加有效率；技术无边界，用技术做些公益的事情，能将温暖传递到更多角落。当技术遇上公益会产生怎样的【催化反应】？ 【T.O.P链接公益·移动技术年度盛典】由个推·云之讯·Ping++联合多家合作伙伴共同举办。 术业有专、成事有先—-T.O.P（Tech &amp; Organization &amp; Partner） 活动邀请到那些勇于探索移动新技术，实践新想法的领路者们，分享他们在产品技术实践上的见解与心得。 希望有更多的人加入“社会程序员”的行列，我们携手让技术赋能公益。 这是我上周末参加的一个活动，感触挺深的，在此分享给大家。 今天收到官方发布的录制视频，特此分享！ &nbsp; &nbsp; &nbsp; &nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>公益</tag>
        <tag>技术</tag>
        <tag>盛典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone6/6s变砖怎么办？]]></title>
    <url>%2Fposts%2F2016-12-16-iphone6-6s-wenti%2F</url>
    <content type="text"><![CDATA[今天作死的想更新下手机固件，结果成砖了。 搜索资料，发现如下两种方法： 第一种： 1将你的iPhone关机 2.同时按住开关机键和home键 3.当你看见白色的苹果logo时，请松开开关机键，并继续保持按住home键。 4.开启iTunes，等待其提示你进行恢复模式后，即可按住键盘上的shift键，点击“恢复”，选择相应的固件进行恢复。 第二种： 1.用USB线将iPhone连接上电脑，然后你将会听见电脑已连接成功的提示声音。 2.现在请先将iPhone关机，然后你将会听见电脑未连接成功的提示声音。 3.请同时按住开关机键和home键，持续到第10秒的时候，请立即松开开关键，并继续保持按住home键。 4.这个时候iTunes会自动启动，并提示你进行恢复模式(iPhone会一直保持黑屏状态)。那么你就可以按住键盘上的shift键，点击“恢复”，选择相应的固件进行恢复。 &nbsp; 作死感悟： No zuo no die 没有金刚钻别揽瓷器活，这句话说的真不错。 我是用第二种方法处理的，第一种不成功。 抹掉了所有数据，然而并没有备份。 滴，车翻了。。。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iPhone6</tag>
        <tag>iPhone6s</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果iOS App从2017年起强制使用HTTPS]]></title>
    <url>%2Fposts%2F2016-12-06-iosnews%2F</url>
    <content type="text"><![CDATA[苹果App于2017年1月1日将启用App Transport Security安全功能，即强制App通过HTTPS连接网络服务。 Apple Store强制使用HTTPS的原因 随着全球互联网安全意识的进一步觉醒，越来越多的公司意识到网络信息安全的重要性，只有绝对的加密才能保证在线交易和商务活动的安全进行。互联网无疑是个人信息和隐私泄露最频繁的场合，各种以窃取信息为方式而展开的网络犯罪是互联网发展所面临的最大挑战。在这样一个大环境下，苹果公司首先做出应对，强制所有App在2017年1月1日前使用HTTPS加密，这就意味着，如果您的APP如果仍采用HTTP传输，那么，在Apple Store中您的APP将不再能被用户下载使用。 App开发商将如何应对这一协议 早在2015年9月的WWDC15上，苹果公司就提出了ATS(App Transport Security)，所谓的ATS是一种新型加密技术-Forward Secrecy，要求应用与后台通讯必须使用最新的TLS1.2版本Https协议，以及所有Apple Store中的App必须使用SHA256算法的SSL/TLS证书。时隔一年多，这一协议还剩不到一个月的时间就要生效，还未安装SSL证书的App开发商们应该如何应对呢？ 以下几点至关重要： （1）必须选择好适用的SSL证书，这是部署HTTPS的第一步 （2）调整后台应用，实现后台应用全站HTTPS （3）选择正规的CA机构申请符合ATS要求的SSL证书]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>新闻</tag>
        <tag>iOS</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锤子手机发布会 相声]]></title>
    <url>%2Fposts%2F2016-10-19-chuizifabuhui%2F</url>
    <content type="text"><![CDATA[老罗单口相声专场10月18日，锤子科技在上海梅赛德斯-奔驰文化中心举行2016年度新品发布会，正式推出代号为SM901和SM919的两款手机新品。当然，发布会的主持人应该还是老罗本人，鉴于老罗幽默风趣的演讲风格，这是一年一度的罗永浩单口相声大会。 昨晚看到23点，心累。 这里贴上视频： &nbsp; 观后感： 亮点还是有几个的，老罗好像慢慢妥协了，情怀不再？]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>锤子</tag>
        <tag>发布会</tag>
        <tag>相声</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ表情昵称代码]]></title>
    <url>%2Fposts%2F2016-10-05-qqbiaoqingcode%2F</url>
    <content type="text"><![CDATA[仅供娱乐！ &nbsp; /wx /微笑 /pz /撇嘴 /se /色 /fd /发呆 /dy /得意 /ll /流泪 /hx /害羞 /bz /闭嘴 /shui /睡 /dk /大哭 /gg /尴尬 /fn /发怒 /tp /调皮 /cy /呲牙 /jy /惊讶 /ng /难过 /kuk /酷 /lengh /冷汗 /zk /抓狂 /tuu /吐 /tx /偷笑 /ka /可爱 /baiy /白眼 /am /傲慢 /jie /饥饿 /kun /困 /jk /惊恐 /lh /流汗 /hanx /憨笑 /db /大兵 /fendou /奋斗 /zhm /咒骂 /yiw(i) /疑问 /xu /嘘... /yun /晕 /zhem /折磨 /shuai /衰 /kl /骷髅 /qiao /敲打 /zj /再见 /ch /擦汗 /kb /抠鼻 /gz /鼓掌 /qd /糗大了 /huaix /坏笑 /zhh /左哼哼 /yhh /右哼哼 /hq /哈欠 /bs /鄙视 /wq /委屈 /kk /快哭了 /yx /阴险 /qq /亲亲 /xia /吓 /kel /可怜 /cd /菜刀 /xig /西瓜 /pj /啤酒 /lq /篮球 /pp /乒乓 /kf /咖啡 /fan /饭 /zt /猪头 /mg /玫瑰 /dx /凋谢 /sa /示爱 /xin /爱心 /xs /心碎 /dg /蛋糕 /shd /闪电 /zhd /炸弹 /dao /刀 /zq /足球 /pch /瓢虫 /bb /便便 /yl /月亮 /ty /太阳 /lw /礼物 /yb /拥抱 /qiang /强 /ruo /弱 /ws /握手 /shl /胜利 /bq /抱拳 /gy /勾引 /qt /拳头 /cj /差劲 /aini /爱你 /bu /不 /hd /好 /aiq /爱情 /fw /飞吻 /tiao /跳跳 /fad /发抖 /oh /怄火 /zhq /转圈 /kt /磕头 /ht /回头 /tsh /跳绳 /hsh /挥手 /jd /激动 /jw /街舞 /xw /献吻 /zuotj /左太极 /youtj /右太极]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QQ</tag>
        <tag>表情包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TingFirefox正式发布]]></title>
    <url>%2Fposts%2F2016-09-23-tingfirefox%2F</url>
    <content type="text"><![CDATA[一个月之前，TingChrome发布的时候就计划紧接着发布TingFirefox版本，但是一直拖着拖着，就这样拖了一个月。码农天生对Firefox情有独钟，怎能少得了？ Slogan： 你想要的一切，TingFirefox都会给你！TingFirefox 是基于 Firefox 制作的免费浏览器。 加强Firefox的标签页浏览功能 优化Firefox的启动速度 &nbsp; &nbsp; &nbsp; 责任声明本站仅仅提供一个观摩学习的环境，将不对本站提及的任何资源负法律责任。 如果您下载使用，表示您已经同意自己承担软件使用带来的一切后果！ &nbsp; 下载链接： http://browser.iyu.pub/ &nbsp; &nbsp;]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>浏览器</tag>
        <tag>Browser</tag>
        <tag>自研软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TingChrome 终于正式发布了]]></title>
    <url>%2Fposts%2F2016-08-29-tingchrome%2F</url>
    <content type="text"><![CDATA[千呼万唤，TingChrome终于发布了！！！ &nbsp; Slogan： 你想要的一切，TingChrome都会给你！&nbsp; TingChrome 是基于 Google Chrome 制作的免费浏览器。 集成过滤 视频广告、网页广告 等扩展 采用特殊的缓存技术加速网站的打开 &nbsp; &nbsp; 责任声明本站仅仅提供一个观摩学习的环境，将不对本站提及的任何资源负法律责任。 如果您下载使用，表示您已经同意自己承担软件使用带来的一切后果！ &nbsp; &nbsp; 下载链接： https://browser.iyu.pub/]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>浏览器</tag>
        <tag>Browser</tag>
        <tag>自研软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国FAST即将睁天眼：世界最大单口径望远镜]]></title>
    <url>%2Fposts%2F2016-07-25-fastelescope%2F</url>
    <content type="text"><![CDATA[&nbsp; 由中国研制和建设的世界最大单口径望远镜――500米口径球面射电望远镜(Five hundred meters Aperture Spherical Telescope，简称FAST)将于今年9月投入使用。该望远镜将被用于探索太空，可追寻地外生命尤其“外星人”(学名“地外智慧生命”)。 &nbsp; 这个被誉为“中国天眼”的FAST与号称“地面最大机器”的德国波恩100米射电望远镜相比，其灵敏度将提高约10倍;与被评为“人类20世纪10大工程”之首的美国阿雷西博305米射电望远镜相比，其综合性能提高约10倍。专家们认为它在今后二三十年时间内仍能保持世界一流地位。FAST可遥望百亿光年星际;这意味着，远在百亿光年外的射电信号，它也有可能“捕捉”到。 基于FAST的强大功能，如果银河系(直径约为15万光年)内存在外星人，他们的信息就很可能被发现。国际科研项目“搜寻外星人计划”(SETI)的首席科学家丹・沃西默最近向中方提出，希望在FAST加装设备，可合作搜索外星人信号。 寻找外星人是否对人类有威胁，对此问题学术界一直都有争论;半个世纪来，“外星人威胁论”比较流行。例如：1974年，阿雷西博射电望远镜向距离地球25000光年的球状星团M13发送无线电信号;诺贝尔物理奖得主、英国天文学家马丁・赖尔得知此事后，就给联合国写信极力反对人类主动与外星人建立联系;在他看来这些信息很可能会暴露地球人的存在，有可能招来杀身之祸。又如：英国进化生物学家西蒙・莫里斯2011年在《皇家学会哲学汇刊(A辑)》撰文指出：外星人的进化过程可能与达尔文理论本质上是一样的，这就意味着外星人可能很像我们人类;毫不掩盖地说，他们甚至可能也拥有暴力倾向。 有“当代宇宙大王”之称的英国物理学家史蒂芬・霍金2012年在接受英国广播公司(BBC)记者采访时更是语出惊人：“宇宙中存在外星人，地球人试图与他们交流是非常危险的;如果外星人决定来拜访我们，那么结果可能和当年欧洲人到达美洲一样，美洲原住民并没有得到什么好处;外星人如果威胁地球人，其主要目的是掠夺地球上的资源。”不知道什么原因，霍金去年却与俄罗斯风险投资家尤里・米尔纳共同领导着一个名为“突破聆听”(The Breakthrough Listen)的寻找外星人项目。有趣的是，最近美国脸书创始人马克・扎克伯格也加入了这项寻找外星人的伟大事业中。 然而，一些科学家并不同意“外星人威胁论”。他们从外星人的智慧与科技，甚至是人类自身对外星人的心理作用来说明外星人对地球人并不构成威胁。中国科学家及未来学家周海中就是这一观点的拥护者。他1999年在《科学美国人(中文版)》撰文指出：担心外星人威胁是完全没有必要的，因为只要是高级智慧生命，他们的理智在决定着他们必须有分寸地对待其他智慧生命体;外星人与地球人将来是能够和平共处、友好合作和共同发展的。 无独有偶，美国天文学家大卫・莫里森2011年在接受英国《新科学家》记者采访时也表示：如果一颗距离地球数百或者数千光年的行星发出的无线电信号被我们接收到，这个文明的先进程度一定超过人类;如果一个文明能够存在数十万年，它一定能解决我们面临的一系列问题，所以没有必要掠夺地球上的资源。他风趣地说：“如果外星人来访，我会好好款待他们。” 毫无疑问，FAST投入使用后，研究人员将得以继续探寻地外生命尤其外星人。如果能找到外星人，那将是人类历史上最伟大的发现;届时，我们可邀请远方的外星人朋友来相会，共商发展大计，共谋合作愿景。 &nbsp; &nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Fast</tag>
        <tag>望远镜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑苹果常见问题]]></title>
    <url>%2Fposts%2F2016-03-22-blackapple-wenti%2F</url>
    <content type="text"><![CDATA[由于经常系统升级，反复出现一些问题，特地整理下并记录下来。 1.修改显存从512MB到1GB的按顺序执行以下4行代码： cd /S*/L*/Ext*/AppleIntelSNBGraphicsFB.kext/C*/M* sudo cp AppleIntelSNBGraphicsFB AppleIntelSNBGraphicsFB.backup sudo perl -pi -e 's|\xC7\x45\xBC\x00\x00\x00\x20|\xc7\x45\xBC\x00\x00\x00\x40|g' AppleIntelSNBGraphicsFB sudo touch /S*/L*/Extensions 2.修复开机正常亮度和VGA HDMI： sudo perl -pi -e 's|\x01\x02\x04\x00\x10\x07\x00\x00\x10\x07\x00\x00\x05\x03\x00\x00\x02\x00\x00\x00\x30\x00\x00\x00\x02\x05\x00\x00\x00\x04\x00\x00\x07\x00\x00\x00\x03\x04\x00\x00\x00\x04\x00\x00\x09\x00\x00\x00\x04\x06\x00\x00\x00\x04\x00\x00\x09\x00\x00\x00|\x01\x02\x03\x00\x12\x13\x00\x00\x12\x13\x00\x00\x05\x03\x00\x00\x02\x00\x00\x00\x30\x00\x00\x00\x02\x05\x00\x00\x00\x08\x00\x00\x06\x00\x00\x00\x06\x02\x00\x00\x01\x00\x00\x00\x09\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00|g' /System/Library/Extensions/AppleIntelSNBGraphicsFB.kext/Contents/MacOS/AppleIntelSNBGraphicsFB 修复权限重建缓存（很重要，防止不能进系统了，可以用Kext Utility修复），然后删除系统盘Extra/Extensions中的驱动（一定要删除，防止冲突），再重启（提前重启你就进不去了）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Apple</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress整站迁移]]></title>
    <url>%2Fposts%2F2015-12-21-wordpressqianyi%2F</url>
    <content type="text"><![CDATA[**wordpress整站迁移步骤：** 1、备份数据库。用数据库备份工具备份老站的mysql数据库(.sql) 2、备份wordpress网站程序。 3、新建mysql数据库，利用数据库备份工具，导入原来网站的.sql的数据库备份文件。 4、将第2步中，原来的网站程序上传到新网站下。 5、删除网站根目录下的wp数据库配置文件wp-config.php，然后在浏览器中输入网站域名访问，安装wordpress。 至此，网站完美迁移成功。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
        <tag>网站搬家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取音乐mp3外链的方法]]></title>
    <url>%2Fposts%2F2015-12-09-getmp3link%2F</url>
    <content type="text"><![CDATA[记得以前经常在鹅厂的空间添加背景音乐，一开始用的是百度音乐外链，后来封了。 今天在写页面的时候，寻找音乐外链。 因为是网易云音乐的脑残粉，就试着抓下网易云音乐的外链。 外链接口： http://music.163.com/api/song/detail/?id=歌曲ID&amp;ids=%5B歌曲ID%5D&amp;csrf_token= （只要把上面链接中的“歌曲ID”换成歌曲的链接中的ID就行） &nbsp; For example： 朴树的“且听风吟”：http://music.163.com/#/song?id=139359 将”id=139359”中的“139359”替换到上面的外链中 即： http://music.163.com/api/song/detail/?id=139359&amp;ids=%5B139359%5D&amp;csrf_token= 在浏览器上打开，可以得到一个json &nbsp; 到这里，你应该会发现 mp3的外链吧。不错，就是”mp3Url“后面的，即： "mp3Url":"http://m2.music.126.net/Z3kPN3AAQFUd3WbiZtQgKQ==/7943971512260105.mp3" &nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>mp3</tag>
        <tag>音乐</tag>
        <tag>外链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat配置WebService]]></title>
    <url>%2Fposts%2F2015-12-02-tomcat-webservice%2F</url>
    <content type="text"><![CDATA[1.下载jax-ws依赖包 http://jax-ws.java.net 2.将jaxws-RI\lib下的包复制到tomcat\shared\lib下 3.编辑conf\catalina.properties 找到common.loader配置项，增加${catalina.home}/shared/lib/*.jar,${catalina.home}/shared/lib 路径]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12306抢票软件大搜罗]]></title>
    <url>%2Fposts%2F2015-12-01-12306soft%2F</url>
    <content type="text"><![CDATA[搜罗了如下的抢票软件： （1）12306.net 软件分享：http://yunpan.cn/c3ScEk7YEw6cG 访问密码 e59b （2）12306Bypass分流抢票软件 软件分享：http://yunpan.cn/c3Sc2btNE4wZz 访问密码 bc76 （3）猎豹抢票大师 软件分享：http://yunpan.cn/c3Vq8prQGZeTj 访问密码 81e0 （4）百度抢票专版 软件分享：http://yunpan.cn/c3VqtqdvR69QU 访问密码 4da7 （5）QQ抢票专版 软件分享：http://yunpan.cn/c3VqXFe5diUsB 访问密码 1081 （6）搜狗抢票专版 软件分享：http://yunpan.cn/c3VPSeJdxRmKx 访问密码 9e3b 若使用搜狗抢票专版，可以使用搜狗预约抢票，挺不错的功能！ 网址：http://mse.sogou.com/yuepiao]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>12306</tag>
        <tag>抢票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String和ByteBuffer互转]]></title>
    <url>%2Fposts%2F2015-11-05-string-bytebuffer%2F</url>
    <content type="text"><![CDATA[String 转换 ByteBuffer： //String 转换 ByteBuffer public static ByteBuffer getByteBuffer(String str) { return ByteBuffer.wrap(str.getBytes()); } ByteBuffer 转换 String： //ByteBuffer 转换 String public static String getString(ByteBuffer buffer) { Charset charset = null; CharsetDecoder decoder = null; CharBuffer charBuffer = null; try { charset = Charset.forName("UTF-8"); decoder = charset.newDecoder(); //用这个的话，只能输出来一次结果，第二次显示为空 // charBuffer = decoder.decode(buffer); charBuffer = decoder.decode(buffer.asReadOnlyBuffer()); return charBuffer.toString(); } catch (Exception ex) { ex.printStackTrace(); return "error"; } }]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 自动备份mysql并加入定时任务]]></title>
    <url>%2Fposts%2F2015-10-27-shell-mysql-backup%2F</url>
    <content type="text"><![CDATA[1.使用mysqldump备份MySQL数据库 新建一个shell文件 touch backup.sh 编辑shell文件 vi backup.sh 输入下列内容： #!/bin/bash mysqldump --opt -uuser -ppassword | gzip &gt; /mysqlbackup/mysql`date +%Y-%m-%d_%H%M%S`.sql.gz #删除超过7天的备份数据，保留3个月里的 10号 20号 30号的备份数据 find /mysqlbackup/ -name "*[1-9].sql.gz" -type f -mtime +7 -exec rm -rf {} \; &gt; /dev/null 2&gt;&amp;1 #删除超过3个月的所有备份数据 find /mysqlbackup/ -name "*.sql.gz" -type f -mtime +92 -exec rm -rf {} \; &gt; /dev/null 2&gt;&amp;1 2.修改文件属性，使其可执行 chmod +x /mysqlbackup/backup.sh 3.加入定时任务 编辑/etc/crontab vi /etc/crontab 添加如下代码： # m h dom mon dow user command 30 01 * * 0 root /mysqlbackup/backup.sh 这样表示每个周日的上午1点30分执行shell文件 4.重新启动crond使设置生效 service cron stop #停止 service cron start #启动 /etc/init.d/cron restart #重启]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>CentOS</tag>
        <tag>Fedora</tag>
        <tag>shell</tag>
        <tag>脚本</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inno Setup 5.5版本中文语言包]]></title>
    <url>%2Fposts%2F2015-10-19-inno-setup-zh%2F</url>
    <content type="text"><![CDATA[; *** Inno Setup version 5.5.0+ Chinese messages *** ; ; To download user-contributed translations of this file, go to: ; http://www.jrsoftware.org/is3rdparty.php ; ; Note: When translating this text, do not add periods (.) to the end of ; messages that didn't have them already, because on those messages Inno ; Setup adds the periods automatically (appending a period would result in ; two periods being displayed). [LangOptions] ; The following three entries are very important. Be sure to read and ; understand the '[LangOptions] section' topic in the help file. LanguageName=Chinese LanguageID=$0409 LanguageCodePage=0 ; If the language you are translating to requires special font faces or ; sizes, uncomment any of the following entries and change them accordingly. ;DialogFontName= ;DialogFontSize=8 ;WelcomeFontName=Verdana ;WelcomeFontSize=12 ;TitleFontName=Arial ;TitleFontSize=29 ;CopyrightFontName=Arial ;CopyrightFontSize=8 [Messages] ; *** Application titles SetupAppTitle=安装 SetupWindowTitle=安装 - %1 UninstallAppTitle=反安装 UninstallAppFullTitle=%1 反安装 ; *** Misc. common InformationTitle=安装信息 ConfirmTitle=提示 ErrorTitle=错误 ; *** SetupLdr messages SetupLdrStartupMessage=现在将安装 %1。是否继续? LdrCannotCreateTemp=不能创建临时文件。安装中止！ LdrCannotExecTemp=不能在临时目录中解压文件，安装过程中止！ ; *** Startup error messages LastErrorMessage=%1.%n%n 错误 %2: %3 SetupFileMissing=在安装目录中找不到文件 %1 。请更正该问题或者获得一个新的文件。 SetupFileCorrupt=安装文件被占用。请获得一个新的安装文件。 SetupFileCorruptOrWrongVer=安装文件被占用, 或者安装文件的版本不对。请更正该问题或者获得一个新文件。 NotOnThisPlatform=该程序不能在 %1 下运行。 OnlyOnThisPlatform=该程序必须在 %1 下运行。 OnlyOnTheseArchitectures=该程序只能在以下WINDOWS版本下运行:%n%n%1 MissingWOW64APIs=该版本需要64位的安装程序。要更正该问题，请安装 Service Pack %1。 WinVersionTooLowError=该软件需要 %1 版本号 %2 或者更高。 WinVersionTooHighError=该软件不能在 %1 版本号 %2 或者更高版本中安装。 AdminPrivilegesRequired=您在安装该程序时必须是管理员权限。 PowerUserPrivilegesRequired=您在安装程序是必须是管理员权限或者高权限用户权限。 SetupAppRunningError=安装程序检测到 %1 正在运行。%n%n请关闭它的所有实例。然后单击“确认”继续安装，或者单击“取消”退出。UninstallAppRunningError=反安装程序检测到 %1 正在运行。%n%n请关闭它的所有实例。然后单击“确认”继续安装，或者单击“取消”退出。 UninstallAppRunningError=Uninstall has detected that %1 is currently running.%n%nPlease close all instances of it now, then click OK to continue, or Cancel to exit. InvalidParameter=命令行中包含无效的参数:%n%n%1 SetupAlreadyRunning=安装程序已经运行. WindowsVersionNotSupported=该程序不支持当前的Windows版本. WindowsServicePackRequired=该程序要求 %1 Service Pack %2 或者更高版本. ; *** Misc. errors ErrorCreatingDir=安装程序不能创建目录 "%1" ErrorTooManyFilesInDir=不能在目录"%1" 下创建文件。因为该目录下有太多的文件了。 ; *** Setup common messages ExitSetupTitle=退出安装 ExitSetupMessage=安装还未完成。如果现在退出，程序将结束安装。%n%n您可以在下次继续安装。%n%n退出安装？ AboutSetupMenuItem=关于安装程序[&A]... AboutSetupTitle=关于安装程序 AboutSetupMessage=%1 版本 %2%n%3%n%n%1 主页:%n%4 AboutSetupNote= TranslatorNote= ; *** Buttons ButtonBack=< 上一步[&B] ButtonNext=下一步[&N] > ButtonInstall=安装[&I] ButtonOK=确认 ButtonCancel=取消 ButtonYes=市[&Y] ButtonYesToAll=全部确认[&A] ButtonNo=否[&N] ButtonNoToAll=全部否认[&o] ButtonFinish=完成[&F] ButtonBrowse=浏览[&B]... ButtonWizardBrowse=浏览[&r]... ButtonNewFolder=新建文件夹[&M] ; *** "Select Language" dialog messages SelectLanguageTitle=选择安装语言种类 SelectLanguageLabel=选择该语言作为安装语言: ; *** Common wizard text ClickNext=单击“下一步”继续，或者单击“取消”退出本安装程序。 BeveledLabel= BrowseDialogTitle=浏览文件夹 BrowseDialogLabel=在下面的列表中选择一个目录, 然后单击“确认”继续。 NewFolderName=新文件夹 ; *** "Welcome" wizard page WelcomeLabel1=欢迎进入 [name] 安装向导 WelcomeLabel2=将在您的电脑上安装 [name/ver] 。%n%n建议在继续安装之前先退出其它运行的程序。 ; *** "Password" wizard page WizardPassword=密码 PasswordLabel1=本安装程序受密码保护。 PasswordLabel3=请输入密码，密码区分大小写。然后单击“下一步”继续。 PasswordEditLabel=密码[&P]: IncorrectPassword=输入的密码不正确，请重新输入。 ; *** "License Agreement" wizard page WizardLicense=用户许可协议 LicenseLabel=请在继续之前仔细阅读用户许可协议。 LicenseLabel3=请仔细阅读下面的用户许可协议。在继续安装之前，您必须接受该协议。 LicenseAccepted=我接受协议[&a]。 LicenseNotAccepted=我不接受协议[&d] ; *** "Information" wizard pages WizardInfoBefore=提示 InfoBeforeLabel=在继续安装之前请仔细阅读以下重要的信息。 InfoBeforeClickLabel=当您准备好继续安装时，单击“继续”。 WizardInfoAfter=信息 InfoAfterLabel=在继续安装之前请仔细阅读以下重要的信息。 InfoAfterClickLabel=当您准备好继续安装时，单击“继续”。 ; *** "User Information" wizard page WizardUserInfo=用户信息 UserInfoDesc=请输入您的信息。 UserInfoName=用户名[&U]: UserInfoOrg=组织[&O]: UserInfoSerial=序列号[&S]: UserInfoNameRequired=您必须输入一个名称。 ; *** "Select Destination Location" wizard page WizardSelectDir=选择目标位置 SelectDirDesc=您将把[name]安装在哪里? SelectDirLabel3=安装程序将把[name]安装在下面的文件夹中。 SelectDirBrowseLabel=继续安装, 请单击“下一步”。如果需要选择其它目录，请单击“浏览”。 DiskSpaceMBLabel=为了安装本软件，至少需要 [mb] MB 的空闲磁盘空间。 InvalidPath=您比如输入一个含盘符的路径名称。比如:%n%nC:\APP%n%n 或者一个网络路径，例如:%n%n\\server\share InvalidDrive=您选择的磁盘或者网络路径不存在或者不能访问。请重新选择其它的磁盘或者网络路径。 DiskSpaceWarningTitle=磁盘空间不足。 DiskSpaceWarning=安装程序至少需要 %1 KB 空闲磁盘空间来安装本软件。但是选择的磁盘上只有 %2 KB 空间可用。%n%n 您确认继续？ DirNameTooLong=该文件夹的名称太长。 InvalidDirName=该文件夹的名字太长。 BadDirName32=文件夹名称中不能包括以下的任何字符:%n%n%1 DirExistsTitle=文件夹已经存在 DirExists=文件夹:%n%n%1%n%n已经存在。您想继续安装? DirDoesntExistTitle=文件夹不存在 DirDoesntExist=文件夹:%n%n%1%n%n不存在。您想创建该文件夹? CannotInstallToNetworkDrive=程序不能被安装到网络磁盘上. CannotInstallToUNCPath=程序不能被安装到一个 UNC 路径上. ; *** "Select Components" wizard page WizardSelectComponents=选择组件 SelectComponentsDesc=哪些组件需要安装? SelectComponentsLabel2=选择您想要安装的组件; 去掉您不想安装的组件。当您准备好后，请单击“下一步” 。 FullInstallation=完全安装 ; if possible don't translate 'Compact' as 'Minimal' (I mean 'Minimal' in your language) CompactInstallation=精简安装 CustomInstallation=自定义安装 NoUninstallWarningTitle=组件存在 NoUninstallWarning=安装程序检测到以下组件已经被安装到您的电脑中:%n%n%1%n%n不选择它们将不在您的电脑中安装。%n%n您想这样继续吗? ComponentSize1=%1 KB ComponentSize2=%1 MB ComponentsDiskSpaceMBLabel=当前选择项至少需要 [mb] MB 的空闲磁盘空间才能安装。 ; *** "Select Additional Tasks" wizard page WizardSelectTasks=选择附加任务 SelectTasksDesc=您想选择哪个附加任务? SelectTasksLabel2=选择在安装[name]时执行的附加任务后单击“下一步”。 ; *** "Select Start Menu Folder" wizard page WizardSelectProgramGroup=选择开始菜单文件夹 SelectStartMenuFolderDesc=您想在哪里放置软件的快捷方式? SelectStartMenuFolderLabel3=安装程序将在下面的文件夹中创建软件的快捷方式。 SelectStartMenuFolderBrowseLabel=继续安装，请单击“下一步”。如果您想选择其它文件夹，单击“浏览”。 MustEnterGroupName=您必须输入一个文件夹名称。 GroupNameTooLong=文件夹名称或者路径名称太长。 InvalidGroupName=文件夹名称非法。 BadGroupName=文件夹名字中不能包含下面的字符:%n%n%1 NoProgramGroupCheck2=不创建开始菜单中的文件夹[&D] ; *** "Ready to Install" wizard page WizardReady=准备开始安装 ReadyLabel1=安装程序开始在您的电脑中安装[name]. ReadyLabel2a=单击“安装”开始安装本软件,或者单击“上一步”修改安装设置。 ReadyLabel2b=单击“安装”开始安装本软件。 ReadyMemoUserInfo=用户信息: ReadyMemoDir=安装目标位置: ReadyMemoType=安装种类: ReadyMemoComponents=选中的组件: ReadyMemoGroup=开始菜单文件夹: ReadyMemoTasks=附加任务: ; *** "Preparing to Install" wizard page WizardPreparing=准备安装 PreparingDesc=安装程序准备在您的电脑中安装[name]。 PreviousInstallNotCompleted=安装/反安装一个以前的程序没有完成。您需要重新启动您的电脑来完成安装工作。%n%n当重新启动您的电脑后，请运行安装程序来完成安装[name]。 CannotContinue=安装程序不能继续执行。请单击“取消”退出。 ;ApplicationsFound=The following applications are using files that need to be updated by Setup. It is recommended that you allow Setup to automatically close these applications. ApplicationsFound=需要被安装程序更新的文件正被以下应用程序使用。建议由安装程序自动结束这些应用程序。 ;ApplicationsFound2=The following applications are using files that need to be updated by Setup. It is recommended that you allow Setup to automatically close these applications. After the installation has completed, Setup will attempt to restart the applications. ApplicationsFound2=需要被安装程序安装的文件正在被以下应用程序使用。建议由安装程序自动结束这些应用程序。当安装完成后，将会尝试重启这些应用程序。 CloseApplications=&Automatically close the applications DontCloseApplications=&Do not close the applications ; *** "Installing" wizard page WizardInstalling=安装中 InstallingLabel=安装程序正在安装[name],请等待。 ; *** "Setup Completed" wizard page FinishedHeadingLabel=[name]安装完成 FinishedLabelNoIcons=安装程序已经在您的电脑中安装了[name]。 FinishedLabel=安装程序已经成功在您的电脑上安装了[name]。如果需要执行，请单击本软件图标。 ClickFinish=单击“完成”退出本安装程序. FinishedRestartLabel=为了完成[name]的安装, 安装程序必须重新启动您的电脑。您想现在就重新启动吗? FinishedRestartMessage=为了完成[name]的安装, 安装程序必须重新启动您的电脑。%n%您想现在就重新启动吗? ShowReadmeCheck=是的,我想查看 README 文件 YesRadio=是的，我想重新启动计算机[&Y] NoRadio=不，我将稍后重新启动计算机[&N] ; used for example as 'Run MyProg.exe' RunEntryExec=运行 %1 ; used for example as 'View Readme.txt' RunEntryShellExec=查看 %1 ; *** "Setup Needs the Next Disk" stuff ChangeDiskTitle=安装程序需要下一个安装盘 SelectDiskLabel2=请插入安装盘 %1 并且单击“确认”。%n%n如果该盘不是下面显示的盘，请输入正确的路径或者单击“浏览”。 PathLabel=目录[&P]: FileNotInDir2=在 "%2" 中没有发现文件。请插入正确的磁盘或者选择其它的文件夹。 SelectDirectoryLabel=请输入下一个磁盘中的正确位置。 ; *** Installation phase messages SetupAborted=安装没有完成。%n%n请修复错误并重新安装。 EntryAbortRetryIgnore=单击“重试”重新尝试，单击“忽略”将继续安装，或者单击“取消”退出安装。 ; *** Installation status messages StatusCreateDirs=创建目录中... StatusExtractFiles=解压文件中... StatusCreateIcons=创建快捷方式中... StatusCreateIniEntries=创建INI单元中... StatusCreateRegistryEntries=创建注册表内容中... StatusRegisterFiles=注册文件中... StatusSavingUninstall=保存反安装信息中... StatusRunProgram=正在完成安装... StatusRollback=恢复原来修改的内容中... StatusClosingApplications=正在关闭应用程序... StatusRestartingApplications=正在重启应用程序... ; *** Misc. errors ErrorInternal2=内部错误: %1 ErrorFunctionFailedNoCode=%1 失败 ErrorFunctionFailed=%1 失败; 代码 %2 ErrorFunctionFailedWithMessage=%1 错误; 代码 %2.%n%3 ErrorExecutingProgram=不能执行文件:%n%1 ; *** Registry errors ErrorRegOpenKey=在打开注册表键时发生错误:%n%1\%2 ErrorRegCreateKey=在创建注册表键时发生错误:%n%1\%2 ErrorRegWriteKey=在些注册表键时发生错误:%n%1\%2 ; *** INI errors ErrorIniEntry=在创建INI文件时发生错误 "%1". ; *** File copying errors FileAbortRetryIgnore=单击“重试”再试一次，单击“忽略”忽略该文件，或者单击“取消”退出安装程序。 FileAbortRetryIgnore2=单击“重试”再试一次，单击“忽略”忽略该文件继续安装，或者单击“取消”退出安装程序。 SourceIsCorrupted=源文件被使用 SourceDoesntExist=源文件 "%1" 不存在 ExistingFileReadOnly=该已经存在的文件是只读属性。%n%n单击“重试”删除只读属性并重新尝试，单击“忽略”忽略该文件，或者单击“取消”退出安装程序。 ErrorReadingExistingDest=当试图读取一个已经存在的文件时发生了错误: FileExists=该文件已经存在。%n%n您想覆盖它吗? ExistingFileNewer=已经存在的文件比安装程序试图安装的文件要新。建议您保留该文件。%n%n您想保留已经存在的文件吗? ErrorChangingAttr=当试图改变一个存在的文件的属性时发生了错误: ErrorCreatingTemp=当试图在目标目录中创建一个文件时发生了错误: ErrorReadingSource=当试图读取一个文件时发生了错误: ErrorCopying=当试图复制一个文件时发生了错误: ErrorReplacingExistingFile=当试图覆盖已经存在的文件时发生错误: ErrorRestartReplace=重新启动置换失败: ErrorRenamingTemp=当在目标目录中重命名文件时发生错误: ErrorRegisterServer=不能注册 DLL/OCX: %1 ErrorRegSvr32Failed=RegSvr32 执行失败, 错误码: %1 ErrorRegisterTypeLib=不能注册以下类型库: %1 ; *** Post-installation errors ErrorOpeningReadme=当打开 README 文件时发生错误。 ErrorRestartingComputer=安装程序不能重新启动电脑。请手动启动。 ; *** Uninstaller messages UninstallNotFound=文件 "%1" 不存在。不能反安装。 UninstallOpenError=文件 "%1" 不能打开。不能反安装。 UninstallUnsupportedVer=反安装记录文件 "%1" 不是基于本安装程序的版本。不能完成软件的删除工作。 UninstallUnknownEntry=一个未知的实体 (%1) 存在于反安装记录文件中。 ConfirmUninstall=您确定完全删除 %1 和相关组件吗? UninstallOnlyOnWin64=该安装程序只能在64位的Windows上执行反安装工作。 OnlyAdminCanUninstall=该安装程序只能在您具有管理员权限时才能执行反安装工作。 UninstallStatusLabel= %1 正在被删除，请稍等。 UninstalledAll=%1 被成功地从您的电脑中删除。 UninstalledMost=%1 删除完成。%n%n有某些组件无法被删除。您可能需要手动删除它们。 UninstalledAndNeedsRestart=为了完成 %1 的删除工作, 您必须重新启动电脑。%n%n您想现在就重新启动吗? UninstallDataCorrupted=文件"%1" 被占用。不能完成删除工作。 ; *** Uninstallation phase messages ConfirmDeleteSharedFileTitle=删除共享程序文件? ConfirmDeleteSharedFile2=系统指出以下的共享程序文件将不再被使用。您是否想删除这些共享文件?%n%n如果这些文件删除后，其他程序仍然要使用它，可能其它程序的功能将受影响。如果您不能肯定，请选择“否”。让这些文件保留在系统中不会对系统造成损害。 SharedFileNameLabel=文件名: SharedFileLocationLabel=位置: WizardUninstalling=反安装 StatusUninstalling=反安装 %1 中... ; *** Shutdown block reasons ShutdownBlockReasonInstallingApp=安装 %1. ShutdownBlockReasonUninstallingApp=卸载 %1. ; The custom messages below aren't used by Setup itself, but if you make ; use of them in your scripts, you'll want to translate them. [CustomMessages] NameAndVersion=%1 版本 %2 AdditionalIcons=附加图标: CreateDesktopIcon=创建桌面图标[&d] CreateQuickLaunchIcon=创建快速启动图标[&Q] ProgramOnTheWeb=%1 on the Web UninstallProgram=反安装 %1 LaunchProgram=执行 %1 AssocFileExtension=用文件扩展名 %2 匹配[&A] %1? AssocingFileExtension=正在用文件扩展名 %2 匹配[&A] %1 中...]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>InnoSetup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux使用tomcat做下载服务器]]></title>
    <url>%2Fposts%2F2015-10-15-linux-tomcat-download%2F</url>
    <content type="text"><![CDATA[tomcat的安装就不赘述了。 1.进入tomcat的如下目录： /tomcat7/conf/Catalina/localhost 2.新建一个xml文件 我这里在做APP的自动更新，所以就新建一个app.xml如下： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;Context path=”/app” reloadable=”true” docBase=”/appupdate” crossContext=”true”&gt; &lt;/Context&gt; 说明：/app为通过ip地址访问的虚拟目录，它被指向/appupdate 3.编辑tomcat下conf/web.xml 找到如下代码： &nbsp; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &nbsp; 将 默认的 &lt;param-value&gt;false&lt;/param-value&gt;改为 &lt;param-value&gt;true&lt;/param-value&gt; 结果如下所示： &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; 4.重启Tomcat service tomcat restart 5.访问文件： 访问：http://域名:8080/app/ 就可以看到目录下的文件了。 &nbsp; &nbsp; &nbsp;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Fedora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat的catalina.out日志的cronolog分割]]></title>
    <url>%2Fposts%2F2015-09-28-tomcat-catalina-out%2F</url>
    <content type="text"><![CDATA[由于最近的项目使用了tomcat应用服务器，产生的日志文件挺大的，主要是调试中打印的一些信息占空间，比如说System.out和log等等。tomcat 的catalina.out文件的不断扩大，导致系统磁盘空间边变小，所以想到了cronolog工具。 2018.01.19修改： 1.重新上传文件 2.修改图片的显示 安装过程如下： 1、下载 wget https://src.fedoraproject.org/repo/pkgs/cronolog/cronolog-1.6.2.tar.gz/a44564fd5a5b061a5691b9a837d04979/cronolog-1.6.2.tar.gz 本来想直接wget的，但是经过测试好像压缩包有问题，之后只能在本地下载再scp到服务器。 贴上我的分享：点我下载 2、解压缩 # tar zxvf cronolog-1.6.2.tar.gz &nbsp; 3、进入cronolog安装文件所在目录 # cd cronolog-1.6.2 &nbsp; 4、运行安装 # ./configure # make # make install &nbsp; 5、查看cronolog安装后所在目录（验证安装是否成功） # which cronolog 正常情况下显示： /usr/local/sbin/cronolog &nbsp; 要想分割tomcat的catalina.out，需作如下工作： Tomcat7以前的版本： （1）注释掉（#） touch “$CATALINA_BASE”/logs/catalina.out （2）修改tomcat bin目录下的catalina.sh文件中的两处 org.apache.catalina.startup.Bootstrap "$@" start \ >> "$CATALINA_BASE" /logs/catalina.out 2>&1 & 为 org.apache.catalina.startup.Bootstrap "$@" start 2>&1 \ | /usr/local/sbin/cronolog "$CATALINA_BASE" /logs/catalina.%Y-%m-%d.out >> /dev/null & 如下图所示： 完成之后重起Tomcat就可以了。 隔天看logs文件中是否有catalina.2015-09-13.out样式的日志。 &nbsp; Tomcat7以后的版本： 1 第一步 将 if [ -z "$CATALINA_OUT" ] ; then CATALINA_OUT=”$CATALINA_BASE”/logs/catalina.out fi 修改为 if [ -z "$CATALINA_OUT" ] ; then CATALINA_OUT=”$CATALINA_BASE”/logs/catalina.out.%Y-%m-%d fi 2 第二步 将 touch "$CATALINA_OUT" 改为 #touch "$CATALINA_OUT" 3 第三步 将 org.apache.catalina.startup.Bootstrap "$@" start \ >> "$CATALINA_OUT" 2>&1 "&" 修改为 org.apache.catalina.startup.Bootstrap "$@" start 2>&1 \ | /usr/local/sbin/cronolog "$CATALINA_OUT" >> /dev/null & 完成之后重起Tomcat就可以了。 隔天看logs文件中是否有catalina.out.2015-09-13样式的日志。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>Ubuntu</tag>
        <tag>Tomcat</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装Tomcat]]></title>
    <url>%2Fposts%2F2015-09-18-ubuntu-tomcat%2F</url>
    <content type="text"><![CDATA[一、下载tomcat (1)方法一：先下载到本地，然后ftp上传到服务器 官方 Apache Tomcat 的下载页面： http://tomcat.apache.org/download-70.cgi (2)方法二：直接在服务器下载（windows版本的区分32位与64位，ubuntu（linux）版本的不区分） http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.64/bin/apache-tomcat-7.0.64.tar.gz (3)方法三：去我的云盘下载 https://yunpan.cn/c6kfTbwPQxRSb 访问密码 ce9c &nbsp; 二、解压安装 先解压 tar zxvf apache-tomcat-7.0.64.tar.gz -C /java 然后改名为tomcat7 ca /java mv apache-tomcat-7.0.64 tomcat7 更改用户 cd /java/tomcat7 chown -R root . chgrp -R root . **三、配置环境变量** vi /etc/profile 在最后面加上如下两句 CATALINA_HOME=/java/tomcat7 export CATALINA_HOME保存后退出vi 刷新变量使配置立即生效 source /etc/profile 进入tomcat的bin目录 cd $CATALINA_HOME/bin 或者: cd /java/tomcat7/bin 修改catalina.sh vi catalina.sh 找到如下这行 # OS specific support. $var _must_ be set to either true or false. 在这行下面新增如下配置语句 指定tomcat的目录以及jdk的目录 CATALINA_HOME=/java/tomcat7 JAVA_HOME=/java/jdk7 保存后退出vi 尝试下启动tomcat是否成功 在tomcat下的bin目录下直接运行startup.sh sh startup.sh 或者 ./startup.sh 四、安装tomcat服务 当前所在目录是tomcat的bin目录 cp catalina.sh /etc/init.d/tomcat 让tomcat在服务器启动时就启动，配置以下语句 update-rc.d -f tomcat defaults 这样就可以用service启动tomcat了： service tomcat start 关闭tomcat: service tomcat stop 五、查看tomcat日志 cd进入tomcat下的logs目录 即/java/tomcat7/logs 关于日志的切割问题，可以查看我的另外一篇博客：Tomcat的catalina.out日志的cronolog分割 tail -f catalina.out ok，到这里，tomcat就安装完毕了。 &nbsp;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaEE</tag>
        <tag>Ubuntu</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git配置多个SSH-Key]]></title>
    <url>%2Fposts%2F2015-09-17-git-ssh-key%2F</url>
    <content type="text"><![CDATA[Git 如何配置多个 SSH-Key 背景当有多个git账号时，比如： a. 一个gitlab，用于公司内部的工作开发； b. 一个github，用于自己进行一些开发活动； c. 一个gitee，用于其他的一些开发活动； 解决方法（1）生成一个gitlab用的SSH-Key ssh-keygen -t rsa -C &#39;xxx@iyu.pub&#39; -f ~/.ssh/id_rsa_gitlab （2）生成一个github用的SSH-Key ssh-keygen -t rsa -C &#39;xxx@iyu.pub&#39; -f ~/.ssh/id_rsa_github (3)生成一个gitee用的SSH-Key ssh-keygen -t rsa -C &#39;xxx@iyu.pub&#39; -f ~/.ssh/id_rsa_gitee (4)在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径） # gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github # github Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab (5) 用ssh命令分别测试 1.ssh -T git@gitlab.com 成功返回 ==&gt; Welcome to GitLab, @xxx! 2.ssh -T git@github.com 成功返回 ==&gt; Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 3.ssh -T git@gitee.com 成功返回 ==&gt; Hi xxx! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Gitlab</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公共 DNS 域名解析服务]]></title>
    <url>%2Fposts%2F2015-09-11-publicdns%2F</url>
    <content type="text"><![CDATA[平时收集的一些DNS： 百度 DNS：180.76.76.76 阿里 DNS ： 223.5.5.5 和 223.6.6.6 腾讯Public DNS+ : 119.29.29.29 Google : 8.8.8.8 和 8.8.4.4 114dns : 114.114.114.114 &nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java推送天气API]]></title>
    <url>%2Fposts%2F2015-09-08-java-weather-api%2F</url>
    <content type="text"><![CDATA[因为最近在做一个项目，涉及一个小模块——推送天气。根据城市名去找天气的一些信息，比如说，高低温度，实时温度，天气状况，湿度，空气质量AQI等等。 反复找了好多天气API，最后发现小米的API挺不错的，是json格式的数据，方便读取数据。 http://weatherapi.market.xiaomi.com/wtr-v2/weather?cityId= 比如说：深圳的天气代码为101280601 在浏览器上访问http://weatherapi.market.xiaomi.com/wtr-v2/weather?cityId=101280601 如果出现乱码，相信你应该知道怎么解决！ 访问之后，我们拿到如下所示的数据： 相信聪明的你知道怎么看这些数据，转换成如下： &nbsp; 拿到这样的json格式的数据，那就好处理了。 先写一个方法： public static byte[] readInputStream(InputStream inputStream) throws IOException { byte[] buffer = new byte[1024]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((len = inputStream.read(buffer)) != -1) { bos.write(buffer, 0, len); } bos.close(); return bos.toByteArray(); } 再访问API调取数据，直接读取就行： URL url = new URL(“http://weatherapi.market.xiaomi.com/wtr-v2/weather?cityId=101280601&quot;); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); InputStream inputStream = conn.getInputStream(); // 通过输入流获得网站数据 byte[] getData = readInputStream(inputStream); // 获得网站的二进制数据 String data = new String(getData, “utf-8”); System.out.println(“从网页上获取的json:” + data); JSONObject jsonObject01 = JSONObject.fromObject(data); JSONObject jsonObject02 = JSONObject.fromObject(jsonObject01.getJSONObject(“realtime”)); System.out.println(“湿度：” + jsonObject02.getString(“SD”)); System.out.println(“天气：” + jsonObject02.getString(“weather”)); JSONObject jsonObject03 = JSONObject.fromObject(jsonObject01.getJSONObject(“today”)); System.out.println(“高温：” + jsonObject03.getDouble(“tempMax”)); System.out.println(“低温：” + jsonObject03.getDouble(“tempMin”)); JSONObject jsonObject04 = JSONObject.fromObject(jsonObject01.getJSONObject(“aqi”)); System.out.println(“空气质量：” + jsonObject04.getInt(“aqi”)); &nbsp; 这就可以得到自己想读取的数据了。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站时钟]]></title>
    <url>%2Fposts%2F2015-09-07-webclock%2F</url>
    <content type="text"><![CDATA[&lt;div style="width:180px; height:74px; margin:-20px auto 10px auto; overflow:hidden;"&gt; &lt;object width="200" height="88" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=7,0,19,0" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"&gt; &lt;param value="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf" name="movie"&gt; &lt;param value="high" name="quality"&gt; &lt;param value="transparent" name="wmode"&gt; &lt;embed width="200" height="88" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" wmode="transparent" quality="high" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf"&gt; &lt;/object&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress添加网站图标icon]]></title>
    <url>%2Fposts%2F2015-08-27-wordpressicon%2F</url>
    <content type="text"><![CDATA[WordPress 如何添加网站图标icon？ 制作网站图标首先去制作icon的网站（我用的是http://www.bitbug.net/）制作图标图片，大小最好是1616，或者3232的，不要过大了，生成之后下载即可，然后把这个ico格式的图片改名为favicon.ico，直接用FTP软件上传到WordPress根目录。 编辑代码进入WordPress后台，找到“外观”模版下的“编辑”功能，并且编辑“顶部”(header.php)代码。在&lt;head&gt;……&lt;/head&gt;中放入以下代码即可。＜link rel=”shortcut icon” href=”http://www.iyu.pub/favicon.ico&quot;＞中间的网址替换成你的网站地址。 制作完成更新代码，然后刷新网站，即可看到网站的图标了。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《错误》- 郑愁予]]></title>
    <url>%2Fposts%2F2015-08-06-poem-mistake%2F</url>
    <content type="text"><![CDATA[郑愁予-错误 我打江南走过 那等在季节里的容颜如莲花的开落 东风不来，三月的柳絮不飞 你的心如小小的寂寞的城 恰若青石的街道向晚 跫音不项，三月的春帷不揭 你底心是小小的窗扉紧掩 我达达的马蹄声是美丽的错误 我不是归人，是个过客...... 英文译文**Mistake** I passed through the South of Yangzi The face waiting at the turn of seasons, like a lotusflower, blooms and wilts Without the east wind, the willow catkins in Marchdo not futter Your heart is like the lonesome little town Like its streets of cobblestones near nightfall When footfalls are silent and the bed curtains ofMarch not unveiled Your heart is a little window tightly shut My clattering hooves are beautiful mistakes I am not a homecoming man but a passing traveler …]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生十大困惑]]></title>
    <url>%2Fposts%2F2015-08-01-renshengshidakunhuo%2F</url>
    <content type="text"><![CDATA[人生十大困惑 有些事，我们总是弄不懂， 有些人，我们总是猜不透， 有些道，我们总是悟不尽， 有些理，我们总是想不通， 有些坎，我们总是跨不过， 有些伤，我们总是治不好， 有些天，我们总是睡不着， 有些地，我们总是去不了， 有些情，我们总是说不出， 有些爱，我们总是得不到。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实现显示网站运行时间]]></title>
    <url>%2Fposts%2F2015-07-13-php-web-runtime%2F</url>
    <content type="text"><![CDATA[使用PHP实现–显示网站的运行时间 PHP代码：&lt;?php // 设置时区 date_default_timezone_set(&#39;Asia/Shanghai&#39;); /** * 秒转时间，格式 年 月 日 时 分 秒 * @param int $time * @return array|boolean */ function Sec2Time($time)&#123; if(is_numeric($time))&#123; $value = array( &quot;years&quot; =&gt; 0, &quot;days&quot; =&gt; 0, &quot;hours&quot; =&gt; 0, &quot;minutes&quot; =&gt; 0, &quot;seconds&quot; =&gt; 0,); if($time &gt;= 31556926)&#123; $value[&quot;years&quot;] = floor($time/31556926); $time = ($time%31556926); &#125; if($time &gt;= 86400)&#123; $value[&quot;days&quot;] = floor($time/86400); $time = ($time%86400); &#125; if($time &gt;= 3600)&#123; $value[&quot;hours&quot;] = floor($time/3600); $time = ($time%3600); &#125; if($time &gt;= 60)&#123; $value[&quot;minutes&quot;] = floor($time/60); $time = ($time%60); &#125; $value[&quot;seconds&quot;] = floor($time); return (array) $value; &#125;else&#123; return (bool) FALSE; &#125; &#125; // 本站创建的时间 $site_create_time = strtotime(&#39;2015-07-01 00:00:00&#39;); $time = time() - $site_create_time; $uptime = Sec2Time($time); ?&gt; HTML代码：本站已运行： &lt;span style=&quot;color:red;&quot;&gt; &lt;?php echo $uptime[&#39;years&#39;]; ?&gt;年 &lt;?php echo $uptime[&#39;days&#39;]; ?&gt;天 &lt;?php echo $uptime[&#39;hours&#39;]; ?&gt;小时 &lt;?php echo $uptime[&#39;minutes&#39;]; ?&gt;分 &lt;?php echo $uptime[&#39;seconds&#39;]; ?&gt;秒 &lt;/span&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江南烟雨(转载)]]></title>
    <url>%2Fposts%2F2015-07-10-jiangnanyanyu%2F</url>
    <content type="text"><![CDATA[转自散文吧http://www.sanwen8.cn/subject/1391202/ 一&emsp;&emsp;关于故乡的记忆，总是很遥远，远到只能在梦里，才能梦见故乡那栋老房子，在岁月中渐渐隐褪了曾经的色彩；梦见门前的那棵梧桐树，叶子绿了、黄了，落了、抽芽了，任时光的年轮划上一圈又一圈；梦见村口那眼冬暖夏凉的泉，每天氤氲着一股白色的雾气，在人们来来往往水桶撞击的声音中，吟唱着最古老的歌谣。还有，还有外婆在老屋门前一声声地呼唤，带着质朴的乡音，带着最温馨的回忆，飘荡，从梦境到现实，从现实到梦境。 &emsp;&emsp;关于故乡的记忆，总是很近，很近。近到可以听见细雨敲窗，雨打芭蕉；近到可以轻易激起心头泛起的，关于故乡的点滴回忆。桃红柳绿，东风暗换年华，但故乡是心头永远的朱砂，总能轻易地勾起心中最深的记忆与牵挂。 &emsp;&emsp;故乡，是一条纤细的乡村小路，小路上杂草丛生，漫过了白色的球鞋，打湿了清晨的裤脚，一直通向校园的方向，通向遥远的，未知的地方。 &emsp;&emsp;春天来了，水田里的禾苗仿若一个个娇小的绿色人儿，在微风中轻轻地招手，一眼望去，是那一望无际的绿色海洋，这里，孕育着庄稼人一年的希望。 &emsp;&emsp;花开了，开在屋前后那高高的田坎上，开在春风拂过的山岗上。一直以来，对于桃花就有着一种别样的喜爱。桃红点点，粉红的花瓣，随着微风 ，轻轻飘落，零落了多少女儿娇柔的心事。惜春常恨春归早，那时候的我，怎懂得韶华易逝的道理。看着那漫天飞舞的桃花瓣，只是觉得好美，好美。伸出手，让花瓣一片一片，自指尖飘落，纷飞成一季最美、纯洁的梦。那个桃花树下的小小姑娘，扎着短短的马尾巴，就这样眼巴巴地，看着那一树桃红，仿佛透过那朵朵盛开的粉红的花朵，看见了一树的硕果累累，馋了嘴，馋了梦，馋了那一季的美好的童年。 &emsp;&emsp;夏天来了。河水沸腾了。两岸杨柳依依，临水梳妆，一双美眸，静静凝望着不远处，在小河里嬉戏玩闹的大人、小孩。小河的胸怀是宽广的，她默默地容纳着来自心灵人们从心灵深处迸发的欢愉，成为这个季节，大自然最清凉的馈赠。 &emsp;&emsp;田地间，成片成片的玉米地，绿油油的，仿佛一排排卫士，守候着自己的家园。村落间、山林间，时常听见布谷鸟千年不变的吟唱，吟唱着一曲朴实、勤劳的歌谣。我总觉得布谷鸟是在叫“豌豆、包谷”，似是而是，听来感觉是那么一回事。离开故乡以后，就再也听不见它的吟唱了，自然也不知道它究竟唱得什么，但我知道，那一声声啼叫，早已经烙在了我的灵魂深处，在某一个午夜梦回，将我带进那个小小山村，带进那片田园，听一曲而来自布谷鸟的天籁。 &emsp;&emsp;秋天来了。秋，是喜悦，是收获，是农民洋溢的笑脸，是那一把把挥洒的汗水。 &emsp;&emsp;这个时节的农事多，打谷子、收玉米，挖红薯，接踵而来的农事，压弯了农民的脊梁，喜悦着农民酣睡的梦乡。对于孩子来说，这个季节是山地田野间肆意的玩闹，是枝头的硕果累累。各种水果，都卖弄着最成熟的风姿。一个个柿子，高高地挂在枝头，仿佛一个个灯笼，煞是好看。橘子已经开始黄了，可孩子们就喜欢那酸酸甜甜的味道，这个在树上摘，几个在树下巴巴地望着，等着树上的孩子扔下来，然后争相抢着，闹着。枣树下，孩子们一个个拿着常常的竹杠，伸长了脖子，敲敲这颗，敲敲那颗。叫嚷着，这里、这里，那边、那边还有……童声，交织成一片欢喜，在秋的田野，编织着丰收的歌谣。 &emsp;&emsp;我是喜欢冬天的。记忆里的那银装素裹的世界，多少次浮上心头。故乡的冬，没有毛主席笔下的“千里冰封，万里雪飘。”故乡的雪，是安静的。它轻盈地落在山头，轻盈地漫过小河，无声敲打着农户的窗口，将一片雪白的世界悄悄带来。 &emsp;&emsp;冬，是寂静的，偶尔，村落间会传来狗吠的声音。声音落下，枝头的白雪犹如被惊吓了一般，“扑哧哧”落下，溅起细碎的花朵，开在冬季，开在那些孩子的梦里。 &emsp;&emsp;小河醉了，将一枕清梦深藏，藏进来年的春；山野醉了，银装素裹，分外妖娆；农人醉了，酣睡的梦里，酝酿着这一年的喜悦与短暂的休憩…… &emsp;&emsp;故乡是一个梦的摇篮，盛满在希望的田野间，斑斓在千年耕耘的山山水水间。沟沟壑壑的土地上，挥洒着多少农民的汗水，埋藏着多少年复一年的希望与憧憬。田地就是希望，勤劳便是未来，双手可以撑起一段又一段岁月。 二&emsp;&emsp;故乡有山，有水，山清水秀。 &emsp;&emsp;山，必然有着山的魂魄。山的魂魄名为豪迈，一曲曲山歌，粗狂、豪迈，带着原始最朴质的旋律，带着山里人的那份“野性”，从嗓子里吼出来，从灵魂中迸发而出。 &emsp;&emsp;水，必然有着水的灵性。水的灵性是柔情。那水，静静地依偎着这片土地，宛若一条绿色的丝带，成为这片土地上美丽的风景。她宛若一个温润的邻家姑娘，顾盼间，柔情万千。 &emsp;&emsp;有了山，有了水，故乡就有了活力。故乡的四面都被青山的环抱着。春天来了，小草绿了，河水动了，燕子也开始忙碌地衔着春泥。水田里，青青的禾苗贪婪地吮吸着春水，你若细细聆听，必然可以听见麦苗拔节的声音。 &emsp;&emsp;杨柳依依，桃红柳绿，这个时节，自然少不了烟雨朦胧。 &emsp;&emsp;烟雨，是一副山水画！属于耕者的画面。 &emsp;&emsp;岁月在时光的深处划上了不同的符号，而烟雨必然是属于故乡最独特的符号。我没有去过真正的江南，不懂得江南烟雨的那份空灵与美丽，只是肆意地任凭想象的种子在心头绽放成故乡烟雨的模样。 &emsp;&emsp;故乡，是厚重的，而耕者，则是故乡的标志，是一个年代最独特的印记。岁月将曾经挺直的脊梁，一点一点压弯，弯成了耕者最后的画面，弯成了生活最初的模样。 &emsp;&emsp;斜风细雨，天空中的燕子，低低地飞翔着，时不时地掠过耕者的头顶，似乎在悄悄地打量，又或者在低低地呢喃。 &emsp;&emsp;耕者的吆喝、老牛的呐喊、细雨的呢喃，勾勒出故乡最初的轮廓。这轮廓间，泾渭分明，动静交织，在岁月中若隐若现，清晰着关于一个年代的记忆。 &emsp;&emsp;雨，在屋檐处滴答成一首静谧的曲子，若一位少女，将自己的一腔心事，静静地倾诉着。 &emsp;&emsp;有雨的日子，老人们总是斜依在那已经微微有些破旧的、沾满了油渍的沙发上。听着雨声，慵懒地打发着那些闲碎的光阴。他们微闭着眼睛，似乎在将岁月中那些暖暖的记忆反复回味。他们的笑容，浅浅地，脸上的皱纹如同枯萎的花儿一般，保留着最后的姿态。 &emsp;&emsp;女人们坐在堂屋里，听着滴答的雨声，一边拉着鞋底，一边将村子里那些陈旧的芝麻绿豆的小事，翻转。生活的往事，便在唾沫横飞中落定，犹如那些土屋中旮旯犄角里堆积的层层尘埃，一点一点被时光掩埋。 &emsp;&emsp;里屋，孩子们不能若天晴一般在田地间玩耍，此时的他们，仿佛被束缚的鸟儿一般，眼巴巴地看着那落雨的屋檐，看看细雨蒙蒙的天空，任由心思在雨中奔跑着，或者，干脆在大人的呵斥中在院子里嬉戏，任由细雨轻吻着那些稚嫩天真的笑颜。 &emsp;&emsp;有雨，那些圈养的鸡便无精打采地在屋檐下躲着雨，这里一堆，那里一垛的，时不时地抖落着羽毛上沾染的雨滴，时不时地 用爪子在地上划上几道爪印，又或者“咯咯”“咯咯”叫上几声，仿佛也在嘀咕着，“这雨啥时候可以停啊？” &emsp;&emsp;…… &emsp;&emsp;烟雨的日子，故乡是静谧的。远处的青山，静静地打量着，任凭细雨蒙蒙，将往日的尘埃一点一点洗刷，山更绿了。河边的柳，静静地梳理着垂下的发丝，若一位温婉的姑娘，正含羞与这场烟雨相约。路边的野草，不知名的花儿，也随着微风轻轻地摆动着腰肢，贪婪地吮吸着甘甜的“乳汁”。 &emsp;&emsp;烟雨，是故乡的魂，淅淅沥沥下在游子的心头。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获取文本区某一行数据]]></title>
    <url>%2Fposts%2F2015-07-09-java-text%2F</url>
    <content type="text"><![CDATA[Java获取文本中某一行数据的方法： 第一种方法String strArray[] = message.split(&quot;\n&quot;); for(int i=0; i&lt;strArray.length;i++)&#123; System.out.println(&quot;第&quot;+ (i+1) +&quot;行数据为：&quot;+strArray[i]); &#125; 第二种方法JTextArea area = new JTextArea(); area.setText(&quot;fasfsadf\nafdasdfsad\nsafasvcxb\n&quot;); System.out.println(area.getText()); StringTokenizer tokenizer = new StringTokenizer(area.getText(),&quot;\n&quot;); while(tokenizer.hasMoreTokens()) &#123; System.out.println(tokenizer.nextToken()); &#125; for(String str:area.getText().split(&quot;\n&quot;))&#123; System.out.println(str); &#125;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[残荷听雨]]></title>
    <url>%2Fposts%2F2015-07-07-canhetingyu%2F</url>
    <content type="text"><![CDATA[有一种高贵，总让我匍匐膜拜；有一种圣洁，总让我敬重仰视。 那就是残荷，挺立于泥淖之中高贵而圣洁的灵魂花朵。 平生是那么地喜欢荷，不仅因为她美丽的外表，更因为她高洁的品格。中通外直、不蔓不枝是荷花的个性；美而不艳、媚而不俗是荷花的风姿；出淤泥而不染、濯清涟而不妖是她的志向；纯洁高雅、可远观而不可亵玩是她的品德。喜欢荷花“花娇映红玉，艳影照清漪”中的那份宁静；喜欢荷花“三秋庭绿尽迎霜，惟有荷花守红死”的忠贞。 初冬时节，飘雨的午后。独自一人，静立在荷塘边，听雨，与残荷。那雨，浸透了思绪，让人忘了时间，忘了自己，宛如一幅孤零零的剪影，倒映在残荷随意泼就而成的水墨画里，与残荷一起溶入静穆的烟雨中。 残荷的美是一种苍凉悲壮的凄美!落叶知寒，栖鸟南迁，满目萧然，荷已成殇。冷雨中的残荷，落尽繁华，枯黄憔悴，历尽风雨沧桑，世俗无暇顾盼。没有了沁人心脾的幽香，没有了文人骚客的礼赞。悲苦的冷雨落在残荷上，孤寂与落寞溢满一塘。雨点淡淡地漾开，好像在微微地叹息着。看那一塘残荷，满目萍碎，在风雨中，有的高擎着黑褐色的叶子，有的被风雨摧残折断倒立在水中；叶子有的残破，有的蜷曲，有的倒伏泥淖之中或昂首向天，或低头沉尽，—或相互依偎，或枝叶相交……尘世的荣衰，世态的炎凉，莲的心事，谁人能懂? “秋阴不散霜飞晚，留得残荷听雨声。”残荷的美是一种历经沧桑之后的心境，苍凉而悠远；那是经过了万千红尘之后的淡定，脆弱而不屈；那是繁华落尽之后，于凄风冷雨中依然坚守的优雅与从容。也许在她的心中藏着一个美丽的梦，待来年的盛夏，满塘的荷花依旧会在荷叶的拥托之中，亭亭玉立，香远益清。含苞的娇羞欲语，怒放的潇洒舒展。粉荷美艳，白荷净洁，演绎万种风情。 聆听荷的心语，领略荷傲人的风姿。残荷听雨，就是让心在最纯净最圣洁的诗句间游走，就是让心灵积淀一份清澈，就是让灵魂多一次净化。感念着四季的轮回，感念着生命的流逝，我唯愿生命如荷：在繁华褪尽的萧索里，保持生命与生俱来的不屈和圣洁；在凄风冷雨的逆境中，保持灵魂的那份纯真与高贵。 残荷，我向你膜拜：为你的不屈，为你枯搞形骸荧茕而立的气度，为你不以物喜不以己悲的坦然，为蕴藏在你生命中那份孤傲与自信! 静心听雨，仿佛是在聆听生命渐行渐远的足音；听残荷承雨，又仿佛在聆听自己寂寞的心语。一种发自生命深处的感念油然而生：生命当以圣洁为本，灵魂当以高贵为伴，香消玉殒风骨犹在，身形憔悴香气长存。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除wordpress侧边栏功能的wordpress.org和feed链接]]></title>
    <url>%2Fposts%2F2015-07-06-wordpressuse%2F</url>
    <content type="text"><![CDATA[在wordpress功能版块有登入\登出，管理，Feed以外，还有一个wordpress，如何删除它们呢? 具体做法： 找到网站wordpress安装目录 在wp_includes文件夹下面有一个default-widgets.php的文件 在此文件里搜索查找&lt;li标签里带有rss2_url，comments_rss2_url，wordpress.org的三段代码全部删除掉。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现网页跳转后可隐藏跳转后网址的代码]]></title>
    <url>%2Fposts%2F2015-07-03-jsjump%2F</url>
    <content type="text"><![CDATA[网页跳转后，隐藏跳转后网址 方法一&lt;script&gt; window.onload=new function()&#123; window.location=&#39;/home/index.html&#39; &#125;; &lt;/script&gt; 方法二&lt;frameset framespacing=&quot;0&quot; border=&quot;0&quot; rows=&quot;0&quot; frameborder=&quot;0&quot;&gt; &lt;frame name=&quot;main&quot; src=&quot;http://www.iyu.pub/&quot; scrolling=&quot;auto&quot; noresize&gt; &lt;/frameset&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计网站访问量的PHP代码]]></title>
    <url>%2Fposts%2F2015-07-02-clicknumbyphp%2F</url>
    <content type="text"><![CDATA[使用PHP统计网站的访问量 &lt;?php session_start(); if(!isset($_SESSION[‘name’]))&#123; $counterFile = “counter.txt”; $fp = fopen($counterFile,”a+”); $num = fgets($fp,5); $num=$num+1; print “您是第 “.”$num”.” 位访客”; &#125;else&#123; $counterFile = “counter.txt”; $fp = fopen($counterFile,”a+”); $num = fgets($fp,5); $num=$num; print “您是第 “.”$num”.” 位访客”; &#125; fclose($fp); if(!isset($_SESSION[‘name’]))&#123; $fpp=fopen($counterFile,”w”); fwrite($fpp, $num); fclose($fpp);&#125;else&#123;exit(); &#125; $name=”test”; $_SESSION[‘name’]=$name; ?&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计网站运行时间的JavaScript代码]]></title>
    <url>%2Fposts%2F2015-07-02-runtimebyjs%2F</url>
    <content type="text"><![CDATA[有时候需要在静态页上显示网站的运行时间，所以用JavaScript实现。 &lt;span id=”showsectime” style=”color:#FF0000;”&gt;网站已安全运行1天1时1分1秒&lt;/span&gt; &lt;script type=”text/javascript”&gt; function NewDate(str) &#123; str = str.split(‘-‘); var date = new Date(); date.setUTCFullYear(str[0], str[1] – 1, str[2]); date.setUTCHours(0, 0, 0, 0); return date; &#125; function showsectime() &#123; var birthDay =NewDate(“2014-08-14”); var today=new Date(); var timeold=today.getTime()-birthDay.getTime(); var sectimeold=timeold/1000 var secondsold=Math.floor(sectimeold); var msPerDay=246060*1000; var e_daysold=timeold/msPerDay; var daysold=Math.floor(e_daysold); var e_hrsold=(daysold-e_daysold)-24; var hrsold=Math.floor(e_hrsold); var e_minsold=(hrsold-e_hrsold)-60; var minsold=Math.floor((hrsold-e_hrsold)*-60); var seconds=Math.floor((minsold-e_minsold)*-60).toString(); document.getElementById(“showsectime”).innerHTML = “网站已安全运行”+daysold+”天”+hrsold+”时”+minsold+”分”+seconds+”秒”; setTimeout(showsectime, 1000); &#125; showsectime(); &lt;/script&gt;]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听风行 旗下所有站点大全]]></title>
    <url>%2Fposts%2F2015-07-01-allsite%2F</url>
    <content type="text"><![CDATA[不知不觉，撸了一个又一个网站，好多都在吃灰，今天整理下。 主要网站 No. 网站 链接 1 听风行官网 http://iyu.pubhttp://www.iyu.pub 2 听风行博客 http://blog.iyu.pub 3 TingBrowser浏览器 http://browser.iyu.pub 工具网站 No. 网站 链接 1 抖音视频在线解析下载 http://douyin.iyu.pub 2 Tmusic http://music.iyu.pub 3 听风行影视 http://v.iyu.pub(目前网站的视频采集好像有点问题，有时间捉捉虫) 4 VIP视频解析 http://vip.iyu.pubhttp://vip2.iyu.pubhttp://vip3.iyu.pub 5 图床 http://img.iyu.pub 6 壁纸 http://wall.iyu.pub 7 元素周期表 http://fun.iyu.pub/ 8 装逼神器 http://b.iyu.pub 9 百度云直链解析 http://bd.iyu.pub 10 IPTV高清在线直播 http://tv.iyu.pub 游戏网站 No. 网站 链接 1 五子棋 http://wuziqi.iyu.pub 2 中国象棋 http://chess.iyu.pub/ 3 2048 http://2048.iyu.pub/ 4 奇葩版FlappyBird http://textbird.iyu.pub 5 方块版FlappyBird http://rectbird.iyu.pub/ 6 马里奥 http://mario.iyu.pub 7 水果忍者 http://fruit.iyu.pub/ 8 吃豆人 http://chidouren.iyu.pub/ 9 重力下落积木 http://toy.iyu.pub]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>听风行</tag>
        <tag>站点</tag>
      </tags>
  </entry>
</search>
