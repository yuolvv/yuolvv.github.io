<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="听风行" />
  
  
  <title>SpringBoot源码分析(4)-SpringBoot 的自动配置 | 听风行</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Java,Java,SpringBoot,Source," />
  

  
  <meta name="description" content="&amp;emsp;&amp;emsp; 记录SpringBoot的源码分析过程-SpringBoot 的自动配置">

  

  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script>
  

  
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  

  
    <script src="//unpkg.com/valine/dist/Valine.min.js" async></script>
  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"JUB4uWwzKVKwbNzwRvkxgw9F-gzGzoHsz","appkey":"tLtzj0dg7LQTGu9dEY57RYef","comment":true,"count":true},
    welcome: {"enable":true,"interval":30},
    start_time: "2015-07-01",
    passwords: ["383060d16dbbd03a8df851cdc6f513f7fdf4dadd8ae0dc62ae87151f537ec38c", ],
    is_post: true,
    lock: false,
    author: "听风行",
    share: {"twitter":true,"facebook":true,"weibo":true,"qq":true,"wechat":true},
    mathjax: true,
    page_type: "",
    root: "/"
  };
</script>

  
<script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>


  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/favicon.ico">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  
<link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">


  

<meta name="generator" content="Hexo 5.2.0"></head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">听风行</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 虽千万人吾往矣</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/friends/" target="_self">友链</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/yuolvv/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/friends/" target="_self">
            友链
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2020-11-18
    </span>
    
      <span>
        | <a href="/categories/Java/"><i class="fa fa-bookmark"></i>Java</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>Unlock
      </span>
    
  </div>
  <h1 class="passage-title">
    SpringBoot源码分析(4)-SpringBoot 的自动配置
  </h1>
  
    <div class="passage-cover">
      <figure style="background-image:url(https://cn.bing.com/th?id=OHR.HocesDuraton_ZH-CN2152159552_1920x1080.jpg);"></figure>
    </div>
  

  

  <article class="passage-article">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle"
        style="display:block; text-align:center;"
        data-ad-layout="in-article"
        data-ad-format="fluid"
        data-ad-client="ca-pub-2795125801721613"
        data-ad-slot="7468094198"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

    <p>上一篇我们分析了SpringBoot的条件注解@ConditionalOnXXX的相关源码，总结如下：</p>
<ol>
<li>SpringBoot的所有@ConditionalOnXxx的条件类OnXxxCondition都是继承于SpringBootCondition基类，而SpringBootCondition又实现了Condition接口。</li>
<li>SpringBootCondition基类主要用来打印一些条件注解评估报告的日志，这些条件评估信息全部来源于其子类注解条件类OnXxxCondition，因此其也抽象了一个模板方法getMatchOutcome留给子类去实现来评估其条件注解是否符合条件。</li>
<li>前一篇还有一个重要的知识点没分析，那就是跟过滤自动配置类逻辑有关的AutoConfigurationImportFilter接口，这篇文章来分析一下。</li>
</ol>
<p>前面分析了跟SpringBoot的自动配置息息相关内置条件注解@ConditionalOnXxx后，现在就开始来分析跟SpringBoot自动配置的相关源码。</p>
<h1 id="1-SpringBootApplication注解"><a href="#1-SpringBootApplication注解" class="headerlink" title="1.@SpringBootApplication注解"></a>1.@SpringBootApplication注解</h1><p>思考下，SpringBoot为何一个标注有@SpringBootApplication注解的启动类通过执行一个简单的run方法就能实现SpringBoot大量Starter的自动配置呢？ </p>
<p>其实SpringBoot自动配置就跟@SpringBootApplication这个注解有关，先来看下这个注解的源码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@SpringBootConfiguration</span></span><br><span class="line"><span class="variable">@EnableAutoConfiguration</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="variable">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		<span class="variable">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public <span class="variable">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">	 * @return the classes to exclude</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="variable">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">	Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">	 * applied.</span></span><br><span class="line"><span class="comment">	 * @return the class names to exclude</span></span><br><span class="line"><span class="comment">	 * @since 1.3.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="variable">@AliasFor</span>(annotation = EnableAutoConfiguration.class)</span><br><span class="line">	String[] excludeName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Base packages to scan for annotated components. Use &#123;@link #scanBasePackageClasses&#125;</span></span><br><span class="line"><span class="comment">	 * for a type-safe alternative to String-based package names.</span></span><br><span class="line"><span class="comment">	 * @return base packages to scan</span></span><br><span class="line"><span class="comment">	 * @since 1.3.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="variable">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">&quot;basePackages&quot;</span>)</span><br><span class="line">	String[] scanBasePackages() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Type-safe alternative to &#123;@link #scanBasePackages&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">	 * scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment">	 * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment">	 * @return base packages to scan</span></span><br><span class="line"><span class="comment">	 * @since 1.3.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="variable">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">&quot;basePackageClasses&quot;</span>)</span><br><span class="line">	Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@SpringBootApplication标注了很多注解，可以看到其中跟SpringBoot自动配置有关的注解就只有@EnableAutoConfiguration，因此，可以肯定的是SpringBoot的自动配置肯定跟@EnableAutoConfiguration相关(其中@ComponentScan注解的excludeFilters属性也有一个类AutoConfigurationExcludeFilter,这个类跟自动配置也有点关系，但不是我们关注的重点)。 </p>
<p>现在我们来打开@EnableAutoConfiguration注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">	 * applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到@EnableAutoConfiguration注解又标有@AutoConfigurationPackage和@Import(AutoConfigurationImportSelector.class)两个注解。</p>
<p>@AutoConfigurationPackage注解肯定跟自动配置的包有关，而AutoConfigurationImportSelector则是跟SpringBoot的自动配置选择导入有关（Spring中的ImportSelector是用来导入配置类的，通常是基于某些条件注解@ConditionalOnXxxx来决定是否导入某个配置类）。</p>
<p>因此，需要重点分析AutoConfigurationImportSelector类，因为SpringBoot的自动配置肯定有一个配置类，而这个配置类的导入则需要靠AutoConfigurationImportSelector来实现。</p>
<h1 id="2-SpringBoot自动配置实现逻辑的入口方法"><a href="#2-SpringBoot自动配置实现逻辑的入口方法" class="headerlink" title="2.SpringBoot自动配置实现逻辑的入口方法"></a>2.SpringBoot自动配置实现逻辑的入口方法</h1><p>可以肯定的是SpringBoot的自动配置的逻辑肯定与AutoConfigurationImportSelector这个类有关，那么该如何找到SpringBoot自动配置实现逻辑的入口方法呢？</p>
<p>AutoConfigurationImportSelector的相关类图：</p>
<p><img src="https://i.loli.net/2020/12/01/D8z45yuimcJIgCW.png" alt="sb16.png"></p>
<p>可以看到AutoConfigurationImportSelector重点是实现了DeferredImportSelector接口和各种Aware接口，然后DeferredImportSelector接口又继承了ImportSelector接口。</p>
<p>AutoConfigurationImportSelector复写DeferredImportSelector接口的实现方法selectImports方法，因为selectImports方法跟导入自动配置类有关，而这个方法往往是程序执行的入口方法。经过调试发现，selectImports方法跟自动配置相关的逻辑有点关系，但实质关系不大。</p>
<p>又该如何来找到自动配置逻辑有关的入口方法呢？</p>
<p>最简单的方法就是在AutoConfigurationImportSelector类的每个方法都打上断点，然后调试看先执行到哪个方法，但是这样太复杂了。自定义一个Starter的时候，要在spring.factories配置文件中配置</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">EnableAutoConfiguration</span>=XxxAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>因此可以推断，SpringBoot的自动配置原理肯定跟从spring.factories配置文件中加载自动配置类有关，于是结合AutoConfigurationImportSelector的方法注释，我们找到了getAutoConfigurationEntry方法。于是在这个方法里面打上一个断点，此时通过调用栈帧来看下更上层的入口方法在哪里，然后再从跟自动配置相关的更上层的入口方法开始分析。</p>
<p><img src="https://i.loli.net/2020/12/01/48APY1QhzxrZWTw.png" alt="sb17.png"></p>
<p>通过上图可以看到，跟自动配置逻辑相关的入口方法在DeferredImportSelectorGrouping类的getImports方法处，因此就从DeferredImportSelectorGrouping类的getImports方法来开始分析SpringBoot的自动配置源码。</p>
<h1 id="3-分析SpringBoot自动配置原理"><a href="#3-分析SpringBoot自动配置原理" class="headerlink" title="3.分析SpringBoot自动配置原理"></a>3.分析SpringBoot自动配置原理</h1><p>既然找到ConfigurationClassParser.getImports()方法是自动配置相关的入口方法，那么下面就来真正分析SpringBoot自动配置的源码。</p>
<p>先看一下getImports方法代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line">	<span class="comment">// 遍历DeferredImportSelectorHolder对象集合deferredImports，deferredImports集合装了各种ImportSelector，当然这里装的是AutoConfigurationImportSelector</span></span><br><span class="line">	<span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : <span class="keyword">this</span>.deferredImports) &#123;</span><br><span class="line">		<span class="comment">// 【1】利用AutoConfigurationGroup的process方法来处理自动配置的相关逻辑，决定导入哪些配置类（这个是分析的重点，自动配置的逻辑全在这）</span></span><br><span class="line">		<span class="keyword">this</span>.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">				deferredImport.getImportSelector());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 【2】经过上面的处理后，然后再进行选择导入哪些配置类</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.group.selectImports();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【1】处的的代码是分析的重点，自动配置相关的大部分逻辑全在这里，深入分析自动配置的主要逻辑。那么this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector())；主要做的事情就是在this.group即AutoConfigurationGroup对象的process方法中，传入的AutoConfigurationImportSelector对象来选择一些符合条件的自动配置类，过滤掉一些不符合条件的自动配置类。</p>
<ol>
<li>AutoConfigurationGroup：是AutoConfigurationImportSelector的内部类，主要用来处理自动配置相关的逻辑，拥有process和selectImports方法，然后拥有entries和autoConfigurationEntries集合属性，这两个集合分别存储被处理后的符合条件的自动配置类；</li>
<li>AutoConfigurationImportSelector：承担自动配置的大部分逻辑，负责选择一些符合条件的自动配置类；</li>
<li>metadata:标注在SpringBoot启动类上的@SpringBootApplication注解元数据</li>
</ol>
<p>【2】的this.group.selectImports的方法主要是针对前面的process方法处理后的自动配置类再进一步有选择的选择导入。</p>
<h2 id="3-1-分析自动配置的主要逻辑"><a href="#3-1-分析自动配置的主要逻辑" class="headerlink" title="3.1 分析自动配置的主要逻辑"></a>3.1 分析自动配置的主要逻辑</h2><p>这里继续深究前面【1】处的 this.group.process方法是如何处理自动配置相关逻辑的。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用来处理自动配置类，比如过滤掉不符合匹配条件的自动配置类</span></span><br><span class="line">@Override</span><br><span class="line">public void process(AnnotationMetadata annotationMetadata,</span><br><span class="line">		DeferredImportSelector deferredImportSelector) &#123;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span>state(</span><br><span class="line">			deferredImportSelector instanceof AutoConfigurationImportSelector,</span><br><span class="line">			<span class="literal">()</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">					<span class="module-access"><span class="module"><span class="identifier">AutoConfigurationImportSelector</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">SimpleName()</span>,</span><br><span class="line">					deferredImportSelector.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>));</span><br><span class="line">	<span class="comment">// 【1】,调用getAutoConfigurationEntry方法得到自动配置类放入autoConfigurationEntry对象中</span></span><br><span class="line">	AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">			.get<span class="constructor">AutoConfigurationEntry(<span class="params">getAutoConfigurationMetadata</span>()</span>,</span><br><span class="line">					annotationMetadata);</span><br><span class="line">	<span class="comment">// 【2】，又将封装了自动配置类的autoConfigurationEntry对象装进autoConfigurationEntries集合</span></span><br><span class="line">	this.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">	<span class="comment">// 【3】，遍历刚获取的自动配置类</span></span><br><span class="line">	<span class="keyword">for</span> (String importClassName : autoConfigurationEntry.get<span class="constructor">Configurations()</span>) &#123;</span><br><span class="line">		<span class="comment">// 这里符合条件的自动配置类作为key，annotationMetadata作为值放进entries集合</span></span><br><span class="line">		this.entries.put<span class="constructor">IfAbsent(<span class="params">importClassName</span>, <span class="params">annotationMetadata</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中再来看标【1】的方法getAutoConfigurationEntry，这个方法主要是用来获取自动配置类有关，承担了自动配置的主要逻辑。直接上代码：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 获取符合条件的自动配置类，避免加载不必要的自动配置类从而造成内存浪费</span><br><span class="line">protected AutoConfigurationEntry getAutoConfigurationEntry(</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata,</span><br><span class="line">		AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">	<span class="regexp">//</span> 获取是否有配置spring.boot.enableautoconfiguration属性，默认返回true</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		return EMPTY_ENTRY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="regexp">//</span> 获得@Congiguration标注的Configuration类即被审视introspectedClass的注解数据，</span><br><span class="line">	<span class="regexp">//</span> 比如：@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class)</span><br><span class="line">	<span class="regexp">//</span> 将会获取到exclude = FreeMarkerAutoConfiguration.class和excludeName=<span class="string">&quot;&quot;</span>的注解数据</span><br><span class="line">	AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">	<span class="regexp">//</span> 【<span class="number">1</span>】得到spring.factories文件配置的所有自动配置类</span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">			attributes);</span><br><span class="line">	<span class="regexp">//</span> 利用LinkedHashSet移除重复的配置类</span><br><span class="line">	configurations = removeDuplicates(configurations);</span><br><span class="line">	<span class="regexp">//</span> 得到要排除的自动配置类，比如注解属性exclude的配置类</span><br><span class="line">	<span class="regexp">//</span> 比如：@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class)</span><br><span class="line">	<span class="regexp">//</span> 将会获取到exclude = FreeMarkerAutoConfiguration.class的注解数据</span><br><span class="line">	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">	<span class="regexp">//</span> 检查要被排除的配置类，因为有些不是自动配置类，故要抛出异常</span><br><span class="line">	checkExcludedClasses(configurations, exclusions);</span><br><span class="line">	<span class="regexp">//</span> 【<span class="number">2</span>】将要排除的配置类移除</span><br><span class="line">	configurations.removeAll(exclusions);</span><br><span class="line">	<span class="regexp">//</span> 【<span class="number">3</span>】因为从spring.factories文件获取的自动配置类太多，如果有些不必要的自动配置类都加载进内存，会造成内存浪费，因此这里需要进行过滤</span><br><span class="line">	<span class="regexp">//</span> 注意这里会调用AutoConfigurationImportFilter的match方法来判断是否符合@ConditionalOnBean,@ConditionalOnClass或@ConditionalOnWebApplication，后面会重点分析一下</span><br><span class="line">	configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">	<span class="regexp">//</span> 【<span class="number">4</span>】获取了符合条件的自动配置类后，此时触发AutoConfigurationImportEvent事件，</span><br><span class="line">	<span class="regexp">//</span> 目的是告诉ConditionEvaluationReport条件评估报告器对象来记录符合条件的自动配置类</span><br><span class="line">	<span class="regexp">//</span> 该事件什么时候会被触发？--&gt; 在刷新容器时调用invokeBeanFactoryPostProcessors后置处理器时触发</span><br><span class="line">	fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">	<span class="regexp">//</span> 【<span class="number">5</span>】将符合条件和要排除的自动配置类封装进AutoConfigurationEntry对象，并返回</span><br><span class="line">	return new AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AutoConfigurationEntry方法主要做的事情就是获取符合条件的自动配置类，避免加载不必要的自动配置类从而造成内存浪费。下面总结下AutoConfigurationEntry方法主要做的事情：</p>
<p>【1】从spring.factories配置文件中加载EnableAutoConfiguration自动配置类（注意此时是从缓存中拿到的）,获取的自动配置类如下图所示。</p>
<p>【2】若@EnableAutoConfiguration等注解标有要exclude的自动配置类，那么再将这个自动配置类排除掉；</p>
<p>【3】排除掉要exclude的自动配置类后，然后再调用filter方法进行进一步的过滤，再次排除一些不符合条件的自动配置类；</p>
<p>【4】经过重重过滤后，此时再触发AutoConfigurationImportEvent事件，告诉ConditionEvaluationReport条件评估报告器对象来记录符合条件的自动配置类；</p>
<p>【5】 最后再将符合条件的自动配置类返回。</p>
<p><img src="https://i.loli.net/2020/12/01/AEl2FdCyY7vIZiS.png" alt="sb18.png"></p>
<p>总结了AutoConfigurationEntry方法主要的逻辑后，再来细看一下AutoConfigurationImportSelector的filter方法：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">String</span>&gt; <span class="built_in">filter</span>(List&lt;<span class="keyword">String</span>&gt; configurations,</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata) &#123;</span><br><span class="line">	<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">	<span class="comment">// 将从spring.factories中获取的自动配置类转出字符串数组</span></span><br><span class="line">	<span class="keyword">String</span>[] candidates = StringUtils.toStringArray(configurations);</span><br><span class="line">	<span class="comment">// 定义skip数组，是否需要跳过。注意skip数组与candidates数组顺序一一对应</span></span><br><span class="line">	<span class="built_in">boolean</span>[] skip = <span class="keyword">new</span> <span class="built_in">boolean</span>[candidates.length];</span><br><span class="line">	<span class="built_in">boolean</span> skipped = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// getAutoConfigurationImportFilters方法：拿到OnBeanCondition，OnClassCondition和OnWebApplicationCondition</span></span><br><span class="line">	<span class="comment">// 然后遍历这三个条件类去过滤从spring.factories加载的大量配置类</span></span><br><span class="line">	<span class="keyword">for</span> (AutoConfigurationImportFilter <span class="built_in">filter</span> : getAutoConfigurationImportFilters()) &#123;</span><br><span class="line">		<span class="comment">// 调用各种aware方法，将beanClassLoader,beanFactory等注入到filter对象中，</span></span><br><span class="line">		<span class="comment">// 这里的filter对象即OnBeanCondition，OnClassCondition或OnWebApplicationCondition</span></span><br><span class="line">		invokeAwareMethods(<span class="built_in">filter</span>);</span><br><span class="line">		<span class="comment">// 判断各种filter来判断每个candidate（这里实质要通过candidate(自动配置类)拿到其标注的</span></span><br><span class="line">		<span class="comment">// @ConditionalOnClass,@ConditionalOnBean和@ConditionalOnWebApplication里面的注解值）是否匹配，</span></span><br><span class="line">		<span class="comment">// 注意candidates数组与match数组一一对应</span></span><br><span class="line">		<span class="comment">/**********************【主线，重点关注】********************************/</span></span><br><span class="line">		<span class="built_in">boolean</span>[] <span class="built_in">match</span> = <span class="built_in">filter</span>.<span class="built_in">match</span>(candidates, autoConfigurationMetadata);</span><br><span class="line">		<span class="comment">// 遍历match数组，注意match顺序跟candidates的自动配置类一一对应</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">match</span>.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 若有不匹配的话</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">match</span>[i]) &#123;</span><br><span class="line">				<span class="comment">// 不匹配的将记录在skip数组，标志skip[i]为true，也与candidates数组一一对应</span></span><br><span class="line">				skip[i] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">// 因为不匹配，将相应的自动配置类置空</span></span><br><span class="line">				candidates[i] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="comment">// 标注skipped为true</span></span><br><span class="line">				skipped = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里表示若所有自动配置类经过OnBeanCondition，OnClassCondition和OnWebApplicationCondition过滤后，全部都匹配的话，则全部原样返回</span></span><br><span class="line">	<span class="keyword">if</span> (!skipped) &#123;</span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 建立result集合来装匹配的自动配置类</span></span><br><span class="line">	List&lt;<span class="keyword">String</span>&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.length);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 若skip[i]为false，则说明是符合条件的自动配置类，此时添加到result集合中</span></span><br><span class="line">		<span class="keyword">if</span> (!skip[i]) &#123;</span><br><span class="line">			result.<span class="built_in">add</span>(candidates[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印日志</span></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		<span class="built_in">int</span> numberFiltered = configurations.<span class="built_in">size</span>() - result.<span class="built_in">size</span>();</span><br><span class="line">		logger.trace(<span class="string">&quot;Filtered &quot;</span> + numberFiltered + <span class="string">&quot; auto configuration class in &quot;</span></span><br><span class="line">				+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)</span><br><span class="line">				+ <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后返回符合条件的自动配置类</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AutoConfigurationImportSelector的filter方法主要做的事情就是调用AutoConfigurationImportFilter接口的match方法来判断每一个自动配置类上的条件注解（若有的话）@ConditionalOnClass,@ConditionalOnBean或@ConditionalOnWebApplication是否满足条件，若满足，则返回true，说明匹配，若不满足，则返回false说明不匹配。</p>
<h2 id="3-2-有选择的导入自动配置类"><a href="#3-2-有选择的导入自动配置类" class="headerlink" title="3.2 有选择的导入自动配置类"></a>3.2 有选择的导入自动配置类</h2><p>继续深究前面分析SpringBoot自动配置原理这节标【2】处的 this.group.selectImports方法是如何进一步有选择的导入自动配置类的。直接看代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector$AutoConfigurationGroup.java</span></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Entry&gt; <span class="title">selectImports</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.autoConfigurationEntries.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里得到所有要排除的自动配置类的set集合</span></span><br><span class="line">	Set&lt;<span class="keyword">String</span>&gt; allExclusions = <span class="keyword">this</span>.autoConfigurationEntries.stream()</span><br><span class="line">			.<span class="built_in">map</span>(AutoConfigurationEntry::getExclusions)</span><br><span class="line">			.flatMap(Collection::stream).collect(Collectors.toSet());</span><br><span class="line">	<span class="comment">// 这里得到经过滤后所有符合条件的自动配置类的set集合</span></span><br><span class="line">	Set&lt;<span class="keyword">String</span>&gt; processedConfigurations = <span class="keyword">this</span>.autoConfigurationEntries.stream()</span><br><span class="line">			.<span class="built_in">map</span>(AutoConfigurationEntry::getConfigurations)</span><br><span class="line">			.flatMap(Collection::stream)</span><br><span class="line">			.collect(Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>));</span><br><span class="line">	<span class="comment">// 移除掉要排除的自动配置类</span></span><br><span class="line">	processedConfigurations.removeAll(allExclusions);</span><br><span class="line">	<span class="comment">// 对标注有@Order注解的自动配置类进行排序，</span></span><br><span class="line">	<span class="keyword">return</span> sortAutoConfigurations(processedConfigurations,</span><br><span class="line">			getAutoConfigurationMetadata())</span><br><span class="line">					.stream()</span><br><span class="line">					.<span class="built_in">map</span>((importClassName) -&gt; <span class="keyword">new</span> Entry(</span><br><span class="line">							<span class="keyword">this</span>.entries.<span class="built_in">get</span>(importClassName), importClassName))</span><br><span class="line">					.collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，selectImports方法主要是针对经过排除掉exclude的和被AutoConfigurationImportFilter接口过滤后的满足条件的自动配置类再进一步排除exclude的自动配置类，然后再排序。</p>
<p>疑问: 前面已经exclude过一次了，为何这里还要再exclude一次？</p>
<h1 id="4-AutoConfigurationImportFilter"><a href="#4-AutoConfigurationImportFilter" class="headerlink" title="4.AutoConfigurationImportFilter"></a>4.AutoConfigurationImportFilter</h1><p>继续分析前面的 AutoConfigurationImportSelector.filter方法的过滤自动配置类的boolean[] match = filter.match(candidates, autoConfigurationMetadata);这行代码。</p>
<p>因此继续分析AutoConfigurationImportFilter接口，分析其match方法，同时也是对前一篇@ConditionalOnXxx的源码分析文章中留下的问题进行补充。</p>
<p>AutoConfigurationImportFilter接口只有一个match方法用来过滤不符合条件的自动配置类。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">AutoConfigurationImportFilter</span> &#123;</span><br><span class="line">	<span class="built_in">bool</span>ean[] match(String[] <span class="built_in">auto</span>ConfigurationClasses,</span><br><span class="line">			AutoConfigurationMetadata <span class="built_in">auto</span>ConfigurationMetadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析AutoConfigurationImportFilter接口的match方法前，先看下类关系图：</p>
<p><img src="https://i.loli.net/2020/12/01/1mkb8yfY7taGW3z.png" alt="sb19.png"></p>
<p>可以看到AutoConfigurationImportFilter接口有一个具体的实现类FilteringSpringBootCondition，FilteringSpringBootCondition又有三个具体的子类：OnClassCondition,OnBeanCondtition和OnWebApplicationCondition。</p>
<p>那么这几个类之间的关系是怎样的呢？</p>
<p>FilteringSpringBootCondition实现了AutoConfigurationImportFilter接口的match方法，然后在FilteringSpringBootCondition的match方法调用getOutcomes这个抽象模板方法返回自动配置类的匹配与否的信息。同时，最重要的是FilteringSpringBootCondition的三个子类OnClassCondition,OnBeanCondtition和OnWebApplicationCondition将会复写这个模板方法实现自己的匹配判断逻辑。</p>
<p>好了，AutoConfigurationImportFilter接口的整体关系已经清楚了，现在再进入其具体实现类FilteringSpringBootCondition的match方法看看是其如何根据条件过滤自动配置类的。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilteringSpringBootCondition.java</span></span><br><span class="line">@Override</span><br><span class="line">public boolean<span class="literal">[]</span> <span class="keyword">match</span>(String<span class="literal">[]</span> autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123;</span><br><span class="line">	<span class="comment">// 创建评估报告</span></span><br><span class="line">	ConditionEvaluationReport report = <span class="module-access"><span class="module"><span class="identifier">ConditionEvaluationReport</span>.</span></span>find(this.beanFactory);</span><br><span class="line">	<span class="comment">// 注意getOutcomes是模板方法，将spring.factories文件种加载的所有自动配置类传入</span></span><br><span class="line">	<span class="comment">// 子类（这里指的是OnClassCondition,OnBeanCondition和OnWebApplicationCondition类）去过滤</span></span><br><span class="line">	<span class="comment">// 注意outcomes数组存储的是不匹配的结果，跟autoConfigurationClasses数组一一对应</span></span><br><span class="line">	<span class="comment">/*****************************【主线，重点关注】*********************************************/</span></span><br><span class="line">	ConditionOutcome<span class="literal">[]</span> outcomes = get<span class="constructor">Outcomes(<span class="params">autoConfigurationClasses</span>, <span class="params">autoConfigurationMetadata</span>)</span>;</span><br><span class="line">	boolean<span class="literal">[]</span> <span class="keyword">match</span> = <span class="keyword">new</span> boolean<span class="literal">[<span class="identifier">outcomes</span>.<span class="identifier">length</span>]</span>;</span><br><span class="line">	<span class="comment">// 遍历outcomes,这里outcomes为null则表示匹配，不为null则表示不匹配</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; outcomes.length; i++) &#123;</span><br><span class="line">		<span class="keyword">match</span><span class="literal">[<span class="identifier">i</span>]</span> = (outcomes<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>null<span class="operator"> || </span>outcomes<span class="literal">[<span class="identifier">i</span>]</span>.is<span class="constructor">Match()</span>);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">match</span><span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> &amp;&amp; </span>outcomes<span class="literal">[<span class="identifier">i</span>]</span> != null) &#123;</span><br><span class="line">			<span class="comment">// 这里若有某个类不匹配的话，此时调用父类SpringBootCondition的logOutcome方法打印日志</span></span><br><span class="line">			log<span class="constructor">Outcome(<span class="params">autoConfigurationClasses</span>[<span class="params">i</span>], <span class="params">outcomes</span>[<span class="params">i</span>])</span>;</span><br><span class="line">			<span class="comment">// 并将不匹配情况记录到report</span></span><br><span class="line">			<span class="keyword">if</span> (report != null) &#123;</span><br><span class="line">				report.record<span class="constructor">ConditionEvaluation(<span class="params">autoConfigurationClasses</span>[<span class="params">i</span>], <span class="params">this</span>, <span class="params">outcomes</span>[<span class="params">i</span>])</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">match</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FilteringSpringBootCondition的match方法主要做的事情还是调用抽象模板方法getOutcomes来根据条件来过滤自动配置类，而复写getOutcomes模板方法的有三个子类，这里不再一一分析，只挑选OnClassCondition复写的getOutcomes方法进行分析。</p>
<h2 id="4-1-OnClassCondition"><a href="#4-1-OnClassCondition" class="headerlink" title="4.1 OnClassCondition"></a>4.1 OnClassCondition</h2><p>OnClassCondition复写的getOutcomes方法的代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition.java</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConditionOutcome[] getOutcomes(String[] <span class="built_in">auto</span>ConfigurationClasses,</span><br><span class="line">		AutoConfigurationMetadata <span class="built_in">auto</span>ConfigurationMetadata) &#123;</span><br><span class="line">	<span class="comment">// Split the work and perform half in a background thread. Using a single</span></span><br><span class="line">	<span class="comment">// additional thread seems to offer the best performance. More threads make</span></span><br><span class="line">	<span class="comment">// things worse</span></span><br><span class="line">	<span class="comment">// 这里经过测试用两个线程去跑的话性能是最好的，大于两个线程性能反而变差</span></span><br><span class="line">	<span class="built_in">int</span> split = <span class="built_in">auto</span>ConfigurationClasses.length / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 【1】开启一个新线程去扫描判断已经加载的一半自动配置类</span></span><br><span class="line">	OutcomesResolver firstHalfResolver = createOutcomesResolver(<span class="built_in">auto</span>ConfigurationClasses, <span class="number">0</span>, split, <span class="built_in">auto</span>ConfigurationMetadata);</span><br><span class="line">	<span class="comment">// 【2】这里用主线程去扫描判断已经加载的一半自动配置类</span></span><br><span class="line">	OutcomesResolver secondHalfResolver = new StandardOutcomesResolver(<span class="built_in">auto</span>ConfigurationClasses, split, <span class="built_in">auto</span>ConfigurationClasses.length, <span class="built_in">auto</span>ConfigurationMetadata, getBeanClassLoader());</span><br><span class="line">	<span class="comment">// 【3】先让主线程去执行解析一半自动配置类是否匹配条件</span></span><br><span class="line">	ConditionOutcome[] secondHalf = secondHalfResolver.resolveOutcomes();</span><br><span class="line">	<span class="comment">// 【4】这里用新开启的线程取解析另一半自动配置类是否匹配</span></span><br><span class="line">	<span class="comment">// 注意为了防止主线程执行过快结束，resolveOutcomes方法里面调用了thread.join()来</span></span><br><span class="line">	<span class="comment">// 让主线程等待新线程执行结束，因为后面要合并两个线程的解析结果</span></span><br><span class="line">	ConditionOutcome[] firstHalf = firstHalfResolver.resolveOutcomes();</span><br><span class="line">	<span class="comment">// 新建一个ConditionOutcome数组来存储自动配置类的筛选结果</span></span><br><span class="line">	ConditionOutcome[] outcomes = new ConditionOutcome[<span class="built_in">auto</span>ConfigurationClasses.length];</span><br><span class="line">	<span class="comment">// 将前面两个线程的筛选结果分别拷贝进outcomes数组</span></span><br><span class="line">	System.<span class="built_in">array</span>copy(firstHalf, <span class="number">0</span>, outcomes, <span class="number">0</span>, firstHalf.length);</span><br><span class="line">	System.<span class="built_in">array</span>copy(secondHalf, <span class="number">0</span>, outcomes, split, secondHalf.length);</span><br><span class="line">	<span class="comment">// 返回自动配置类的筛选结果</span></span><br><span class="line">	<span class="keyword">return</span> outcomes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，OnClassCondition的getOutcomes方法主要解析自动配置类是否符合匹配条件，当然这个匹配条件指自动配置类上的注解@ConditionalOnClass指定的类存不存在于classpath中，存在则返回匹配，不存在则返回不匹配。</p>
<p>由于解析自动配置类是否匹配比较耗时，因此从上面代码中我们可以看到分别创建了firstHalfResolver和secondHalfResolver两个解析对象，这两个解析对象个分别对应一个线程去解析加载的自动配置类是否符合条件，最终将两个线程的解析自动配置类的匹配结果合并后返回。</p>
<p>那么自动配置类是否符合条件的解析判断过程又是怎样的呢？现在我们分别来看一下上面代码注释标注的【1】，【2】，【3】和【4】处。</p>
<h3 id="4-1-1-createOutcomesResolver"><a href="#4-1-1-createOutcomesResolver" class="headerlink" title="4.1.1 createOutcomesResolver"></a>4.1.1 createOutcomesResolver</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> OutcomesResolver <span class="title">createOutcomesResolver</span><span class="params">(<span class="keyword">String</span>[] autoConfigurationClasses,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, AutoConfigurationMetadata autoConfigurationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 新建一个StandardOutcomesResolver对象</span></span><br><span class="line">	OutcomesResolver outcomesResolver = <span class="keyword">new</span> StandardOutcomesResolver(</span><br><span class="line">			autoConfigurationClasses, start, <span class="built_in">end</span>, autoConfigurationMetadata,</span><br><span class="line">			getBeanClassLoader());</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// new一个ThreadedOutcomesResolver对象，并将StandardOutcomesResolver类型的outcomesResolver对象作为构造器参数传入</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ThreadedOutcomesResolver(outcomesResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若上面开启的线程抛出AccessControlException异常，则返回StandardOutcomesResolver对象</span></span><br><span class="line">	<span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">		<span class="keyword">return</span> outcomesResolver;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到createOutcomesResolver方法创建了一个封装了StandardOutcomesResolver类的ThreadedOutcomesResolver解析对象。再来看下ThreadedOutcomesResolver这个线程解析类封装StandardOutcomesResolver这个对象的目的是什么？继续跟进代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadedOutcomesResolver</span>(<span class="params">OutcomesResolver outcomesResolver</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 这里开启一个新的线程，这个线程其实还是利用StandardOutcomesResolver的resolveOutcomes方法</span></span><br><span class="line">	<span class="comment">// 对自动配置类进行解析判断是否匹配</span></span><br><span class="line">	<span class="keyword">this</span>.thread = <span class="keyword">new</span> Thread(</span><br><span class="line">			() -&gt; <span class="keyword">this</span>.outcomes = outcomesResolver.resolveOutcomes());</span><br><span class="line">	<span class="comment">// 开启线程</span></span><br><span class="line">	<span class="keyword">this</span>.thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在构造ThreadedOutcomesResolver对象时候，原来是开启了一个线程，然后这个线程其实还是调用了刚传进来的StandardOutcomesResolver对象的resolveOutcomes方法去解析自动配置类。</p>
<h3 id="4-1-2-new-StandardOutcomesResolver"><a href="#4-1-2-new-StandardOutcomesResolver" class="headerlink" title="4.1.2 new StandardOutcomesResolver()"></a>4.1.2 new StandardOutcomesResolver()</h3><p>逻辑很简单，就是创建了一个StandardOutcomesResolver对象，用于后面解析自动配置类是否匹配，同时，新建的一个线程也是利用它来完成自动配置类的解析的。</p>
<h3 id="4-1-3-StandardOutcomesResolver-resolveOutcomes"><a href="#4-1-3-StandardOutcomesResolver-resolveOutcomes" class="headerlink" title="4.1.3 StandardOutcomesResolver.resolveOutcomes()"></a>4.1.3 StandardOutcomesResolver.resolveOutcomes()</h3><p>这个方法承担了解析自动配置类匹配与否的全部逻辑，是需要重点分析的方法，resolveOutcomes方法最终把解析的自动配置类的结果赋给secondHalf数组。那么它是如何解析自动配置类是否匹配条件的呢？</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition$StandardOutcomesResolver.java</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> ConditionOutcome[] resolveOutcomes() &#123;</span><br><span class="line">	<span class="comment">// 再调用getOutcomes方法来解析</span></span><br><span class="line">	<span class="keyword">return</span> getOutcomes(<span class="keyword">this</span>.<span class="built_in">auto</span>ConfigurationClasses, <span class="keyword">this</span>.start, <span class="keyword">this</span>.end,</span><br><span class="line">			<span class="keyword">this</span>.<span class="built_in">auto</span>ConfigurationMetadata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConditionOutcome[] getOutcomes(String[] <span class="built_in">auto</span>ConfigurationClasses,</span><br><span class="line">		<span class="built_in">int</span> start, <span class="built_in">int</span> end, AutoConfigurationMetadata <span class="built_in">auto</span>ConfigurationMetadata) &#123;</span><br><span class="line">	<span class="comment">// 只要autoConfigurationMetadata没有存储相关自动配置类，那么outcome默认为null，则说明匹配</span></span><br><span class="line">	ConditionOutcome[] outcomes = new ConditionOutcome[end - start];</span><br><span class="line">	<span class="comment">// 遍历每一个自动配置类</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">		String <span class="built_in">auto</span>ConfigurationClass = <span class="built_in">auto</span>ConfigurationClasses[i];</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">			* TODO 对于autoConfigurationMetadata有个疑问：</span></span><br><span class="line"><span class="comment">			* 为何有些自动配置类的条件注解能被加载到autoConfigurationMetadata，而有些又不能，</span></span><br><span class="line"><span class="comment">			* 比如自己定义的一个自动配置类HelloWorldEnableAutoConfiguration就没有被存到autoConfigurationMetadata中</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">auto</span>ConfigurationClass != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 这里取出注解在AutoConfiguration自动配置类类的@ConditionalOnClass注解的指定类的全限定名，</span></span><br><span class="line">			<span class="comment">// 举个栗子，看下面的KafkaStreamsAnnotationDrivenConfiguration这个自动配置类</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">				* @ConditionalOnClass(StreamsBuilder.class)</span></span><br><span class="line"><span class="comment">				* class KafkaStreamsAnnotationDrivenConfiguration &#123;</span></span><br><span class="line"><span class="comment">				* // 省略无关代码</span></span><br><span class="line"><span class="comment">				* &#125;</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">			<span class="comment">// 那么取出的就是StreamsBuilder类的全限定名即candidates = org.apache.kafka.streams.StreamsBuilder</span></span><br><span class="line">			String candidates = <span class="built_in">auto</span>ConfigurationMetadata.<span class="keyword">get</span>(<span class="built_in">auto</span>ConfigurationClass, <span class="string">&quot;ConditionalOnClass&quot;</span>);</span><br><span class="line">			<span class="comment">// 因为这里是处理某个类是否存在于classpath中，所以传入的key是ConditionalOnClass</span></span><br><span class="line">			<span class="comment">// 若自动配置类标有ConditionalOnClass注解且有值，此时调用getOutcome判断是否存在于类路径中</span></span><br><span class="line">			<span class="keyword">if</span> (candidates != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 拿到自动配置类注解@ConditionalOnClass的值后，再调用getOutcome方法去判断匹配结果,若该类存在于类路径，则getOutcome返回null，否则非null</span></span><br><span class="line">				<span class="comment">/*******************【主线，重点关注】******************/</span></span><br><span class="line">				outcomes[i - start] = getOutcome(candidates);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> outcomes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>StandardOutcomesResolver.resolveOutcomes</code>的方法中再次调用<code>getOutcomes</code>方法，主要是从<code>autoConfigurationMetadata</code>对象中获取到自动配置类上的注解<code>@ConditionalOnClass</code>指定的类的全限定名，然后作为参数传入<code>getOutcome</code>方法用于去类路径加载该类，若能加载到则说明注解<code>@ConditionalOnClass</code>满足条件，此时说明自动配置类匹配成功。</p>
<p>但是别忘了，这里只是分析了<code>@ConditionalOnClass</code>注解，若自动配置类还有其他注解比如<code>@ConditionalOnBean</code>，若该<code>@ConditionalOnBean</code>注解不满足条件的话，同样最终结果是不匹配的。回到<code>OnClassCondtion</code>的判断逻辑，继续进入<code>getOutcome</code>方法看它是如何去判断<code>@ConditionalOnClass</code>注解满不满足条件的。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition$StandardOutcomesResolver.java</span></span><br><span class="line"><span class="comment">// 返回的outcome记录的是不匹配的情况，不为null，则说明不匹配；为null，则说明匹配</span></span><br><span class="line"><span class="keyword">private</span> ConditionOutcome get<span class="constructor">Outcome(String <span class="params">candidates</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// candidates的形式为“org.springframework.boot.autoconfigure.aop.AopAutoConfiguration.ConditionalOnClass=org.aspectj.lang.annotation.Aspect,org.aspectj.lang.reflect.Advice,org.aspectj.weaver.AnnotatedElement”</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 自动配置类上@ConditionalOnClass的值只有一个的话，直接调用getOutcome方法判断是否匹配</span></span><br><span class="line">		<span class="keyword">if</span> (!candidates.contains(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">			<span class="comment">// 看到因为传入的参数是 ClassNameFilter.MISSING，因此可以猜测这里应该是得到不匹配的结果</span></span><br><span class="line">			<span class="comment">/******************【主线，重点关注】********************/</span></span><br><span class="line">			return get<span class="constructor">Outcome(<span class="params">candidates</span>, ClassNameFilter.MISSING, <span class="params">this</span>.<span class="params">beanClassLoader</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自动配置类上@ConditionalOnClass的值有多个的话，则遍历每个值（其值以逗号，分隔）</span></span><br><span class="line">		<span class="keyword">for</span> (String candidate : <span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>comma<span class="constructor">DelimitedListToStringArray(<span class="params">candidates</span>)</span>) &#123;</span><br><span class="line">			ConditionOutcome outcome = get<span class="constructor">Outcome(<span class="params">candidate</span>, ClassNameFilter.MISSING, <span class="params">this</span>.<span class="params">beanClassLoader</span>)</span>;</span><br><span class="line">			<span class="comment">// 可以看到，这里只要有一个不匹配的话，则返回不匹配结果</span></span><br><span class="line">			<span class="keyword">if</span> (outcome != null) &#123;</span><br><span class="line">				return outcome;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		<span class="comment">// We&#x27;ll get another chance later</span></span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>getOutcome</code>方法再次调用重载方法<code>getOutcome</code>进一步去判断注解<code>@ConditionalOnClass</code>指定的类存不存在类路径中，跟着主线继续跟进去：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition$StandardOutcomesResolver.java</span></span><br><span class="line"><span class="keyword">private</span> ConditionOutcome get<span class="constructor">Outcome(String <span class="params">className</span>, ClassNameFilter <span class="params">classNameFilter</span>, ClassLoader <span class="params">classLoader</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 调用classNameFilter的matches方法来判断`@ConditionalOnClass`指定的类存不存在类路径中</span></span><br><span class="line">	<span class="comment">/******************【主线，重点关注】********************/</span></span><br><span class="line">	<span class="keyword">if</span> (classNameFilter.matches(className, classLoader)) &#123;</span><br><span class="line">		<span class="comment">// 这里调用classNameFilter去判断className是否存在于类路径中，</span></span><br><span class="line">		<span class="comment">// 其中ClassNameFilter又分为PRESENT和MISSING两种;</span></span><br><span class="line">		<span class="comment">// 目前只看到ClassNameFilter为MISSING的调用情况，所以默认为true的话记录不匹配信息；</span></span><br><span class="line">		<span class="comment">// 若传入ClassNameFilter为PRESENT的话，估计还要再写一个else分支</span></span><br><span class="line">		return <span class="module-access"><span class="module"><span class="identifier">ConditionOutcome</span>.</span></span>no<span class="constructor">Match(ConditionMessage.<span class="params">forCondition</span>(ConditionalOnClass.<span class="params">class</span>)</span>.did<span class="constructor">NotFind(<span class="string">&quot;required class&quot;</span>)</span>.items(Style.QUOTE, className));</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一层一层的剥，最终剥到了最底层了，这个真的需要足够耐心，没办法，源码只能一点一点的啃。可以看到最终是调用<code>ClassNameFilter</code>的<code>matches</code>方法来判断<code>@ConditionalOnClass</code>指定的类存不存在类路径中,若不存在的话，则返回不匹配。</p>
<p>继续跟进<code>ClassNameFilter</code>的源码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilteringSpringBootCondition.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">enum</span> ClassNameFilter &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里表示指定的类存在于类路径中，则返回true</span></span><br><span class="line">	PRESENT &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">matches</span>(<span class="params"><span class="built_in">String</span> className, ClassLoader classLoader</span>)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> isPresent(className, classLoader);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里表示指定的类不存在于类路径中，则返回true</span></span><br><span class="line">	MISSING &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">matches</span>(<span class="params"><span class="built_in">String</span> className, ClassLoader classLoader</span>)</span> &#123;</span><br><span class="line">			<span class="comment">// 若classpath不存在className这个类，则返回true</span></span><br><span class="line">			<span class="keyword">return</span> !isPresent(className, classLoader);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这又是一个抽象方法，分别被PRESENT和MISSING枚举类实现</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">boolean</span> matches(<span class="built_in">String</span> className, ClassLoader classLoader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查指定的类是否存在于类路径中</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> <span class="function"><span class="title">isPresent</span>(<span class="params"><span class="built_in">String</span> className, ClassLoader classLoader</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (classLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">			classLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用类加载器去加载相应类，若没有抛出异常则说明类路径中存在该类，此时返回true</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			forName(className, classLoader);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若不存在于类路径中，此时抛出的异常将catch住，返回false。</span></span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 利用类加载器去加载指定的类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; forName(<span class="built_in">String</span> className, ClassLoader classLoader)</span><br><span class="line">			throws ClassNotFoundException &#123;</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> classLoader.loadClass(className);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Class.forName(className);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>ClassNameFilter</code>原来是<code>FilteringSpringBootCondition</code>的一个内部枚举类，实现了判断指定类是否存在于<code>classpath</code>中的逻辑。</p>
<h3 id="4-1-4-ThreadedOutcomesResolver-resolveOutcomes"><a href="#4-1-4-ThreadedOutcomesResolver-resolveOutcomes" class="headerlink" title="4.1.4 ThreadedOutcomesResolver.resolveOutcomes()"></a>4.1.4 ThreadedOutcomesResolver.resolveOutcomes()</h3><p>这里是用新开启的线程去调用<code>StandardOutcomesResolver.resolveOutcomes</code>方法解析另一半自动配置类是否匹配，因为是新线程，这里很可能会出现这么一种情况：主线程解析完属于自己解析的一半自动配置类后，那么就继续往下跑了，此时不会等待新开启的子线程的。</p>
<p>因此，为了让主线程解析完后，需要让主线程继续等待正在解析的子线程，直到子线程结束。那么继续跟进代码区看下<code>ThreadedOutcomesResolver.resolveOutcomes</code>方法是怎样实现让主线程等待子线程的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition$ThreadedOutcomesResolver.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConditionOutcome[] resolveOutcomes() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 调用子线程的Join方法，让主线程等待</span></span><br><span class="line">		<span class="keyword">this</span>.thread.join();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">		Thread.currentThread().interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若子线程结束后，此时返回子线程的解析结果</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.outcomes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到用了<code>Thread.join()</code>方法来让主线程等待正在解析自动配置类的子线程，这里应该也可以用<code>CountDownLatch</code>来让主线程等待子线程结束。最终将子线程解析后的结果赋给<code>firstHalf</code>数组。</p>
<h2 id="4-2-OnBeanCondition-和-OnWebApplicationCondition"><a href="#4-2-OnBeanCondition-和-OnWebApplicationCondition" class="headerlink" title="4.2 OnBeanCondition 和 OnWebApplicationCondition"></a>4.2 OnBeanCondition 和 OnWebApplicationCondition</h2><p>前面深入分析了<code>OnClassCondition</code>是如何过滤自动配置类的，那么自动配置类除了要经过<code>OnClassCondition</code>的过滤，还要经过<code>OnBeanCondition</code>和<code>OnWebApplicationCondition</code>这两个条件类的过滤，可自行分析。</p>
<h1 id="5-AutoConfigurationImportListener"><a href="#5-AutoConfigurationImportListener" class="headerlink" title="5.AutoConfigurationImportListener"></a>5.AutoConfigurationImportListener</h1><p>继续分析前面<br><code>AutoConfigurationImportSelector.getAutoConfigurationEntry</code>方法的触发自动配置类过滤完毕的事件<code>fireAutoConfigurationImportEvents(configurations, exclusions);</code>这句代码。</p>
<p>直接点进<code>fireAutoConfigurationImportEvents</code>方法看看其是如何触发事件的：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.java</span></span><br><span class="line"><span class="keyword">private</span> void fire<span class="constructor">AutoConfigurationImportEvents(List&lt;String&gt; <span class="params">configurations</span>, Set&lt;String&gt; <span class="params">exclusions</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 从spring.factories总获取到AutoConfigurationImportListener即ConditionEvaluationReportAutoConfigurationImportListener</span></span><br><span class="line">	List&lt;AutoConfigurationImportListener&gt; listeners = get<span class="constructor">AutoConfigurationImportListeners()</span>;</span><br><span class="line">	<span class="keyword">if</span> (!listeners.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">		<span class="comment">// 新建一个AutoConfigurationImportEvent事件</span></span><br><span class="line">		AutoConfigurationImportEvent event = <span class="keyword">new</span> <span class="constructor">AutoConfigurationImportEvent(<span class="params">this</span>, <span class="params">configurations</span>, <span class="params">exclusions</span>)</span>;</span><br><span class="line">		<span class="comment">// 遍历刚获取到的AutoConfigurationImportListener</span></span><br><span class="line">		<span class="keyword">for</span> (AutoConfigurationImportListener listener : listeners) &#123;</span><br><span class="line">			<span class="comment">// 这里调用各种Aware方法用于触发事件前赋值，比如设置factory,environment等</span></span><br><span class="line">			invoke<span class="constructor">AwareMethods(<span class="params">listener</span>)</span>;</span><br><span class="line">			<span class="comment">// 真正触发AutoConfigurationImportEvent事件即回调listener的onXXXEveent方法。这里用于记录自动配置类的评估信息</span></span><br><span class="line">			listener.on<span class="constructor">AutoConfigurationImportEvent(<span class="params">event</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，<code>fireAutoConfigurationImportEvents</code>方法做了以下两件事情：</p>
<ol>
<li>调用<code>getAutoConfigurationImportListeners</code>方法从<code>spring.factories</code>配置文件获取实现<code>AutoConfigurationImportListener</code>接口的事件监听器；如下图，可以看到获取的是<code>ConditionEvaluationReportAutoConfigurationImportListener</code>：</li>
</ol>
<p><img src="https://i.loli.net/2020/12/01/JaQkUX8zYR2Iven.png" alt="sb20.png"></p>
<ol start="2">
<li>遍历获取的各个事件监听器，然后调用监听器各种<code>Aware</code>方法给监听器赋值，最后再依次回调事件监听器的<code>onAutoConfigurationImportEvent</code>方法，执行监听事件的逻辑。</li>
</ol>
<p>此时再来看下<code>ConditionEvaluationReportAutoConfigurationImportListener</code>监听器监听到事件后，它的<code>onAutoConfigurationImportEvent</code>方法究竟做了哪些事情：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConditionEvaluationReportAutoConfigurationImportListener.java</span></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAutoConfigurationImportEvent</span>(<span class="params">AutoConfigurationImportEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 获取到条件评估报告器对象</span></span><br><span class="line">		ConditionEvaluationReport report = ConditionEvaluationReport.<span class="keyword">get</span>(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">		<span class="comment">// 将符合条件的自动配置类记录到unconditionalClasses集合中</span></span><br><span class="line">		report.recordEvaluationCandidates(<span class="keyword">event</span>.getCandidateConfigurations());</span><br><span class="line">		<span class="comment">// 将要exclude的自动配置类记录到exclusions集合中</span></span><br><span class="line">		report.recordExclusions(<span class="keyword">event</span>.getExclusions());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>ConditionEvaluationReportAutoConfigurationImportListener</code>监听器监听到事件后，做的事情很简单，只是分别记录下符合条件和被<code>exclude</code>的自动配置类。</p>
<h1 id="6-AutoConfigurationPackages"><a href="#6-AutoConfigurationPackages" class="headerlink" title="6.AutoConfigurationPackages"></a>6.AutoConfigurationPackages</h1><p>前面已经详述了SpringBoot的自动配置原理了，最后，跟SpringBoot自动配置有关的注解<code>@AutoConfigurationPackage</code>还没分析，来看下这个注解的源码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@Import</span>(AutoConfigurationPackages.Registrar.class)</span><br><span class="line">public <span class="variable">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>@AutoConfigurationPackage</code>注解是跟SpringBoot自动配置所在的包相关的，即将 添加该注解的类所在的package 作为 自动配置package 进行管理。</p>
<p>接下来我们再看看<code>AutoConfigurationPackages.Registrar</code>类是干嘛的，直接看源码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AutoConfigurationPackages.Registrar.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="title">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> registerBeanDefinitions(AnnotationMetadata metadata,</span><br><span class="line">			BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">Set</span>&lt;<span class="built_in">Object</span>&gt; <span class="function"><span class="title">determineImports</span>(<span class="params">AnnotationMetadata metadata</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>Registrar</code>类是<code>AutoConfigurationPackages</code>的静态内部类，实现了<code>ImportBeanDefinitionRegistrar</code>和<code>DeterminableImports</code>两个接口。现在主要来关注下<code>Registrar</code>实现的<code>registerBeanDefinitions</code>方法，这个方法是注册<code>bean</code>定义的方法。看到它又调用了<code>AutoConfigurationPackages</code>的<code>register</code>方法，继续跟进源码：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void register(<span class="keyword">BeanDefinitionRegistry </span>registry, String... packageNames) &#123;</span><br><span class="line">	if (registry.containsBeanDefinition(<span class="keyword">BEAN)) </span>&#123;</span><br><span class="line">		<span class="keyword">BeanDefinition </span><span class="keyword">beanDefinition </span>= registry.getBeanDefinition(<span class="keyword">BEAN);</span></span><br><span class="line"><span class="keyword">	</span>	ConstructorArgumentValues constructorArguments = <span class="keyword">beanDefinition</span></span><br><span class="line"><span class="keyword">	</span>			.getConstructorArgumentValues();</span><br><span class="line">		constructorArguments.<span class="keyword">addIndexedArgumentValue(0,</span></span><br><span class="line"><span class="keyword">	</span>			<span class="keyword">addBasePackages(constructorArguments, </span>packageNames));</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		GenericBeanDefinition <span class="keyword">beanDefinition </span>= new GenericBeanDefinition();</span><br><span class="line">		<span class="keyword">beanDefinition.setBeanClass(BasePackages.class);</span></span><br><span class="line"><span class="keyword">	</span>	<span class="keyword">beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0,</span></span><br><span class="line"><span class="keyword">	</span>			packageNames);</span><br><span class="line">		<span class="keyword">beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span></span><br><span class="line"><span class="keyword">	</span>	registry.registerBeanDefinition(<span class="keyword">BEAN, </span><span class="keyword">beanDefinition);</span></span><br><span class="line"><span class="keyword">	</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，可以看到<code>register</code>方法注册了一个<code>packageNames</code>即自动配置类注解<code>@EnableAutoConfiguration</code>所在的所在的包名相关的<code>bean</code>。那么注册这个<code>bean</code>的目的是为了什么呢？</p>
<p>结合注释知道，注册这个自动配置包名相关的<code>bean</code>是为了被其他地方引用，比如<code>JPA entity scanner</code>。 </p>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h1><p>最后，再总结下SpringBoot自动配置的原理，主要做了以下事情：</p>
<ol>
<li>从spring.factories配置文件中加载自动配置类；</li>
<li>加载的自动配置类中排除掉<code>@EnableAutoConfiguration</code>注解的<code>exclude</code>属性指定的自动配置类；</li>
<li>然后再用<code>AutoConfigurationImportFilter</code>接口去过滤自动配置类是否符合其标注注解（若有标注的话）<code>@ConditionalOnClass</code>,<code>@ConditionalOnBean</code>和<code>@ConditionalOnWebApplication</code>的条件，若都符合的话则返回匹配结果；</li>
<li>然后触发<code>AutoConfigurationImportEvent</code>事件，告诉<code>ConditionEvaluationReport</code>条件评估报告器对象来分别记录符合条件和<code>exclude</code>的自动配置类。</li>
<li>最后spring再将最后筛选后的自动配置类导入IOC容器中</li>
</ol>
<h2 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h2><blockquote>
<p>为了避免加载不必要的自动配置类造成内存浪费，<code>FilteringSpringBootCondition</code>用于过滤<code>spring.factories</code>文件的自动配置类，而<code>FilteringSpringBootCondition</code>为啥只有<code>OnOnBeanCondition</code>,<code>OnClassCondition</code>和<code>onWebApplicationCondition</code>这三个条件类用于过滤，为啥没有<code>onPropertyCondtion</code>，<code>onResourceCondition</code>等条件类来过滤自动配置类呢？</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.<span class="built_in">auto</span>configure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.<span class="built_in">auto</span>configure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.<span class="built_in">auto</span>configure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.<span class="built_in">auto</span>configure.condition.OnWebApplicationCondition</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ttyy1112/article/details/101284541">https://blog.csdn.net/ttyy1112/article/details/101284541</a></li>
</ol>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-SpringBootApplication%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.@SpringBootApplication注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E7%9A%84%E5%85%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-text">2.SpringBoot自动配置实现逻辑的入口方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%88%86%E6%9E%90SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-text">3.分析SpringBoot自动配置原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%88%86%E6%9E%90%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E9%80%BB%E8%BE%91"><span class="toc-text">3.1 分析自动配置的主要逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%9C%89%E9%80%89%E6%8B%A9%E7%9A%84%E5%AF%BC%E5%85%A5%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">3.2 有选择的导入自动配置类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-AutoConfigurationImportFilter"><span class="toc-text">4.AutoConfigurationImportFilter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-OnClassCondition"><span class="toc-text">4.1 OnClassCondition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-createOutcomesResolver"><span class="toc-text">4.1.1 createOutcomesResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-new-StandardOutcomesResolver"><span class="toc-text">4.1.2 new StandardOutcomesResolver()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-StandardOutcomesResolver-resolveOutcomes"><span class="toc-text">4.1.3 StandardOutcomesResolver.resolveOutcomes()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-ThreadedOutcomesResolver-resolveOutcomes"><span class="toc-text">4.1.4 ThreadedOutcomesResolver.resolveOutcomes()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-OnBeanCondition-%E5%92%8C-OnWebApplicationCondition"><span class="toc-text">4.2 OnBeanCondition 和 OnWebApplicationCondition</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-AutoConfigurationImportListener"><span class="toc-text">5.AutoConfigurationImportListener</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-AutoConfigurationPackages"><span class="toc-text">6.AutoConfigurationPackages</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-text">7.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%96%91%E9%97%AE%EF%BC%9A"><span class="toc-text">疑问：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol>
  </div>
</aside>
  
    <aside class="passage-copyright">
      <div>本文作者: 听风行</div>
      
        <div>
          原文链接: 
          <a href="" target="_blank">https://blog.iyu.pub/posts/2020-11-18-SpringBoot-Source-04/</a>
        </div>
      
      <div>
        版权声明: 本博客所有文章除特别声明外, 均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议. 转载请注明出处!
      </div>
    </aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/Java/"><i class="fa fa-tags"></i>Java</a>
     
      <a href="/tags/SpringBoot/"><i class="fa fa-tags"></i>SpringBoot</a>
     
      <a href="/tags/Source/"><i class="fa fa-tags"></i>Source</a>
    
    </div>
  
</div>

    </main>
    
      
<div class="site-comment-contanier" data-plateform="leancloud">
  
    <p id="site-comment-info">
      <i class="fa fa-spinner fa-spin"></i> 评论加载中
    </p>
    <div id="site-comment"></div>
  
</div>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
      
        <div class="site-footer-col">
          <h5 class="site-footer-title">友链推荐</h5>
          
            <span class="site-footer-item">
              <a href="https://www.iyu.pub" target="_blank">听风行官网</a>
            </span>
          
            <span class="site-footer-item">
              <a href="https://browser.iyu.pub" target="_blank">TingBrowser</a>
            </span>
          
            <span class="site-footer-item">
              <a href="https://www.zhyui.com" target="_blank">Timogal</a>
            </span>
          
            <span class="site-footer-item">
              <a href="http://www.sqliu.cn" target="_blank">桥帮主</a>
            </span>
          
        </div>
      
        <div class="site-footer-col">
          <h5 class="site-footer-title">服务器推荐</h5>
          
            <span class="site-footer-item">
              <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=5e3lfzbh" target="_blank">阿里云服务器</a>
            </span>
          
            <span class="site-footer-item">
              <a href="https://cloud.tencent.com/redirect.php?redirect=1001&cps_key=4a5ddee5a29f458f6de46e4f27bc904e&from=console" target="_blank">腾讯云服务器</a>
            </span>
          
            <span class="site-footer-item">
              <a href="https://cloud.baidu.com/campaign/partner/index.html?teamCode=GC6E98UL" target="_blank">百度云服务器</a>
            </span>
          
        </div>
      
        <div class="site-footer-col">
          <h5 class="site-footer-title">社交の平台</h5>
          
            <span class="site-footer-item">
              <a href="https://twitter.com/tingfengxing" target="_blank">Twitter</a>
            </span>
          
            <span class="site-footer-item">
              <a href="https://www.facebook.com/tingfengxing" target="_blank">Facebook</a>
            </span>
          
        </div>
      
    
    <div class="site-footer-info">
      <i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>
    </div>
    
      <div class="site-footer-info">
        <i class="fa fa-paw"></i> 您是本站第 <span id="site-count"></span> 位访客
      </div>
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> <a href="mailto:Email: 0@iyu.pub">Email: 0@iyu.pub
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2015~2023 <a href="https://blog.iyu.pub" target="_blank">https://blog.iyu.pub</a>.
      Created by <a href="https://177.im/" target="_blank">听风行</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <div class="site-layer-input-choose">
          <a href="javascript:void(0);" title="Change Search Engine">Google</a>
        </div>
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
        <div class="site-layer-reward" id="site-layer-reward" style="display: none;">
          
            <div>
              <img src="/images/wechat.png" alt="WeChat">
              
                <p>WeChat</p>
              
            </div>
          
            <div>
              <img src="/images/alipay.png" alt="AliPay">
              
                <p>AliPay</p>
              
            </div>
          
        </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/posts/2020-11-19-SpringBoot-Source-05/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/posts/2020-11-17-SpringBoot-Source-03/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
      <a href="#site-comment" data-enable="true">
        <i class="fa fa-commenting"></i>
      </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
      <a href="javascript:void(0);" id="site-reward">
        <i class="fa fa-thumbs-up"></i>
      </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
    <a id="share-btn-twitter" href="javascript:void(0);" target="_blank">
      <i class="fa fa-twitter"></i>
    </a>
  
  
    <a id="share-btn-facebook" href="javascript:void(0);" target="_blank">
      <i class="fa fa-facebook"></i>
    </a>
  
  
    <a id="share-btn-weibo" href="javascript:void(0);" target="_blank">
      <i class="fa fa-weibo"></i>
    </a>
  
  
    <a id="share-btn-qq" href="javascript:void(0);" target="_blank">
      <i class="fa fa-qq"></i>
    </a>
  
  
    <a id="share-btn-wechat" href="javascript:void(0);" target="_blank">
      <i class="fa fa-wechat"></i>
    </a>
  
</div>
    
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-88629664-2"></script>
  <script async>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-88629664-2');
  </script>



  <script async>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>




    

    <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "2133ab6ff866479db3e4979524888b83"}'></script>

  </body>
</html>